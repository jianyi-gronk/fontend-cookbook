## 1. 文件上传

<img src="https://img-blog.csdnimg.cn/5c0bd272339a41cebe9b241cae8dd45b.png">

#### 单文件上传

- 文件上传，只要把 input 标签的 type 设置为 file，可以选择 **单一，任意形式** 的文件
  ```
  <input id="uploadFile" type="file" />
  <button id="submit" onclick="uploadFile()">上传文件</button>
  ```
- 如果要指定上传文件的类型，可以通过 input 标签的 accept 属性来进行限制
  ```
  // 这里使用 image/* 限制只能选择图片文件
  // 也可以设置特定的类型，比如 image/png，image/jpeg 或 image/png,image/jpeg（两种类型二选一均可）
  <input id="uploadFile" type="file" accept="image/*" />
  <button id="submit" onclick="uploadFile()">上传文件</button>
  ```

#### 多文件上传

- 需要加上 multiple 属性，可以允许上传多个文件
  ```
  <input id="uploadFile" type="file" accept="image/*" multiple />
  <button id="submit" onclick="uploadFile()">上传文件</button>
  ```

#### 目录上传

- 需要加上 webkitdirectory 属性，可以允许上传目录
  ```
  <input id="uploadFile" type="file" accept="image/*" webkitdirectory />
  <button id="submit" onclick="uploadFile()">上传文件</button>
  ```
- 当获取文件列表时，列表中的文件对象上含有一个 webkitRelativePath 属性，用于表示当前文件的相对路径

#### 压缩目录上传

- 本质还是上传文件后，js 对文件进行处理（把目录下的所有文件压缩成 ZIP 文件，然后把生成的 ZIP 文件上传到服务器）
- JSZip 是一个用于创建、读取和编辑 .zip 文件的 JavaScript 库，该库支持大多数浏览器，并且官方已经为我们提供了 解压本地文件、解压远程文件 和 生成 ZIP 文件 的完整示例

#### 拖拽上传

- 拖拽相关的 api
  - dragstart 事件
    - 当拖拽元素开始被拖拽时触发
    - 作用于被拖拽的元素
  - dragenter 事件
    - 当拖拽元素或选中的文本到一个可释放目标时触发
    - 作用于目标元素
  - dragover 事件
    - 当元素或选中的文本被拖到一个可释放目标上时触发（每 100 毫秒触发一次）
    - 作用于目标元素
  - dragleave 事件
    - 当拖拽元素或选中的文本离开一个可释放目标时触发
    - 作用于目标元素
  - dragend 事件
    - 当拖拽完成后触发时触发
    - 作用于被拖拽的元素
  - drop 事件
    - 当元素或选中的文本在可释放目标上被释放时触发
    - 作用于目标元素
  - **基于上面的这些事件，我们就可以提高用户拖拽的体验**。比如当用户拖拽的元素进入目标区域时，对目标区域进行高亮显示。当用户拖拽的元素离开目标区域时，移除高亮显示
  - **当 drop 事件触发后，拖拽的元素已经放入目标区域了，这时就需要获取对应的数据**
- DataTransfer 对象用于保存拖动并放下（drag and drop）过程中的数据。它可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型，这个对象可以从所有拖动事件 **drag 事件的 events 参数的 dataTransfer 属性上**获取，上面有属性
  - **files（重要的，上传文件的时候用到的）**
    - **包含数据传输中可用的所有本地文件的列表。如果拖动操作不涉及拖动文件，则此属性为空列表**
  - dropEffect
    - 获取当前选定的拖放操作类型或者设置的为一个新的类型。值必须为 none, copy, link 或 move
  - effectAllowed
    - 提供所有可用的操作类型。必须是 none, copy, copyLink, copyMove, link, linkMove, move, all or uninitialized 之一
  - items（只读）
    - 提供一个包含所有拖动数据列表的 DataTransferItemList 对象
  - types（只读）
    - 一个提供 dragstart 事件中设置的格式的 strings 数组
- **监听 “ 上传区域 ” 的 drop 事件，触发的时候，读取 event 的 dataTransfer 属性 的 files 属性，然后进行上传操作即可**

#### 剪贴板上传

- 如果用户授予了相应的权限，Clipboard API 就能提供系统剪贴板的读写访问。在 Web 应用程序中，Clipboard API 可用于实现剪切、复制和粘贴功能。该 API 用于取代通过 document.execCommand API 来实现剪贴板的操作，可以通过 navigator.clipboard 来获取 Clipboard 对象
- 什么时候获取系统剪贴板里的文件呢，通过监听 “ 上传区域 ” 的 paste 事件，在发生 粘贴 操作时触发，绑定的元素不一定是 input，普通的 div 也是可以绑定的

#### 大文件分块上传

- 在上传大文件时，为了提高上传的效率，我们一般会使用 Blob.slice() 方法对大文件按照指定的大小进行切割，然后通过多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并
  - Blob 对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作 File 对象一样操作 Blob 对象，实际上，File 继承自 Blob
  - Blob.slice() 方法用于创建一个包含源 Blob 的指定字节范围内的数据的新 Blob 对象

<img src="https://img-blog.csdnimg.cn/cefc37f1ccd5456f89f70bc7023a33e8.png#pic_center">

<img src="https://img-blog.csdnimg.cn/89387920a0e34955859267d64661deca.png#pic_center">

#### 服务端上传

服务器上传就是把文件从一台服务器上传到另外一台服务器，借助 Github 上 form-data 这个库提供的功能，我们可以很容易地实现服务器上传的功能

## 2. 文件下载

- 一般后端会提供下载的方式有两种
  - 直接返回文件的网络地址（一般用在静态文件上，比如图片以及各种音视频资源等）
  - 返回文件流（一般用在动态文件上，比如根据前端选择，导出不同的统计结果 excel 等）

#### 直接返回资源路径

- 通过 window.open
  - 只要提供了文件的服务器地址，使用 window.open 也就是在新窗口打开，这时浏览器会自动执行下载
- 通过 a 标签
  - 基础写法
    ```
    <a href="./calamus.pdf">下载</a>
    ```
  - 但是，对于 txt , jpg , pdf 等浏览器支持直接打开的文件不会被执行下载，而是会直接打开，这时候就要用到新属性 download 了，download 也可以为空，这样就是默认文件名，如果不为空，则可以规定下载时的文件名
    ```
    <a href="./calamus.pdf" download="filename.pdf">download</a>
    ```
  - 不过兼容性并不好，但是，虽然不兼容，但不代表完全不支持，IE 和 Safari 不会直接下载，但是会有下载提示框弹出，只是多绕了一步而已。如果不想借助后台而要实现文件下载，给 a 标签加 download 绝对是首选之策

#### 返回文件流

- axios 下载
  - 请求发送的时候需要设置 responseType 为 "blob"，不设置时，下载文本类型的文件没有问题，但是下载二进制文件的话，比如视频或者图片，下载之后总是无法正常打开，前后端也没有任何错误提示，responseType 为 blob 的话，二进制文件才能正常下载，而且文本类型的文件也能正常下载打开
  - 如果 responseType 没有设置为 blob，new Blob 的时候需要传入第二个参数，比如
    ```
    new Blob([res], { type: xhr.getResponseHeader("Content-Type") });
    ```

## 3. SSO 单点登录

#### 出现场景

- 在项目初期，公司中使用的系统很少，通常一个或者两个，每个系统都有自己的登录系统，用户用自己的账号登录，很方便
- 但随着公司的不断发展，用到的系统随之增多，用户在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于用户来说，是很不好的体验。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢
- 因此出现了单点登录（ Single Sign On ），简称为 SSO，是比较流行的企业业务整合的解决方案之一，SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统

#### 实现思路

<img src="https://img-blog.csdnimg.cn/9127d035f70240cda550d51be86a3535.png">

- 如图所示，图中有 4 个系统，分别是 Application1、Application2、Application3、和 SSO
- Application1、Application2、Application3 没有登录模块，而 SSO 只有登录模块，没有其他的业务模块，当 Application1、Application2、Application3 需要登录时，将跳到 SSO 系统，SSO 系统完成登录，其他的应用系统也就随之登录了

#### 具体实现（ session 登录举例 ）

- 相同域名，不同子域名下的单点登录
  - 一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做 a.com，同时有两个业务系统分别为 app1.a.com 和 app2.a.com。我们要做单点登录（ SSO ），需要一个登录系统，叫做 sso.a.com
  - 我们只要在 sso.a.com 登录，app1.a.com 和 app2.a.com 就也登录了。通过上面的登陆认证机制，我们可以知道，在 sso.a.com 中登录了，其实是在 sso.a.com 的服务端的 session 中记录了登录状态，同时在浏览器端（ Browser ）的 sso.a.com 下写入了 Cookie。那么我们怎么才能让 app1.a.com 和 app2.a.com 登录呢？这里有两个问题：
    - Cookie 是不能跨域的，我们 Cookie 的 domain 属性是 sso.a.com，在给 app1.a.com 和 app2.a.com 发送请求是带不上的
    - sso、app1 和 app2 是不同的应用，它们的 session 存在自己的应用内，是不共享的
  - 针对第一个问题，sso 登录以后，可以将 Cookie 的域设置为顶域，即 .a.com，这样所有子域的系统都可以访问到顶域的 Cookie 。我们在设置 Cookie 时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给 baidu.com 的域设置 Cookie
  - 争对第二个问题，我们在 sso 系统登录了，这时再访问 app1，Cookie 也带到了 app1 的服务端（ Server ），app1 的服务端怎么找到这个 Cookie 对应的 Session 呢？这里就要把 3 个系统的 Session 共享，如图所示。共享 Session 的解决方案有很多，例如：Spring-Session
- 不同域名下的单点登录
  - 统一身份认证 CAS（Central Authentication Service）是 SSO 的开源实现，利用 CAS 实现 SSO 可以很大程度的降低开发和维护的成本（ CAS 是由耶鲁大学发起的企业级开源项目，历经 20 多年的完善，具有较高的稳定性、安全性。国内多数高校的 SSO 都基于 CAS ）
  - CAS 官网上的具体标准流程如下（ 第一次访问 app1 ）：
    1. 用户访问 app1 系统，app1 系统是需要登录的，但用户现在没有登录
    2. 跳转到 CAS server，即 SSO 登录系统，以后图中的 CAS Server 我们统一叫做 SSO 系统。 SSO 系统也没有登录，弹出用户登录页
    3. 用户填写用户名、密码，SSO 系统进行认证后，将登录状态写入 SSO 的 session，浏览器（ Browser）中写入 SSO 域下的 Cookie
    4. SSO 系统登录完成后会生成一个 ST（Service Ticket），然后跳转到 app 系统，同时将 ST 作为参数传递给 app 系统
    5. app 系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。
    6. 验证通过后，app 系统将登录状态写入 session 并设置 app 域下的 Cookie
  - 访问 app1 后，第一次访问 app2
    1. 用户访问 app2 系统，app2 系统没有登录，跳转到 SSO
    2. 由于 SSO 已经登录了，不需要重新登录认证
    3. SSO 生成 ST，浏览器跳转到 app2 系统，并将 ST 作为参数传递给 app2
    4. app2 拿到 ST，后台访问 SSO，验证 ST 是否有效
    5. 验证成功后，app2 将登录状态写入 session，并在 app2 域下写入 Cookie，这样，app2 系统不需要走登录流程，就已经是登录了。SSO，app 和 app2 在不同的域，它们之间的 session 不共享也是没问题的

#### ST 的重要性

- SSO 系统登录后，跳回原业务系统时，带了个参数 ST，业务系统还要拿 ST 再次访问 SSO 进行验证，这个步骤是否有点多余？如果 SSO 登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？
- 不可以，因为单点登录，资源都在各个业务系统这边，不在 SSO 那一方。 用户在给 SSO 服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO 随便给业务系统一个 ST，那么业务系统是不能确定这个 ST 是用户伪造的，还是真的有效，所以要拿着这个 ST 去 SSO 服务器再问一下，这个用户给我的 ST 是否有效，是有效的我才能让这个用户访问

## 4. token 续签

#### 提一嘴

客户端通过配置 axios 的拦截器，获取 和 发送 token

```
// 请求拦截器
instance.interceptors.request.use(req=>{}, err=>{});
// 响应拦截器
instance.interceptors.reponse.use(req=>{}, err=>{});
```

#### token 时限设置为多少合理（参考）

1. 面对极度敏感的信息，如钱或银行数据，那就根本不要在本地存放 token，只存放在内存中。这样，随着 app 关闭，token 也就没有了，此外将 token 的时限设置成较短的时间（如 1 小时）
2. 对于那些虽然敏感但跟钱没关系，如健身 app 的进度，这个时间可以设置得长一点，如 1 个月
3. 对于像游戏或社交类 App，时间可以更长些，半年或 1 年

#### 续签方法

场景：超过 2 个小时后，用户没有请求，则需要重新登录

- 方法一：每次请求都返回新 token
  - 假设一个 token 的需求为 2h 未进行请求即过期。则设置有效期 2h，那么每次请求都会把一个 token 换成一个新 token。如果 2h 没有进行请求，那么上一次请求的到的 token 就会过期，需要重新登录。不断签就能一直使用下去
  - 这种方式实现思路很简单，但开销比较大
  - 问题一：每次都刷新 token，带来的性能影响如何？
    - 以前每次请求，需要进行一次 token 签名校验，而现在是要签发一个新 token，进行的都是一次签名运算，那么运算量即从 n 变成 2n
    - 其次，每次刷新都要把旧 token 加入黑名单，会导致黑名单特别大
  - 问题二：每次都刷新 token，并发请求时会不会因为 token 刷新而导致只有一个请求成功？
    - 答案是确实会导致这个问题，怎么解决呢？设置一个宽限时间，每次 token 刷新后，原来逻辑应该是立刻不可用，现在设置一个宽限时间，让其在 n 秒之内仍然可用即可
- 方法二：用户登录返回两个 token
  - 第一个是 accessToken ，它的过期时间 token 本身的过期时间 2 个小时，另外一个是 refreshToken 它的过期时间更长一点比如为 1 天。客户端登录后，将 accessToken 和 refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可
  - 该方案的不足是：
    - 需要客户端来配合
    - 用户注销的时候需要同时保证两个 token 都无效
    - 重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当 accessToken 快过期的时候，提前去通过 refreshToken 获取新的 accessToken）

## 5. 请求选择用 xml 还是 json

（我以前开发的话，一直觉得 xml 只适合写文档，例如配置文件那种，对于请求，一定是无脑选择 json，平常也没怎么看人请求用过 xml，但是在实习的时候，看到公司请求用了 xml，这里说一下我认为开发中请求选择 xml 或者 json 的优缺点）

1. xml 可以通过在标签中添加属性这简单的方法来存储元数据，就是说 xml 可以简单区分，标签内的数据，是该数据的值，而标签的属性，是用来描述这个数据的数据，这么听还有点抽象，看个例子：
   ```
   // def 属性表示 data 的取值范围，用来描述 data，而 85 则是 data 的值
   <data def="1 100">85</data>
   ```
   如果用 json 来代替，需要创建一个对象，把元数据当作对象的成员来存储，但是这样容易发生歧义，该情况 xml 更优
2. ① 在包含相同的信息的情况下，大部分情况下 json 要小于 xml，这意味着更快的传输和处理速度，② 且 json 执行序列化和反序列化的速度显著优于使用 xml，尤其解释 xml 时，尤其标签存在属性使得这些编程语言需要重新组织它们的数据结构才能进行操作，而大部分语言对于 json 都很容易进行转换，③ json 支持数组，而 xml 不支持，写起来更繁琐
   【序列化：是将对象的状态信息转换为可以存储或传输的形式的过程】
   【反序列化：是将可以存储或传输的形式转换为对象的状态信息的过程】

## 6. base64 编码

（以前一直只知道 base64 用在图片传送存储上，实习的时候接触项目才知道原来用很多地方可以用到）
【Base64 是为了解决各系统以及传输协议中二进制不兼容的问题而生的】

1. 用在图片传送存储上：
   1. 优点
      1. 网页中使用 base64 格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数
      2. base64 编码的字符串，更适合不同平台、不同语言的传输
      3. 把 css 中的图片使用成 base64 编码的，css 是在 html 头部引用的，要优先于下面的内容被加载，所以在网速不好的时候就会出现先加载出 base64 图片
   2. 缺点
      1. base64 格式的文本内容较多，存储在数据库中增大了数据库服务器的压力
      2. 网页加载图片虽然不用访问服务器了，但因为 base64 格式的内容太多，导致文件变大，所以加载网页的速度会降低，可能会影响用户的体验， CSS 文件的体积直接影响渲染，导致用户会长时间注视空白屏幕。HTML 和 CSS 会阻塞渲染，而图片不会
      3. base64 无法缓存，要缓存只能缓存包含 base64 的 css 文件，这比直接缓存图片要差很多，而且一般 HTML 改动比较频繁，所以等同于得不到缓存效益
      4. 图片转成 base64，体积会变大 33%，所以大点的图片也不建议转换，base64 的含义即用 64 个（2 的 6 次方）可见字符来表示，所以一个以前 3 个字节的内容（3 _ 8），现在需要 4 个可见字符表示（4 _ 6），由于每个可见字符都只占了六位，但是确实一个字节，所以会多出来两位，用 2 个 0 来填满，最终结果就是，以前三个字节的二进制，现在需要四个字节来表示，所以体积会变大
2. 可能某些场合并不能传输或者储存二进制流：
   二进制文件和文本文件的存储和传输方式是不一样的。比如，如果一个传输协议是基于 ascii 文本的，那么它就不能传输二进制流，那你要将二进制流传输就得编码。常见的诸如 http 协议的 url 就是纯文本的，不能直接放二进制流。并且大多数语言的 string 类型，都不能直接储存二进制流，但可以储存 base64 编码的字符串。如果希望用 string 类型操作一切数据，那就没法直接用二进制流
3. **base64 编码还包含了抵御含 sql 注入在内的各种注入的功能**：
   base64 编码中不包含任何符号和空格，因此（近乎很难构造成）不会被解析成任何攻击语句。任何要存入的数据先进行 base64 编码再往后端传或者后端收到后先进行 base64 转码再进行 sql 拼接，这样可以有效的抵御 sql 注入等各种攻击。但是缺点也有一些，一旦 base64 化，那么就不能进行高效搜索，以及储存空间要占用更大的地方，也不能方便的进行字符串截取等操作
   （这个真的很妙，我就说怎么公司里的代码总是给一些可见的字符，比如用户密码，用户名这种可见字符，用 base64 编码处理一遍，反而扩大了传输的体积，这么一想，应该是为了抵御 sql 注入，是我愚昧了，之前一直没搞懂，恍然大悟）

## 7. 状态处理权限校验码

可以通过一个权限校验码返回所有，比如增是 2，删是 4，改是 8，查是 16，如果返回一个 20 就等于有查和删的权限

## 8. 换肤功能

- 对于复杂换肤，不同换肤主题，涉及到的不止颜色，还有图片，复杂样式等等，改动范围很大，可能使用多套 css 文件来进行实现换肤，可能更方便一些
- 通过 css 变量

  - 如果只是简单的换肤，例如修改部分元素的颜色之类，使用 css 变量，然后通过修改变量的值（颜色）会更方便
  - 对于 less 变量，@ 应该很熟悉，但是 less 是预处理语言，会先转换为 css，所以这个变量只是方便开发的时候，转成 css 之后，就并不存在变量，所以并不能通过这个
  - 在 css3 中引入了属性变量和 var 函数，所以我们应该用的是 css3 新增的变量功能，使用变量的步骤为

    1. 定义变量
       - css 自定义变量形式为 --变量名
         ```
         --theme-color:'green'
         --theme-default:'blue'
         ```
    2. 声明变量

       - 声明为全局变量
         - 在伪类:root 中全局定义，可以作为全局变量使用
         ```
         :root{
           --theme-color:'green',
           --theme-default:'blue'
         }
         ```
       - 声明为局部变量
         ```
         .box{
           --theme-color:'green',
           --theme-default:'blue'
         }
         ```
       - 声明为私有变量（只能用在某个元素上）

         - 在元素的 style 属性自定义变量

         ```
         <div style="--i:100px" class='line'></div>

         .line{
           width:var(--i)
         }
         ```

    3. 使用变量
       - 使用 var 函数来引用变量
         ```
         .box{
           --theme-color:'green',
           --theme-default:'blue'
           color:var(--theme-color)
           background:var(--theme-default)
         }
         ```
       - 设置默认值，即当变量引用失败时使用
         ```
         .box{
           --theme-color:'green',
           --theme-default:'blue'
           color:var(--theme-color,'yellow')
         }
         ```
    4. 注意事项
       - 变量命名大小写敏感
       - 全局中定义的变量可以在任何地方使用，局部中定义的只能在局部中使用
       - 变量也是跟着 CSS 选择器走的，如果变量所在的选择器和使用变量的元素没有交集，是没有效果的

  - 可以 css 变量，配合 less 变量进行使用，一直写 var 函数，例 var(--theme-color,'yellow')，也十分繁琐，所以可以借助 less 变量，@bg: var(--bg, pink)，这样之后的使用，只要 @bg 即可，更方便

## 9. 添加水印

- 公司内部的一些 沟通平台，或者 内部管理平台，通常会需要水印这样的措施，避免泄密之类的
- 可以通过一个函数，根据浏览器窗口大小来动态生成 div，并完成水印的样式，这个函数可以绑定在浏览器的 load 事件（当页面加载后，由 window 对象调用）和 resize 事件（ 当浏览器窗口大小变化，由 window 对象调用 ）上
- 具体可以通过在 body 元素下，创建一个 div，将一个 shadow dom 附加在上面，因为水印应该和其他业务页面相互隔离，不影响互相，为了兼容性可以先判断元素上是否存在 attachShadow 方法，如果没有就只能当作普通元素添加在页面上
- 然后需要注意因为水印在页面的最上方，需要设置 zIndex 为 99999，且为了防止会阻碍页面上其他应用的点击时间，需要将 css 属性 pointer-events 设置为 none，让元素对鼠标事件不做出任何反应

  ```
  <style>
     .a {
          position: absolute;
          width: 300px;
          height: 300px;
          background-color: aqua;
      }
      .b {
          position: absolute;
          width: 200px;
          height: 200px;
          background-color: red;
          pointer-events: none;
      }
  </style>

  <div class="a"></div>
  <div class="b"></div>
  <script>
      let a = document.getElementsByClassName('a')[0];
      let b = document.getElementsByClassName('b')[0];
      a.addEventListener('click', () => {
          console.log('a');
      })
      b.addEventListener('click', () => {
          console.log('b');
      })
  </script>
  ```

- 对于其他的一些样式细节，可以通过传入参数配置对象，来和默认配置通过解构运算符进行合并，例
  ```
  function test(settings) {
    let defaultSettings = { xxx };
    let nowConfiguration = { ...defaultSettings, ...settings }; // 后面解构的会覆盖前面的
  }
  ```

## 10. 扫码登录

https://blog.csdn.net/weixin_45275996/article/details/115304407

## 11. 设计 前端走查设计测试用例 流程图

- 可以通过一个树状流程图，从初始的几个页面场景出发，列出每个场景各种情况，然后再连接到能从该页面跳转到的其他子页面，再列出子页面可能出现的各种情况，一直这么列举下去
- 主要是对 prd 文档需要熟悉，对特殊情况的处理需要了解，比如文字过长部分显示省略号，鼠标悬浮气泡展示内容，字段为空时特殊展示，还有比如特殊情况按钮禁用，分页功能是否可用 等等情况，需要在流程图中全部体现出来
- 然后每一次项目测试时，就可以根据这个流程图其中的部分模块，或者全部模块，走一遍测试，如果过了就画掉，没过就标出来，写在一个问题管理文档里，再 @ 相关负责的前端同事进行相应处理即可

## 12. validator

## 13. Hybrid

## 14. vite

## 15. 浏览器工作原理
