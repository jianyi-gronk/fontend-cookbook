[详情](https://cn.rx.js.org/manual/overview.html)（ 但是有点老旧了，貌似没更新，有些 api 都弃用了，我稍微做了更改 ）

## 1. 基础介绍

- RxJS 和 Promise 都是用于处理异步操作的工具，但它们的作用不完全相同，Promise 适用于简单的异步场景，而 RxJS 则适用于更为复杂的异步场景，并能够提供更多的功能和灵活性
  - Promise 是一个代表异步操作最终完成或失败的对象。使用 Promise 可以方便地处理异步操作的结果，并在需要时进行响应，并且现代浏览器和 Node.js 等平台中都内置了 Promise 对象，无需额外安装或导入
  - RxJS 则是一个强大的响应式编程库，可以处理异步数据流。RxJS 提供了丰富的操作符，可以对数据流进行转换、过滤和组合等操作，从而实现多个异步操作之间的交互、并发等复杂的异步场景，但浏览器和 Node.js 都没有内置 RxJS，所以需要安装导入
- RxJS 的设计模式是基于观察者模式的。它通过创建可观察对象（ Observable ）和订阅者（ Subscriber ），将数据流和事件流进行抽象，并提供了一系列操作符来方便地对数据流进行转换、过滤和组合等操作。这种基于观察者模式的设计思想使得 RxJS 能够很好地处理异步操作和事件驱动的场景
  - Promise 其实也是基于观察者模式的，Promise 对象可以注册多个回调函数（ 观察者 ），并在异步操作完成后通知这些回调函数执行相应的任务
- RxJS 是一种流式编程库，因为它的核心概念是基于数据流的操作，即把数据看作连续的事件流，并通过各种操作进行处理和转换，就好像你正在观察一条河流，河水不停地从你身边流过，而你则可以记录下每一个时间点的水位、水流速度等信息。类比到数据上，就是数据不断地产生和传输，我们可以通过不断地收集和分析来获取有用的信息，流式编程库的特点包括
  - 基于数据流：将数据看作连续的事件流，提供了处理和转换这些事件流的强大工具
  - 响应式编程：能够自动监测事件流的变化，并能够立即响应变化
  - 高效性：使用异步编程技术，能够更高效地处理事件流，并能够避免阻塞线程
  - 可组合性：因为所有的操作都是基于数据流的，所以可以很方便地将多个操作组合在一起，构建复杂的数据处理管道
  - 函数式编程：RxJS 使用函数式编程风格，使得代码更易于理解和维护

## 2. 主要核心概念

- Observable（ 可观察对象 ）：一个异步的数据流对象，可以用来订阅并处理数据
  - Observable 对象通常包含了一个 subscribe() 订阅方法，用于注册一个或多个 Observer 对象，用于监听 Observable 发出的数据流
  - Observable 对象，通常使用 new 关键字或 from() 方法来创建
    - new 关键字可以手动创建 Observable，new Observable() 需要传入一个函数参数
      - 是惰性运算，并不会直接执行，当 subscribe 订阅 Observable 时，类似于调用函数，才会执行
      - 每一个观察者订阅一次，都会执行一遍
      - 这个执行是同步的，不是异步
      - 这个函数类似于 Generator，可以同步或异步的 “返回” 多个值
      - 用 try/catch 代码块来包裹任意代码是个不错的主意，如果捕获到异常的话，会发送 "error" 通知
      - 以前是 create()，已经被弃用，虽然现在仍能用，但是建议改成使用 new Observable()
    - from() 等创造函数可以将一个数组、Promise、Generator 或其他对象转换为 Observable
- Creation functions（ 创造函数 ）：是一组用于创建 Observable 的函数，这些函数可以从多种来源创建 Observable，包括数组、Promise、事件、定时器等。常见的有
  - from()：将一个数组、Promise、Generator 或其他对象转换为 Observable
  - of()：用于创建一个发出指定值的 Observable
  - interval()：用于创建一个定时器 Observable，每隔一定时间发出一个递增的数字
  - timer()：用于创建一个定时器 Observable，可以指定延迟时间和间隔时间
  - fromEvent()：用于创建一个基于事件的 Observable，用于监听 DOM 事件、WebSocket 事件等
  - ajax()：用于创建一个 Ajax 请求 Observable，用于发送 HTTP 请求并获取响应数据
  - defer()：用于延迟创建 Observable，可以在订阅时才创建 Observable，避免在创建时就执行异步操作
  - empty()：用于创建一个空的 Observable，不发出任何数据，直接完成
- Observer（ 观察者 ）：接收 Observable 推送过来的数据，并对其进行处理
  - Observer 对象通常包含了三个方法，分别是 next()、error() 和 complete() 方法，这些方法分别用于处理 Observable 发出的正常数据、错误信息和完成事件，且 Observer 可以选择性地实现这些方法，例如可以只实现 next() 方法，而不实现 error() 和 complete() 方法。在这种情况下，如果 Observable 发生错误或完成事件，就不会调用对应的方法
    - next() 方法：用于处理正常的数据流，当 Observable 发出新的数据时，会调用 next() 方法，并将数据作为参数传递给该方法
    - error() 方法：用于处理错误信息，当 Observable 发生错误时，会调用 error() 方法，并将错误信息作为参数传递给该方法
    - complete() 方法：用于处理 Observable 完成事件，当 Observable 发出完成事件时，会调用 complete() 方法
    - "Error" 和 "Complete" 通知可能只会在 Observable 执行期间发生一次，并且只会执行其中的一个，如果已经发送了 "Error" 或 "Complete" 通知的话，那么之后不会再发送任何通知
- Subscription（ 订阅 ）：表示 Observer 对 Observable 的订阅关系，也表示进行中的执行，用于监听 Observable 发出的事件，可以取消订阅以停止执行
  - 订阅 Observable 像是调用函数, 并提供接收数据的回调函数（ 观察者对象中的方法 ）
  - 当我们订阅一个 Observable 时，会返回一个 Subscription 对象。这个对象包含了一个 unsubscribe() 方法，用于取消订阅。当我们调用 unsubscribe() 方法时，Subscription 对象会从 Observable 中移除，同时也会停止接收事件
  - Subscription 对象还提供了一些其他的方法，如 add() 和 remove() 方法，可以用来添加或移除其他的 Subscription 对象，以便于管理和取消多个订阅，比如，我们可以将多个 Subscription 对象添加到一个集合中，然后统一管理和取消订阅。这样可以避免内存泄漏和其他问题，提高代码的可维护性和可读性
- Operators（ 操作符 ）：用于转换、过滤和组合 Observable 数据流的函数，可以方便地处理 Observable 发出的数据流，实现数据转换、筛选、合并、累积等操作
  - 虽然 RxJS 中最核心的概念是 Observable，观察者 和 订阅，但是最方便有用的还是自带的众多 Operators 操作符
  - 当操作符被调用时，如果参数是 Observable 实例，它们不会改变已经存在的 Observable 实例，而是返回一个新的 Observable，订阅操作符返回的 Observable 同样会订阅作为参数输入 Observable ，称之为 “操作符订阅链”
  - 提供了很多不同的操作符，这些操作符可以根据需要进行组合，以实现复杂的数据流处理
    - map()：用于将 Observable 发出的每个数据项通过一个函数进行转换
    - filter()：用于过滤 Observable 发出的数据项，只保留符合条件的数据项
    - merge()：用于将多个 Observable 合并成一个 Observable，同时处理多个数据流
    - concat()：用于将多个 Observable 按顺序连接起来，依次处理每个数据流
    - reduce()：用于将 Observable 发出的数据项通过一个函数进行累积，返回一个累积值
    - take()：用于从 Observable 发出的数据流中获取指定数量的数据项
    - switchMap()：用于将 Observable 发出的每个数据项转换为另一个 Observable，并返回一个新的 Observable
    - debounceTime()：用于过滤 Observable 发出的数据项，只保留最后一个指定时间内发出的数据项
  - pipe 用于将多个操作符（operators）串联在一起，从而创建可组合的数据流管道。通过将不同的操作符组合在一起，可以方便地对 Observable 发出的事件序列进行修改、过滤、转换等操作，以满足各种异步编程需求
  - RxJS 中操作符可以单独导入，例 const { observeOn, map, filter } = require('rxjs/operators')，或者 Rx.xxx() 来使用，最后都需要通过 pipe 组合起来
- Subject（ 主体 ）：既是 Observable，也是 观察者
  - 是一种特殊类型的 Observable
    - 普通的 Observables 是单播的（ 每个已订阅的观察者都拥有 Observable 的独立执行 ），而 Subject 允许将值多播给多个观察者，可以方便地处理多个订阅者需要同时处理同一个数据流的场景
    - 对于 Subject，你可以使用一或多次 subscribe 方法，得到一或多个观察者，就可以开始正常接收值。从观察者的角度而言，它无法判断 Observable 执行是来自普通的 Observable 还是 Subject
    - 在 Subject 的内部，subscribe 不会调用发送值的新执行。它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener 的工作方式
    - 要给 Subject 提供新值，只要调用 subject.next(theValue)，它会将值多播给已注册监听该 Subject 的观察者们
  - 也是 观察者
    - Subject 是一个有如下方法的对象： next(v)、error(e) 和 complete()
    - 因为 Subject 是观察者，这也就在意味着你可以把 Subject 作为参数传给任何 Observable 的 subscribe 方法
  - Subject 对象有以下几种类型
    - BehaviorSubject：是特殊类型的 Subject，它可以在订阅之前发射最新的值，相当于一个具有“记忆功能”的 Subject
    - ReplaySubject：是特殊类型的 Subject，它可以缓存一定数量的事件，并将它们发送给任何后续订阅者
    - AsyncSubject：是特殊类型的 Subject，它只会在 Observable 完成时发出最后一个值，如果 Observable 发生错误，则不会发出任何值
- Scheduler（ 调度器 ）：调度器控制着何时启动 subscription 和何时发送通知
  - Scheduler 由三部分组成
    - 调度器是一种数据结构：它知道如何根据优先级或其他标准来存储任务和将任务进行排序
    - 调度器是执行上下文：它表示在何时何地执行任务（ 举例来说，立即的，或另一种回调函数机制（ 比如 setTimeout 或 process.nextTick ），或动画帧 ）
    - 调度器有一个（ 虚拟的 ）时钟：调度器功能通过它的 getter 方法 now() 提供了“时间”的概念。在具体调度器上安排的任务将严格遵循该时钟所表示的时间
  - Scheduler 对象可以通过调用 Rx.Scheduler.create() 方法来创建。Scheduler 对象可以通过传递给 Observable 的 subscribeOn() 和 observeOn() 方法来应用。subscribeOn() 方法用于指定 Observable 执行的线程或事件循环，observeOn() 方法用于指定 Observer 执行的线程或事件循环
  - RxJS 提供了几种不同的 Scheduler，包括
    - null：不传递任何调度器的话，会以同步递归的方式发送通知，用于定时操作或尾递归操作
    - Rx.queueScheduler：当前事件帧中的队列调度(蹦床调度器)，用于迭代操作
    - Rx.asapScheduler：微任务的队列调度，它使用可用的最快速的传输机制，比如 Node.js 的 process.nextTick() 或 Web Worker 的 MessageChannel 或 setTimeout 或其他，用于异步转换
    - Rx.asyncScheduler：使用 setInterval 的调度，用于基于时间的操作符，使用了 setTimeout 或 setInterval，给定的延迟时间为 0
  - 所有的 Observable 操作符处理并发性都有可选的调度器。如果没有提供调度器的话，RxJS 会通过使用最小并发原则选择一个默认调度器。这意味着引入满足操作符需要的最小并发量的调度器会被选择。例如
    - 对于返回有限和少量消息的 observable 的操作符，RxJS 不使用调度器，即 null 或 undefined
    - 对于返回潜在大量的或无限数量的消息的操作符，使用 queue 调度器
    - 对于使用定时器的操作符，使用 aysnc 调度器
    - 因为 RxJS 使用最少的并发调度器，如果出于性能考虑，你想要引入并发，那么可以选择不同的调度器。要指定具体的调度器，可以使用那些采用调度器的操作符方法，例如 from([10, 20, 30], Rx.asyncScheduler)
  - 使用 subscribeOn 来调度 subscribe() 调用在什么样的上下文中执行。 默认情况下，Observable 的 subscribe() 调用会立即同步地执行。然而，你可能会延迟或安排在给定的调度器上执行实际的 subscription ，使用实例操作符 subscribeOn(scheduler)，其中 scheduler 是你提供的参数
  - 使用 observeOn 来调度发送通知的的上下文。 实例操作符 observeOn(scheduler) 在源 Observable 和目标观察者之间引入了一个中介观察者，中介负责调度，它使用给定的 scheduler 来调用目标观察者

## 3. 个人看法

- 个人感觉使用难度：Promise < RxJS < Generator
- 所以一般能方便地用 Promise 解决，就不考虑 RxJS
- 以下是一些 Promise 无法解决，需要使用 RxJS 解决的场景
  - 处理异步数据流：Promise 只能处理单个异步值，而 RxJS 能够处理多个异步值的数据流
  - 需要取消异步操作：Promise 不提供取消异步操作的方式，而 RxJS 提供了多种取消异步操作的方法
  - 处理复杂的事件序列：RxJS 提供了强大的操作符和工具，可以轻松地处理各种复杂的事件序列，例如 debounce、throttle、retry 和 buffer 等
  - 处理事件流中的错误：Promise 只能处理单个异步值的错误，而 RxJS 可以处理整个事件流中的错误，并采取相应的措施来恢复或终止事件流
  - 需要对事件流进行变换或组合：RxJS 提供了各种操作符和工具，可以方便地对事件流进行变换或组合，例如 map、filter、zip 和 merge 等

## 4. 样例

- 基础使用

  ```
  // 自定义创建 可观察对象，传入函数，参数为监听该 可观察者对象 的 观察者对象，可以在其中调用 观察者 身上的方法
  // new Observable() 传入的函数不会直接执行（ 和 new Promise 不同，这个需要 subscribe 订阅，才会执行函数内容 ）
  var observable = new Rx.Observable(function (observer) {
    // 用 try/catch 代码块来包裹任意代码是个不错的主意，如果捕获到异常的话，会发送 "error" 通知
    try {
      // 调用 观察者对象 身上的 next，并进行传值
        observer.next(1);
        observer.next(2);
        observer.next(3);
        var intervalID = setTimeout(() => {
          // 调用 观察者对象 身上的 complete
          observer.complete();
          // 如果发送的是 "Error" 或 "Complete" 通知的话，那么之后不会再发送任何通知了，所以不会发送 4
          observer.next(4);
        }, 1000);
        // 返回 unsubscribe 方法用于取消订阅，具体为释放资源或去取消 Observable 执行
        return function unsubscribe() {
          clearInterval(intervalID);
        };
    } catch (err) {
        observer.error(err);
      }

  });

  console.log('just before subscribe');

  // 可观察对象 上包含 subscribe 方法，用于注册一个 观察者，并返回一个 订阅对象
  // 此时会 同步 执行 new Rx.Observable() 中的函数内容
  // 传入一个对象，身上可以 next，error，complete 中一个或多个方法
  var subscription1 = observable.subscribe({
      next: x => console.log('got value ' + x),
      complete: () => console.log('done')
  });

  // 一个 可观察对象 可以注册多个 观察者，此时会执行多次 new Rx.Observable() 中的函数内容
  // 如果 subscribe 传入的是一个函数，则默认是一个只用 next 方法的 观察者
  // 或者可以直接把方法做为参数传入，默认顺序为 next，error，complete，可以只提供一两个方法
  var subscription2 = observable.subscribe(
    x => console.log('got value ' + x),
      err => console.error('something wrong occurred: ' + err),
  )

  console.log('just after subscribe');

  // 稍后
  setTimeout(() => {
    subscription1.unsubscribe();
    subscription2.unsubscribe();
  }, 2000);

  // just before subscribe
  // got value 1
  // got value 2
  // got value 3
  // got value 1
  // got value 2
  // got value 3
  // just after subscribe
  // done
  ```

- Subscription 细节

  ```
  var observable1 = Rx.interval(400);
  var observable2 = Rx.interval(300);

  var subscription = observable1.subscribe(x => console.log('first: ' + x));
  var childSubscription = observable2.subscribe(x => console.log('second: ' + x));

  // 添加其他订阅，便于进行统一管理
  subscription.add(childSubscription);
  // 可以通过 subscription.remove(childSubscription) 将它移除

  setTimeout(() => {
      // subscription 和 childSubscription 都会取消订阅
      subscription.unsubscribe();
  }, 1000);

  // second: 0
  // first: 0
  // second: 1
  // first: 1
  // second: 2
  ```

- Subject 基础使用

  ```
  // 创建一个 Subject
  var subject = new Rx.Subject();

  // 作为 观察者 监听
  subject.subscribe({
      next: (v) => console.log('observerA: ' + v)
  });
  subject.subscribe({
      next: (v) => console.log('observerB: ' + v)
  });

  // 作为 Observable 进行多播传值
  subject.next(1);

  console.log('============')

  // 或者可以创建一个普通 Observable，来观察
  var observable = Rx.from([2, 3]);

  // 直接提供一个 subject 进行订阅
  observable.subscribe(subject);

  // observerA: 1
  // observerB: 1
  // ============
  // observerA: 2
  // observerB: 2
  // observerA: 3
  // observerB: 3
  ```

- 自定义操作符函数

  ```
  // 自定义操作符函数，将从输入 Observable 接收的每个值都乘以10
  function multiplyByTen(input) {
      var output = new Rx.Observable(function subscribe(observer) {
        // 订阅 output 会导致 input Observable 也被订阅
        input.subscribe({
          // 在 input Observable 对应的观察者中进行处理，再调用 output 身上的参数的方法传递值
            next: (v) => observer.next(10 * v),
            error: (err) => observer.error(err),
            complete: () => observer.complete()
        });
      });
      return output;
  }

  var input = Rx.from([1, 2, 3, 4]);
  var output = multiplyByTen(input);
  output.subscribe(x => console.log(x));
  ```

- Scheduler 基础使用

  ```
  const observable = Rx.of(1, 2, 3).pipe( // 需要通过 pipe 将一或多个操作符组合
      Rx.map((v) => v + 10),
    Rx.filter((v) => v !== 12),
    Rx.observeOn(Rx.asyncScheduler) // 使用操作符 observeOn 来指定 async 调度器发送这些值
  );

  console.log('just before subscribe');

  // observeOn(Rx.asyncScheduler) 在 new Rx.Observable 和最终的观察者之间引入了一个代理观察者
  observable.subscribe({
    next: x => console.log('got value ' + x),
    error: err => console.error('something wrong occurred: ' + err),
    complete: () => console.log('done'),
  });
  console.log('just after subscribe');

  // just before subscribe
  // just after subscribe
  // got value 11
  // got value 13
  // done
  // done
  ```
