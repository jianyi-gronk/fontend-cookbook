## 1. 什么是 Web Component

- 组件是前端的发展方向，现在流行的 React 和 Vue 都是组件框架，而 Chrome 浏览器，一直在推动浏览器的原生组件，即 Web Components API
- 相比第三方框架，原生组件简单直接，符合直觉，不用加载任何外部模块，代码量小。目前，它还在不断发展，但已经可用于生产环境
- Web Components 是一项标准，目前它包含 3 项主要技术，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突
  - Custom elements（自定义元素）： 一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们
  - Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的，隐藏的，独立的 “影子” DOM 树附加到附加到常规的 DOM 树中的元素（与主文档 DOM 分开呈现），以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样，并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突
    <img src="https://img-blog.csdnimg.cn/a54d85aaf8ba4ca68730383da64e0dc0.png">
  - HTML templates（HTML 模板）： \<template\> 和 \<slot\> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用

## 2. 简单示例

- 先写组件内容
  ```
  <template id="tpl">
    <style>
      article {width: 20%; margin: 20px auto; border: solid 1px gray; padding: 8px;}
      header {
        background: lightblue; color: #fff;
        font-size: 24px; border: solid 1px lightblue;
      }
    </style>
    <article>
      <header>title...title</header>
      <section>content..........content</section>
    </article>
  </template>
  ```
- 然后使用 customElement 创建自定义组件
  ```
  class SelfDiv extends HTMLElement {
    constructor() {
      super()
      document.body.appendChild(tpl.content.cloneNode(true))
    }
  }
  customElements.define('my-blog', SelfDiv)
  ```
  - 但是这样我们只是单纯的把 template 内容（ SelfDiv 组件）挂在 body 上，也没有用上 shadow DOM，这样并没有隔离性，会和其他组件相互干扰，所以我们需要脱离真实 DOM，做到真正的内部独立
  - 并且内容也并没有自定义，这样不方便我们来复用组件
- 使用 Shadow DOM
  ```
  class SelfDiv extends HTMLElement {
    constructor() {
      super()
      let shadow = this.attachShadow({ mode: 'open' })
      shadow.appendChild(tpl.content.cloneNode(true))
    }
  }
  ```
  - Shadow DOM 接口返回一个 shadow-root 节点，在此节点内部的样式和行为都不会影响外面元素，可作为微前端子应用间样式隔离的选择方案之一，可以实现自定义组件做到内部独立（样式，事件等）
- 使用 slot 插槽
  - 比如上面的组件，还并不能自定义标题和内容的文本，这个时候就需要 slot 插槽
  - 插槽具有一个 name 属性作为标识，通常在 template 中定义，在使用时可以根据标识对其填充任何 HTML 元素
- 最后，在页面上使用 \<my-blog /\> 标签就能出现我们想要的内容

## 3. Custom elements

- 可以通过 customElements.define(name, constructor, options) 返回的绑定在 window 对象上的 customElements 实例进行元素自定义
  - name : 元素名。只能用短线连接的英文字符，不能是单个单词。例：name='my-comp'
  - constructor：元素构造器，必须继承自 HTMLElement 或其子类（例如：HTMLParagraphElement 等）
  - options：控制元素如何定义，只支持一个选项 extends，用于指明定义的元素继承自何种类型元素
    extends 指明的元素和 constructor 继承的元素保持一致
    例，{ extends: 'p' }
- 自定义组件的使用方法
  - 扩展自 HTMLElement 的自定义元素，直接使用 <元素名></元素名>
  - 扩展自特定子类 Element 的元素，使用 is 属性访问 <扩展 Element is="元素名"></扩展 Element>
    例，\<p is="extend-p"\>\</p\>

## 4. Shadow DOM

- 可以使用 Element.attachShadow(obj) 方法将一个 shadow root 附加到任何一个元素上，它接受一个配置对象作为参数，该对象有一个 mode 属性，值可以是 open 或者 closed（ 以前是 createShadowRoot，不过现在已经被弃用了 ）
  - open：允许外部 JavaScript 访问 Shadow DOM 中的元素和内容。外部的 JavaScript 可以通过 shadowRoot 属性来获取 Shadow DOM 的根元素，并访问其中的元素和内容。在 open 模式下，Shadow DOM 中的元素和内容可以被外部的 JavaScript 所操作和修改
  - closed：不允许外部 JavaScript 访问 Shadow DOM 中的元素和内容。外部的 JavaScript 无法通过 shadowRoot 属性来获取 Shadow DOM 的根元素，也无法访问其中的元素和内容，会返回 null。在 closed 模式下，Shadow DOM 中的元素和内容只能在 Shadow DOM 内部被访问和修改
  - 都无法在被附加到的元素的 children 中得到 ！！！
- **使用 attachShadow 方法创建的 Shadow DOM 是不会在开发者工具的 Elements 面板中显示出来的，因为 Shadow DOM 是被隔离的，不会影响到外部的 DOM 结构和样式。但是，在某些情况下，开发者工具中的 Elements 面板可能会显示 Shadow DOM 中的元素和内容**
  - 这种情况通常发生在 Shadow DOM 中包含了一些原生的表单控件或者其他浏览器原生的元素（ 在我的测试中，div 元素能正常出现在开发者工具中的 Elements 面板）。在这种情况下，浏览器会将 Shadow DOM 中的内容渲染到浏览器的 DOM 中，以便用户可以正常地与这些原生元素进行交互。在开发者工具的 Elements 面板中，可以看到这些原生元素及其包含的 Shadow DOM 中的元素和内容
  - 需要注意的是，即使 Shadow DOM 中的内容被渲染到了浏览器的 DOM 中，它们仍然是被隔离的，不会影响到外部的 DOM 结构和样式。在开发者工具中，可以通过查看元素的父节点和祖先节点来确定 Shadow DOM 中的元素是否被渲染到了浏览器的 DOM 中。如果 Shadow DOM 中的元素的父节点是 ShadowRoot 对象，或者祖先节点中包含 ShadowRoot 对象，那么这些元素就是在 Shadow DOM 中，而不是在浏览器的 DOM 中
- **可以通过元素的 getRootNode() 方法来判断某个元素是否为 Shadow DOM 根元素**。如果元素是 Shadow DOM 根元素，则 getRootNode() 方法返回的对象应该是一个 ShadowRoot 对象；如果元素不是 Shadow DOM 根元素，则 getRootNode() 方法返回的对象应该是一个 Document 对象
- 使用同样的方式来操作 Shadow DOM，就和操作常规 DOM 一样，例如添加子节点、设置属性，以及为节点添加自己的样式（例如通过 element.style 属性），或者为整个 Shadow DOM 添加样式（例如在 \<style\> 元素内添加样式）。不同的是，Shadow DOM 内部的元素始终不会影响到它外部的元素（除了 :focus-within），这为封装提供了便利
- 不是任何类型的元素都可以附加到 shadow root 下面。出于安全考虑，目前只有这些类型元素可以附加到 shadow DOM 上（ 有效的自定义元素也可 ）
  <img src="https://img-blog.csdnimg.cn/6014a37bfdbf430a8e794d222fd43c20.png">

## 5. template 和 slot

- slot 分为具名和非具名（ 和 vue 里的 slot 类似 ）
- 一些细节
  - 如果你调用 template 时未显式使用具名 slot，具名 slot 会显示默认内容
  - 具名 slot 被使用时，非具名 slot 默认不展示
  - 如果在 template 中定义了非具名 slot，使用模板时标签间的内容会直接替换非具名 slot 部分

## 6. 具体使用

#### 添加样式

- 直接在模板中添加 style 标签
  【 父组件中 】
  ```
  <template id="myTemplate">
    <style>
      h1 {
        color: red
      }
    </style>
    <h1>这是一个大标题</h1>
  </template>
  ```

#### 父向子通信

- 为了提高可复用性，组件中需要根据传入参数展示不同的内容
  【 父组件中 】
  ```
  <my-component id="myComponent" title="这是传入的标题"></my-component>
  ```
- 传入一个 title 属性，用 this.getAttribute 方法可以取到该属性
  【 子组件中 】
  ```
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      const template = document.querySelector('#myTemplate')
      const content = template.content.cloneNode(true)
      const title = content.querySelector('#title')
      const propTitle = this.getAttribute('title') // 获取到传入的 title 属性值
      title.innerText = propTitle
      this.appendChild(content)
    }
  }
  ```

#### 子与父通信

- 子父组件通信可以用自定义事件来实现
  自定义了一个 myEvent 事件（至于如何自定义事件就不详细展开了），注意携带的消息一定要放在 detail 属性中，放在其他属性会找不到，如果数据很多的话 detail 也可以是一个对象。当点击标题的时候把该事件 dispatch 出去
  【 子组件中 】
  ```
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      const template = document.querySelector('#myTemplate')
      const content = template.content.cloneNode(true)
      const title = content.querySelector('#title')
      const myEvent = new CustomEvent('myEvent', { // CustomEvent 用于自定义事件
        detail: '这是子组件传过来的消息'
      })
      title.addEventListener('click', () => { // 当点击 title 的时候，会触发这个 click 事件
        this.dispatchEvent(myEvent) // dispatchEvent 即向指定事件目标派发（触发）一个事件
      })
      this.appendChild(content)
    }
  }
  ```
- 在 myComponent 监听该事件，作出对应的处理
  【 父组件中 】
  ```
  const myComponent = document.querySelector('#myComponent')
  myComponent.addEventListener('myEvent', val => { // 监听子组件中自定义的事件
    console.log(val)
  })
  ```

#### 数据驱动视图

- 当传入的数据变化时，应当监听数据的变化，并对 dom 作出修改，涉及两个方法

  - static get observedAttributes 该静态方法需要返回一个数组，数组内是需要监听变化的属性名
  - attributeChangedCallback 当监听的属性变化时，会触发该函数，函数体内是监听的函数变化时需要执行的逻辑
    【 子组件 】

  ```
  class MyComponent extends HTMLElement {
    constructor() {
      super();
      const template = document.querySelector('#myTemplate')
      const content = template.content.cloneNode(true)
      const title = content.querySelector('#title')
      this.$title = title
      const propTitle = this.getAttribute('title')
      title.innerText = propTitle
      const shadowRoot = this.attachShadow({ mode: 'open' })
      shadowRoot.appendChild(content)
    }

    static get observedAttributes() {
      return ['title']
    }

    attributeChangedCallback() {
      const propTitle = this.getAttribute('title')
      this.$title.innerText = propTitle
    }
  }
  ```

- 给子组件绑定一个点击事件，点击时修改传入的属性
  【 父组件 】
  ```
  document.querySelector('#myComponent').addEventListener('click', e => {
    e.target.setAttribute('title', '传入的标题被修改了')
  })
  ```

#### 生命周期

- 生命周期，和 vue，react 的生命周期类似，在 custom element 的构造函数中，可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用
  - constructor：当组件被创建时
  - connectedCallback：当 custom element 首次被插入文档 DOM 时，被调用
  - disconnectedCallback：当 custom element 从文档 DOM 中删除时，被调用
  - adoptedCallback：当 custom element 被移动到新的文档时，被调用
  - attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时，被调用
  - errorCallback 错误处理函数

## 7. 如今发展

- 腾讯研发的下一代前端框架，Omi 框架（ 12.6k star ）和 谷歌研发的 lit 框架，都是基于 Web Components 规范设计的组件化框架
- 目前已经有一些基于 WebComponent 标准开发的组件库：Omiu（基于 Omi 开发的跨框架 UI 组件库），xy-ui（ 1.1k star ）
- 还存在比较有意思的基于 WebComponent 标准开发的 CSS 库：css-doodle（ 5.1k star ）
