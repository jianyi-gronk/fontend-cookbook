## 1. CPU 和 GPU

#### 1.1 基础介绍

- CPU 即中央处理单元，是一种硬件组件，它是服务器的核心计算单元。它负责处理操作系统和应用程序运行所需的各类计算任务
- GPU 即图形处理单元，是一种与 CPU 类似，但更专业的硬件组件。与普通 CPU 相比，它可以更高效地处理并行运行的复杂数学运算。最初的 GPU 专用于处理游戏和动画中的图形渲染任务，不过现在它们的用途已远超于此
- 计算机图形学和动画设计的出现后，产生了第一批计算密集型工作负载，而 CPU 的设计初衷并非是处理这些工作负载。例如，电子游戏动画需要应用程序处理数据以显示数千个像素，每个像素都有自己的颜色、亮度和移动方式。当时 CPU 上的几何数学计算导致了性能问题。硬件制造商开始认识到，卸载常见的面向多媒体的任务可以减轻 CPU 的压力并提高性能。如今，与 CPU 相比，图形处理单元（GPU）工作负载处理一些计算密集型应用（比如机器学习和人工智能）时更高效

#### 1.2 主要区别

- 功能
  - CPU 和 GPU 之间的主要区别在于它们的功能。没有 CPU，服务器就无法运行。CPU 处理服务器上所有软件正常运行所需的所有任务。另一方面，GPU 支持 CPU 执行并发计算。GPU 可以更快地完成简单和重复的任务，因为它可以将任务分解成更小的部分然后并行完成
- 设计
  - GPU 擅长通过多个核心或算术逻辑单元（ALU）进行并行处理。GPU 核心不如 CPU 核心强大，内存也更少。CPU 可以在不同的指令集之间快速切换，而 GPU 只是获取大量相同的指令并高速进行推送。因此，GPU 功能在并行计算中起着重要作用

#### 1.3 区别示例

- 为了更好地理解，可以类比为，CPU 就像一家大型餐厅的主厨，他必须要确保给数百个汉堡翻面。即使主厨可以亲自做，但这并不是利用时间的最佳方式。在主厨完成这项简单但耗时的任务时，所有厨房中的操作都可能停止或延缓。为了避免这种情况，主厨可以让初级助手同时翻汉堡。GPU 更像是一个有十只手的初级助手，可以在 10 秒钟内翻 100 个汉堡

#### 1.4 使用 GPU 而不是 CPU 的场景

- GPU 非常适合浮点数计算、图形处理或数据模式匹配，具体场景如下
  1.  浏览器渲染复杂场景和动画
      - 在浏览器渲染复杂场景和动画时，需要对大量的图形元素进行处理，包括几何计算、纹理映射、光照计算等。GPU 的并行处理能力可以同时处理多个图形元素，从而加快渲染速度
      - GPU 是专门为图形处理而设计的，它具有专门优化的图形处理单元和指令集。这使得 GPU 在处理图形相关的任务时更加高效，如顶点着色、像素着色、纹理采样等
      - GPU 拥有高带宽的图形内存，可以快速读写图形数据。在浏览器渲染复杂场景和动画时，需要频繁地读取和写入大量的图形数据，如顶点数据、纹理数据等
  2.  深度学习
      - 深度学习用于教计算机以受人脑启发的方式处理数据。例如，深度学习算法可以识别图片、文本、声音和其他数据中的复杂模式，从而生成准确的见解和预测。基于 GPU 的服务器可为机器学习、神经网络和深度学习任务提供高性能
  3.  高性能计算（指需要极高计算能力的任务）
      - 比如 需要快速、大规模地运行地球科学模拟和地震处理
      - 比如 需要规划财务模拟，以识别产品组合风险、对冲机会等
      - 比如 需要在医学、基因组学和药物发现领域构建预测性、实时性或回顾性的数据科学应用程序
  4.  自动驾驶汽车
      - 要开发及部署高级驾驶辅助系统（ADAS）和自动驾驶汽车（AV）系统，需要高度可扩展的计算、存储、网络和分析技术。例如，需要数据收集、标注和注释、地图开发、算法开发、模拟和验证方面的功能。如此复杂的工作负载需要基于 GPU 的计算机系统的支持才能高效运行

## 2. WebGL

#### 2.1 基础介绍

- WebGL 是一种基于 JavaScript 的 3D 图形渲染 API，允许开发人员在浏览器内部通过 GPU 为 HTML5 的画布元素提供渲染加速，支持 HTML5 的浏览器中实现交互式的 3D 图形和 2D 图形，它可以让浏览器实时渲染更为复杂的三维场景或交互式动画，包括游戏、虚拟现实体验、可视化数据、产品展示等等
- WebGL 并不是 HTML5 的一部分，而是由 Khronos Group 开发和维护的一个独立的标准。它基于 OpenGL ES 2.0 规范，因此在使用上的流程和 OpenGL ES 存在了诸多相似之处，函数名和参数也几乎是相同的
- WebGL 的目的是为了在不安装任何插件的情况下，就能在浏览器中实现高性能的图形渲染
- 特性：
  - GPU 加速：WebGL 可以利用计算机的图形处理器（GPU）进行硬件加速渲染，从而实现更高的性能。这对于实现复杂的 3D 场景和实时图形至关重要
  - 集成 HTML5 和 JavaScript：WebGL 与 HTML5 和 JavaScript 紧密集成，使得开发者可以利用现有的 Web 技术栈来构建 3D 应用程序。WebGL 现在已经是 Canvas 的绘制上下文之一，还可以和 Web Audio API 结合使用，实现具有 3D 图形和音频的互动体验
  - 跨平台兼容性：WebGL 可以运行在各种平台上，包括桌面浏览器、移动设备等。这意味着开发者可以编写一次代码，然后在多个设备上运行，从而实现更广泛的覆盖
  - 着色器支持：WebGL 支持顶点着色器和片段着色器，这些着色器允许开发者编写自定义的渲染代码，从而实现高度灵活的渲染效果。着色器使用 GLSL（OpenGL Shading Language）编写，这是一种类似于 C 语言的高级编程语言
  - 开源库和框架：有许多开源库和框架可以帮助开发者更容易地使用 WebGL，例如 Three.js、Babylon.js 和 A-Frame 等。这些库提供了更高级别的抽象，使得开发者可以专注于创建 3D 内容，而不必关注底层的 WebGL API 细节
- 不过 WebGL 需要开发者了解 3D 图形编程和计算机图形学的基础知识，因此需要花费一定的时间学习
- 目前几乎所有用到了 GPU 的 JavaScript 库底层都是通过 WebGL 来实现，比如 Three.js（ 3D 图形 ），Babylon.js（ 3D 图形 ），Pixi.js（ 2D 图形 ），TensorFlow.js（ 机器学习 ） 等

#### 2.2 OpenGL 和 WebGL

- 相同点：
  - OpenGL 和 WebGL 均带有如 顶点着色器，片段着色器，且着色器的编写语言均为 GLSL
- 不同点：
  - 首先 WebGL 相对 OpenGL 功能被削减了，例如删除了混合、反走样、雾化、缓存设置等高级场景设置函数，保留了简单、效能的函数
  - 其次是安全问题，它使得显卡硬件直接暴露在恶性代码或者 web 程序面前
  - 最后因为 WebGL 只是 OpenGL 的简易版，性能上比桌面应用还是有一定差距
  - 但 WebGL 采用了 B/S 的网络体系结构。不需要客户端本地下载绘制图形程序包，只需电脑配置满足需求，用户就可以在 web 浏览器进行图形渲染以及模型可视化

#### 2.3 应用场景

- 3D 游戏：WebGL 可以实现在浏览器中的 3D 游戏，无需安装任何插件或客户端软件
- 数据可视化：使用 WebGL 创建交互式的 3D 数据可视化，帮助用户更好地理解和分析数据
- 虚拟现实（VR）和增强现实（AR）：WebGL 可以用于开发基于 Web 的 VR 和 AR 应用程序，使得用户无需安装特定的软件即可体验虚拟现实或增强现实
- 在线 3D 建模和设计：WebGL 可以用于在线 CAD 软件、3D 建模工具和设计应用程序，从而使得用户可以在浏览器中直接进行建模和设计
- 教育和培训：WebGL 可以用于创建交互式的 3D 教育材料，如虚拟实验室、模拟器和教育游戏等

#### 2.4 样例

1. 首先需要一个进行 WebGL 绘制的载体。可以在 html 里面直接写标签，也可以在 js 中创建 DOM
   ```javascript
   ...
   <canvas id="canvas"></canvas>
   ...
   <script>
       const canvas = document.querySelector("#canvas");
   </script>
   ```
2. 通过 canvas 上的 getContext() 获取 WebGL 渲染上下文，接下来可以通过变量 gl 来使用 WebGL API 了
   ```javascript
   const gl = canvas.getContext('webgl')
   ```
3. 需要先准备好着色器的源码，然后将源码编译、链接。着色器（shader）是由专门的着色器语言（Shadering Language）编写的，在 OpenGL ES 中，使用的是 GLSL（OpenGL Shadering Language，一种类 C++ 语言）。着色器是成对出现的，分别是 顶点着色器 和 片段着色器
   - 顶点着色器（ Vertex Shader ）
     ```javascript
     const vertexShaderSource = `
         attribute vec4 a_position;
         void main() {
             gl_Position = a_position;
         }
     `
     ```
   - 片段着色器（ Fragment Shader ）
     ```javascript
     const fragmentShaderSource = `
         precision mediump float;
         void main() {
             gl_FragColor = vec4(1, 0.3, 0.5, 1);
         }
     `
     ```
4. 因为最终在 canvas 上渲染图形还是要使用 JavaScript 而不是 GLSL，所以需要将 GLSL 代码编译处理成 JavaScript 对象

   ```javascript
   // 编译着色器
   function setupShader(gl, type, source) {
   	let shader = gl.createShader(type) // 先创建空着色器对象
   	gl.shaderSource(shader, source) // 载入着色器源码
   	gl.compileShader(shader) // 编译

   	// 判断是否编译成功
   	let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
   	if (success) {
   		return shader
   	}

   	console.log(gl.getShaderInfoLog(shader))
   	gl.deleteShader(shader)
   }
   ```

5. 链接顶点着色器和片段着色器，生成一个着色器程序的 JavaScript 对象

   ```javascript
   // 链接顶点着色器和片段着色器
   function linkShader(gl, vertexShader, fragmentShader) {
   	let program = gl.createProgram() // 先创建一个空的着色器程序
   	gl.attachShader(program, vertexShader) // 载入编译好的顶点着色器
   	gl.attachShader(program, fragmentShader) // 载入编译好的片段着色器
   	gl.linkProgram(program) // 链接

   	// 判断是否链接成功
   	let success = gl.getProgramParameter(program, gl.LINK_STATUS)
   	if (success) {
   		return program
   	}

   	console.log(gl.getProgramInfoLog(program))
   	gl.deleteProgram(program)
   }
   ```

6. 调用上面的函数进行编译以及链接

   ```javascript
   // 编译
   let vertexShader = setupShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
   let fragmenSthader = setupShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

   // 链接
   let shaderProgram = linkShader(gl, vertexShader, fragmentShader);
   let positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");
   ```

7. 着色器设置好了之后，就要开始准备数据，作为着色器的输入了，作为着色器的输入数据，必须是在缓冲区中的数据。而现在没有缓冲区，也没有数据，所以接下来创建这两个东西，并把数据放入缓冲区中
   1. 创建缓冲区
      ```javascript
      let positionBuffer = gl.createBuffer()
      ```
   2. 然后使用 ARRAY_BUFFER 绑定点，绑定到这个 positionBuffer（ ARRAY_BUFFER 说明要用顶点数组方式绘图 ）
      ```javascript
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
      ```
   3. 缓冲区准备好了，接下来准备数据
      ```javascript
      let positions = [0, 0, 0, 0.2, 0.7, 0, -0.5, -0.5, -0.4, -0.2, -0.7, 0]
      ```
   4. 然后通过 ARRAY_BUFFER 绑定点，将数据放到缓冲区中
      ```javascript
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)
      ```
8. 准备画布
   1. 由于 WebGL 的裁剪空间是一个横纵坐标都在 [-1, 1] 范围内的矩形，而画布的尺寸一般不是这个，所以需在尺寸上映射
      ```javascript
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
      ```
   2. 然后清空一下画布
      ```javascript
      gl.clearColor(0, 0, 0, 0)
      gl.clear(gl.COLOR_BUFFER_BIT)
      ```
9. 渲染
   1. 首先指定着色器程序
      ```javascript
      gl.useProgram(shaderProgram)
      ```
   2. 然后启用 a_position 这个输入值（属性）
      ```javascript
      gl.enableVertexAttribArray(positionAttributeLocation)
      ```
   3. 之后准备将缓冲区的数据输送到着色器，其中参数的含义为：
      - size=2 表示每次迭代读取两个数据，即 x 和 y。由于顶点着色器中 gl_Position 的类型是 vec4，包含 x,y,z,w 四个数据，而这里只需要前两个 x 和 y
      - type=gl_FLOAT 表示使用的是 32 为浮点类型的数据
      - normalize=false 表示不需要归一化数据
      - offset=0 表示从缓冲区的开始位置读取数据
      ```javascript
      var size = 2
      var type = gl.FLOAT
      var normalize = false
      var stride = 0
      var offset = 0
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset)
      ```
   4. 最后设置图元类型，通过 drawArrays()，使用顶点数组中的顶点数据绘制
      ```javascript
      var primitiveType = gl.TRIANGLES
      var offset = 0
      var count = 6
      gl.drawArrays(primitiveType, offset, count)
      ```

#### 2.5 完整样例

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>GLSL-test</title>
  </head>

  <body>
    <canvas id="canvas"></canvas>

    <script>
      // 全局变量
      let gl;

      // 准备 WebGL 上下文
      function prepareContext() {
        // 使用Canvas
        let canvas = document.querySelector("#canvas");
        canvas.setAttribute("width", "640");
        canvas.setAttribute("height", "640");
        gl = canvas.getContext("webgl");
        if (!gl) {
          alert("无法使用 WebGL！");
        } else {
          console.log(gl);
        }
      }

      // 编译
      function setupShader(gl, type, source) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }

        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      }

      // 链接
      function linkShader(gl, vertexShader, fragmentShader) {
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        let success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      }

      // 创建缓冲区，并填入顶点数据
      function createBuffer(data) {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
      }

      (function main() {
        // 环境上下文准备
        prepareContext();

        // 着色器准备
        const vertexShaderSource = `
          attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
        `;
        const fragmentShaderSource = `
          precision mediump float;
        void main() {
            gl_FragColor = vec4(1, 0.3, 0.5, 1);
        }
        `;

        // 编译
        let vertexShader = setupShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        let fragmentShader = setupShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // 链接
        let shaderProgram = linkShader(gl, vertexShader, fragmentShader);
        let positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");

        // 准备输入数据
        createBuffer([0, 0, -0.3, 0.2, 0.2, 0.5, -0.5, -0.5, -0.4, -0.2, -0.7, 0]);

        // 准备画布
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // 加载着色器，准备读取缓冲区的数据
        gl.useProgram(shaderProgram);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // 执行绘制
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      })();
    </script>
  </body>
</html>
```

## 3. three.js

#### 3.1 基础介绍

- three.js 就是一个基于 WebGL 技术实现的 JavaScript 3D 渲染引擎。它封装了许多 WebGL 的复杂操作，提供了简单易用的接口和丰富的功能，使开发者可以方便地在网页上创建各种 3D 场景和效果。由于 WebGL 只是一个底层的图形库，需要编写大量的代码才能实现复杂的 3D 渲染，而 three.js 则为开发人员提供了一种更高级、更便捷的方式来创建 3D 场景
- 并且还有很多在 three.js 的基础上封装的，例如 A-Frame，可以帮助开发者构建适用于虚拟现实和增强现实的基于 Web 的应用程序，提供了易于使用的 HTML 标签
- 有很多基于 three.js 实现的项目
  - Sketchfab 是一个 3D 内容平台，用户可以通过上传、分享和发现 3D 模型来展示其创作，它使用 three.js 来呈现 3D 模型
  - Cubeslam 是一个基于浏览器的多人游戏。它使用 WebRTC 和 WebSockets 进行在线游戏对战，并使用 three.js 呈现游戏场景和角色
  - The Wilderness Downtown 是一个交互式音乐视频，基于 Chrome 浏览器开发。它使用 HTML5、CSS3、SVG、Canvas 和 WebGL 等技术，其中 three.js 用于呈现 3D 动画场景

#### 3.2 特性

- 易用性：Three.js 提供了直观的 API，使得开发者可以快速地上手并创建 3D 图形
- 灵活性：Three.js 支持多种几何体、纹理、材质和光照模型，可以满足各种复杂的 3D 效果需求
- 性能：Three.js 高度优化了 WebGL 渲染性能，使得 3D 图形可以在各种设备上流畅运行
- 社区支持：Three.js 有一个非常活跃的社区，提供了大量的教程、示例和插件，方便开发者学习和使用。

## 4. WebVR，WebAR，WebXR

#### 4.1 基础介绍

- WebVR、WebAR 和 WebXR 都是用于在 Web 浏览器中创建沉浸式体验的技术。它们分别针对虚拟现实（ VR ）、增强现实（ AR ）和一个统一的标准（ XR，即 扩展现实 ），旨在简化跨平台应用程序的开发和访问
- WebVR 是最早的一种 Web 标准，专注于在浏览器中创建虚拟现实（ VR ）体验，将用户带入一个虚拟的三维环境。它提供了一套 JavaScript API，用于访问和控制 VR 设备（如 Oculus Rift、HTC Vive 等）。通过 WebVR，开发者可以使用 Web 技术（如 HTML、CSS、JavaScript 和 WebGL ）创建沉浸式的 3D 场景，为用户提供跨设备的 VR 体验
- WebAR 是针对增强现实（ AR ）技术的 Web 标准。它允许开发者在浏览器中创建将虚拟对象与现实世界融合的应用程序。WebAR 通常使用设备的摄像头捕获现实世界的画面，然后在画面上叠加虚拟对象。与 WebVR 类似，WebAR 也提供了一套 API，用于访问 AR 设备的功能（ 如追踪、定位、识别等 ）
- WebXR 是一个新的 Web 标准，旨在整合 WebVR 和 WebAR，统一虚拟现实（ VR ）和增强现实（ AR ）的开发和体验。WebXR 提供了一套扩展的 JavaScript API，支持各种 VR 和 AR 设备，包括头戴式显示器（ HMD ）和移动设备。WebXR 不仅继承了 WebVR 和 WebAR 的功能，还引入了新的特性（如空间追踪、手势识别等），以满足更多样化的应用场景，所以也是目前推荐使用的技术

#### 4.2 WebGL 在其中的作用

- WebGL 是 WebVR、WebAR 和 WebXR 的基础技术之一
- 3D 图形渲染：WebGL 是实现 WebVR、WebAR 和 WebXR 中 3D 场景渲染的核心技术。它使得开发者可以在 Web 浏览器中创建复杂的 3D 模型、纹理和光照效果，为用户提供沉浸式的视觉体验
- 性能优化：由于沉浸式应用（ 尤其是 VR 和 AR ）对性能要求很高，WebGL 提供了 GPU 加速渲染，以确保在各种设备上实现流畅的帧率和低延迟。这对于创建高质量的 VR、AR 和 XR 体验至关重要
- 跨平台兼容性：WebGL 作为 Web 标准，得到了各大浏览器的支持。这意味着使用 WebGL 的 WebVR、WebAR 和 WebXR 应用程序可以在不同平台和设备上运行，为用户提供更广泛的可访问性

## 5. TensorFlow.js

#### 5.1 基础介绍

- 使用过机器学习的伙伴肯定对 TensorFlow 这个库不陌生，之前写论文处理深度学习模型的时候就用过 TensorFlow，打数模比赛也是用 TensorFlow 进行聚类分析，这语句 import tensorflow as tf 太熟悉了
- TensorFlow.js 是由谷歌开发的 JavaScript 库，它可以在浏览器或 node.js 中运行预训练模型或者实时训练自定义模型，使得在浏览器中使用机器学习变得更加容易，无需任何额外的设置或设备，官网提供了详细的文档
  - 预训练模型是指在大量数据集上已经训练好的模型，可以直接使用或者通过微调来适应特定的问题，甚至可以把预训练模型从 python 的模型转换为 TensorFlow.js（ 可以让后端传一个模型过来 ）
  - 自定义模型的训练，意味着可以在浏览器中进行神经网络训练而无需将其发送到服务器上
- 官方也提供了很多方便的预训练模型，例如 人脸检测，手部姿势检测（ 可以用来做游戏，不同手势对应游戏不同操作 ），语意分割，文本恶意检测（ 对一段语句进行评分，从 ‘非常恶意’ 到 ’非常健康‘ ）等等

#### 5.2 优缺点

- 优点
  - 前端加速：可以利用现代浏览器的 GPU 加速功能，从而提高前端深度学习模型的性能
  - 集成方便：TensorFlow.js 可以很好地与其他 Web 技术集成，例如，React、Vue、Angular 等。此外，TensorFlow.js 还支持与 TensorFlow Python API 之间的模型转换，使得开发者可以在 Python 和 JavaScript 之间无缝切换
  - 跨平台：可以运行在多个平台上，包括 Web 和 Node.js。这使得它可以在不同的环境中使用，例如，Web 应用程序、桌面应用程序、移动应用程序等
  - 数据隐私保护：支持在浏览器内部进行训练和推断，而不需要将数据发送到服务器进行处理。这意味着您的数据可以更好地受到保护，因为它们不会离开用户的计算机
  - 节省资源：将深度学习模型部署在客户端，可以降低服务器端资源需求，节省带宽和计算资源
- 缺点
  - 性能受限：虽然 TensorFlow.js 可以利用 GPU 加速功能来提高性能，但是由于 JavaScript 本身的限制，它的性能仍然不能与原生的 C++ 版本相比较
  - 资源浪费：由于 TensorFlow.js 运行在浏览器中，因此需要占用一定的计算资源和内存。这意味着，在 Web 应用程序中使用 TensorFlow.js 可能会导致页面加载时间变慢。此外，对于移动设备等资源受限的环境，TensorFlow.js 的资源消耗可能会更加明显
  - 版本更新较慢：相对于 TensorFlow Python API，TensorFlow.js 的版本更新较慢。这意味着，当新的深度学习技术出现时，开发者可能需要等待一段时间才能在 TensorFlow.js 中使用这些技术

#### 5.3 第三方封装

- 有很多第三方封装的 JavaScript 库，比如基于 TensorFlow.js 构建的 face-api.js，提供了非常容易使用的 api，能够在网页浏览器中运行，可以完成以下功能：
  - 人脸检测：从图像或视频中检测出所有可见的人脸，并确定它们的位置
  - 人脸识别：将每个检测到的人脸与预先训练的模型进行比较，以确定它是否与已知的人脸匹配
  - 年龄和性别估计：根据人脸进行年龄和性别的估计
  - 还有其他一些功能，如 面部标志检测（例如眼睛、鼻子、嘴巴等），表情识别 和 面部姿势估计

#### 5.4 真实场景

- 服务器可以通过集群提升算力，而前端算力的限制，所以绝大部分计算还是得放在服务器上进行
- 阿里钉钉大语言这块对小部分对算力要求不高的场景尝试过，但是尝试过程中很容易存在跑不动的情况（ 比如风扇呼呼吹 ）
- 所以目前这一块可能离真实运用在实际场景还是有一段差距

## 6. WebGPU

#### 6.1 基础介绍

- WebGPU 是由 W3C GPU for the Web 社区组发布的规范，为了允许网页代码以高性能且安全可靠的方式访问 GPU 功能
- WebGPU 不是 WebGL 的延续，而是下一代全新的基于 Web 的图形 API，很大概率会取代 WebGL

#### 6.2 WebGPU 和 WebGPU 的区别

- 技术基础：WebGL 基于 OpenGL ES，这是一种较旧的图形 API，主要用于移动设备和嵌入式系统。WebGPU 则是一种全新的图形 API，旨在提供更高的性能和更现代的功能。WebGPU 基于底层图形 API，对三个现代图形 API 直接打包（ Vulkan、DirectX 12 和 Metal ），这些 API 提供了更接近硬件的控制，从而实现更高的性能
- 性能：由于 WebGPU 基于更现代的底层图形 API，因此它能够实现比 WebGL 更高的性能。WebGPU 提供了更低的驱动程序开销、更好的多线程支持和更高效的内存管理。这意味着使用 WebGPU 的应用程序可以实现更高的帧率、更低的延迟和更丰富的图形效果
  - 在渲染性能上，WebGPU 比 WebGL 快 3 倍以上
  - 在计算性能上，WebGPU 比 WebGL 快 50 倍以上
  - [具体性能测试分析的地址](https://link.zhihu.com/?target=https://www.bbsmax.com/A/x9J2XD6ed6/)
- 着色器语言：WebGL 使用 OpenGL Shading Language（ GLSL ）作为着色器编程语言。WebGPU 则使用了一种新的着色器语言 WebGPU Shading Language（ WGSL ），它是基于 SPIR-V 和 Vulkan 的 Naga 编译器项目的一个子集。WGSL 旨在提供更好的性能、安全性和可移植性
- 浏览器支持：WebGL 已经被大多数现代浏览器广泛支持，包括桌面和移动设备上的 Chrome、Firefox、Safari 和 Edge。WebGPU 则仍处于开发和实验阶段，目前只有部分浏览器支持（ 如 Chrome Canary 和 Safari Technology Preview ），并且可能需要启用特定的浏览器标志

#### 6.3 基础使用（ [具体样例](https://zhuanlan.zhihu.com/p/626810456) ）

- 和 WebGL 一样，也是 Canvas 的绘制上下文之一，通过 canvas.getContext('webgpu') 获取
  ```javascript
  const context = canvas.getContext('webgpu')
  ```

## 7. CSS 开启 GPU 加速

【 当元素的渲染复杂度较高时，例如具有复杂的动画或过渡效果，使用 GPU 加速可能会提高性能。GPU 加速可以减少主线程上的计算负担，并利用 GPU 的并行处理能力来提高渲染速度 】

1. 使用 CSS 的 transform 属性和 translate3d 或 translateZ 函数来开启硬件加速

   - 将元素移动到 3D 空间（ 即使实际上并没有移动 ）会触发浏览器将该元素提升到一个独立的渲染层（ 又称合成层 ），从而利用 GPU 加速
   - 过度使用 GPU 加速可能会导致 GPU 内存不足，从而影响性能

   ```javascript
   .element {
       transform: translate3d(0, 0, 0);
   }

   .element {
       transform: translateZ(0);
   }
   ```

2. 使用 CSS 的 will-change 属性
   - will-change 属性允许提前告知浏览器，将在不久的将来对该元素进行动画处理。这使得浏览器可以在动画实际发生之前进行相应的优化
   - 当在元素上应用 will-change 属性，并将其值设置为某些可以受益于 GPU 加速的 CSS 属性（ 如 transform、opacity 或 filter ）时，可能会开启 GPU 加速
   - 不要滥用 will-change 属性，因为过度使用可能导致性能问题。只有在确实需要优化的情况下才使用此属性
   - 并非所有浏览器都会针对所有 will-change 值启用 GPU 加速。实际的行为取决于浏览器的实现和优化策略
   ```javascript
   .element {
       will-change: transform;
   }
   ```

## 8. 浏览器通过 GPU 加速绘制过程原理

- 硬件加速： GPU 具有强大的图形计算能力，可以执行许多与图形绘制相关的操作，如位图合成、滤镜效果、3D 变换等。通过使用 GPU 的硬件加速功能，浏览器可以将这些计算密集型任务从 CPU offload 到 GPU，从而提高性能。硬件加速可以有效地降低 CPU 的负担，提高渲染速度
- 分层渲染： 浏览器在绘制网页时，会将页面元素分成多个独立的层（ Layer ）。这些层可能包括普通的 HTML 元素、CSS3 动画、视频等。分层渲染的目的是将复杂的页面渲染任务分解为多个简单的任务，以便于在 GPU 中高效地执行。分层渲染有助于减少不必要的重绘，降低 CPU 负担
- 纹理映射： 将网页的每个层转换为一个纹理（ Texture ），纹理是一个包含像素数据的图像。浏览器会将这些纹理上传到 GPU 的显存中。GPU 可以直接读取显存中的纹理数据，避免了在 CPU 和 GPU 之间传输大量的图像数据，从而提高了绘制效率
- 合成： 在 GPU 中，网页的各个层会被合成为一个完整的图像。合成过程包括将各个层按照正确的顺序和透明度组合在一起。GPU 可以并行地处理这些合成任务，从而在很短的时间内完成合成过程，提高绘制速度
- 双缓冲技术： 浏览器在渲染过程中通常会使用双缓冲技术，即使用两个缓冲区（ 前缓冲区和后缓冲区 ）进行绘制。在后缓冲区中进行绘制操作，当绘制完成后，将后缓冲区切换到前缓冲区进行显示。这种方法可以避免屏幕撕裂和闪烁现象，提高用户体验
