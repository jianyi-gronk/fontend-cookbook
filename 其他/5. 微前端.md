## 1. 微前端介绍

#### 1.1 微前端出现的原因

- 单页应用开发模式已经成为业界主流，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一，而是越来越庞大
- 因为过于庞大，所以难以维护，并且每次开发，上线新需求时还需要花费不少的时间来构建项目，往往是改一处而动全身，由此带来的发版成本也越来越高

#### 1.2 微前端是什么

- 微前端不是单纯的前端框架或者工具，而是一套架构体系，是一种类似于微服务的架构，它将微服务的理念应用于浏览器端
- 将一个单体应用程序拆分为一组松散耦合的服务，并通过轻量级的通信协议组织起来
- 一般情况下，我们会基于业务来拆分应用，每个应用都有一个自己的仓库，独立运行，独立开发，独立部署，独立访问，独立维护，还可以根据团队的特点自主选择适合自己的技术栈，极大的提升了开发人员的效率和体验

<img src="https://img-blog.csdnimg.cn/fb4ababd1b0f4061b4c0115414ff7eba.png">

#### 1,3 微前端作用是什么

（ 其实微前端就很像拆分组件，来缩小代码体积，方便排查问题，但是有更独立，可兼容，可不同技术栈 等等其他作用 ）

- 简单、分离、松耦合的代码仓库
  - 微前端架构下的代码仓库更加简单、轻量，各个仓库的代码可以基于业务、权限、变更的频率、组织结构、后端微服务等原则拆分，界限明确，降低耦合
  - 并且将整个庞大的项目拆分细化，也可以对拆分出来的部分分别进行版本管理，可以将不同版本的几个部分进行合并
- 独立开发、独立部署
  - 代码库拆分以后，我们可以基于各个代码仓库独立开发，由于代码体积的缩小，项目构建时间变短，极大提升开发效率，也便于开发人员在开发过程中快速定位源代码，提高开发效率，降低维护成本
  - 另外，各个项目都有自己的交付流水线（ 从构建、测试到上线 ），并且能够独立部署，不需要考虑其他项目的情况
- 技术栈无关
  - 在实际项目中，各个项目会因为各种各样的原因导致使用的技术栈不一样。比如开发框架有 react、vue、angular 等，构建工具有 webpack、rollup、parcel 等，可以可以做到将使用不同技术栈的子应用聚合起来
  - 可以让团队获得更多的机会在项目中尝试新的技术（ vue3、webpack5 等），有助于整个团队技术的成长
- 遗留系统迁移
  - 每个公司中，多多少少会存在一些应用是使用老的技术栈开发的，比如 Backbone，Vue1.0，angular1.0，jquery 等，这些应用已经在线上稳定运行，而且也没有新的功能
  - 对于这样的应用，我们没有理由浪费时间和精力，而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行，直接整合到新的应用中

#### 1.4 实现微前端的方案

- 目前，业界主流的微前端实现方案主要有：
  - Nginx 路由转发：
    - 通过 Nginx 配置反向代理来实现不同路径映射到不同应用，例如 www.abc.com/app1 对应 app1，www.abc.com/app2 对应 app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置
    - 优点：简单，快速，易配置
    - 缺点：在切换应用时会触发浏览器刷新，影响体验
  - iframe 嵌套：
    - 如果不考虑体验问题，iframe 几乎是最完美的微前端解决方案了，父应用单独是一个页面，每个子应用嵌套一个 iframe，父子通信可采用 postMessage 或者 contentWindow 方式
    - 优点：实现非常简单，提供了浏览器原生的硬隔离方案，不论是样式隔离，js 隔离这类问题统统都能被完美解决
    - 缺点：它的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题
      - url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
      - UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
      - 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
      - 慢，每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程
      - 其中有的问题比较好解决（问题1），有的问题我们可以睁一只眼闭一只眼（问题4），但有的问题我们则很难解决（问题3）甚至无法解决（问题2），而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案
  - Web Components：
    - 每个子应用需要采用纯 Web Components 技术编写组件，是一套全新的开发模式
    - 优点：每个子应用拥有独立的script和css，也可单独部署
    - 缺点：对于历史系统改造成本高，子应用通信较为复杂易踩坑
  - 组合式应用路由分发：
    - 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制
    - 优点：纯前端改造，体验良好，可无感知切换，子应用相互隔离
    - 缺点：需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点
  - webpack5：
    - 从 Webpack5 开始，已经内置了对微前端开发的支持，提供了新的功能叫 Module Federation，提供了足够的能力来实现微前端开发
    - 模块联合允许 JavaScript 应用程序从另一个应用程序动态加载代码，并在此过程中能共享依赖关系，如果使用 Module Federation 的应用程序不具有联合代码所需的依赖关系，则 Webpack 将从该联合构建源中下载缺少的依赖关系
    - 在Module Federation的上下文中，启动代码是一种将运行时代码附加到远程容器启动序列的实施策略。这真的很有用，因为通过Hook无法访问ModuleFederation及其运行时，无法对其进行扩展或添加一行代码，这些代码可以像动态设置远程容器的公共路径那样进行操作。这在普通的webpack应用程序中是微不足道的，但是在一个无法访问的自定义运行时容器中却很难做到，该容器为模块联合远程编排提供了动力。简单来说，Module Federation注入一段运行时的代码来负责加载和编排远程的应用代码，并能够管理和加载远程应用的依赖
    - Module Federation 的加载过程
      - localhost 加载 index.html
      - main.js 是Module Federation的核心的编排代码，负责加载远程组件
      - remoteEntry.js 是Module Federation暴露的远程组件的代码
      - src\_ 是打包后的代码，其中 bootstrap_js 是容器侧的代码，index_js 是微前端侧的代码
  - single-spa：
    - single-spa 是最早的微前端整合方案，主要步骤是，在主应用中注册所有可能加载的微应用，微应用的声明必须在入口函数中暴露出三个钩子函数（bootstrap，mount，unmount），提供三个函数给主应用使用， bootstrap 为启动准备，mount 为挂载，unmount 为销毁，主应用通过发送请求加载子应用打包好的lib库，然后执行子应用的lib就行
    - 优点：操作较简单
      ```
      ...........
      const singleLifeCycle = new singleSpaVue({
        Vue,
        appOptions // 将配置对象传过去
      })
      ...........
      // 实例对象上有所需暴露的三个钩子函数，不需要自己写
       export const bootStrap = singleLifeCycle.bootstrap;
       export const mount = singleLifeCycle.mount;
       export const unmount = singleLifeCycle.unmount;
      ```
    - 缺点：
      - 对微应用的侵入性太强：将整个微应用打包成一个 JS 文件，常见的打包优化基本上都没了，比如：按需加载、首屏资源加载优化、css 独立打包等优化措施
      - 样式隔离问题 和 JS 隔离问题：single-spa 中没有做这部分的工作
      - 资源预加载问题：single-spa 中没有做这部分的工作
      - 应用间通信：single-spa 中没有做这部分的工作，它只在注册微应用时给微应用注入一些状态信息，后续就不管了，没有任何通信的手段，只能用户自己去实现
  - qiankun
    - qiankun 是由蚂蚁集团开源的基于 single-spa 的微前端实现库，旨在帮助大家能更简单构建一个生产可用微前端架构系统
    - 特性：
      - 基于 single-spa 封装，提供了更加开箱即用的 API
      - 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架
      - HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单
      - 样式隔离，确保微应用之间样式互相不干扰
      - JS 沙箱，确保微应用之间 全局变量/事件 不冲突
      - 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
      - umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统

#### 1.5 是否使用微前端

- 微前端最佳使用场景是一些 B 端的管理系统，能兼容集成历史系统，也可以将新系统集成进来，并且不影响原先的交互体验
- 微前端的构建通常比较复杂，从工具，打包，到部署，微前端都是更为复杂的存在，天下没有免费的午餐，对于小型项目，它的成本太高
- 虽然每个团队可以使用不同的框架，但是实际操作起来，除了要支持历史遗留的应用，它的意义不大。同时也为带来体验上的问题。可以远程加载不同的框架代码是一回事，把它们都用好是另一回事
- 性能上来看，如果优化得不好微前端的性能可能会存在问题，至少微前端框架是额外的一层加载，如果不同的微前端使用了不同的框架，那么每一个框架都需要额外的加载

## 2. 组合式应用路由

#### 2.1 介绍

- 当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端 SPA 项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用 React，Vue，Angular 或者 JQuery 开发，**每个微应用注册到基座应用中**，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示
  <img src="https://img-blog.csdnimg.cn/5e4b3e2cd245402a9fcee4912a2a7536.png">
- 当整个微前端框架运行之后，给用户的体验就是类似下图所示
  <img src="https://img-blog.csdnimg.cn/339f9ce298e6450e98661db03085bd6d.png">
- 简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题
  - 路由切换的分发问题
  - 主微应用的隔离问题
  - 通信问题（ 最经典的比如：用户状态的存储 - 免登 ）

#### 2.2 模块联邦

- 模块联邦（Federated Modules）是一种用于在不同应用程序之间共享和使用代码模块的技术。这项技术主要用于前端开发，尤其是在微前端架构中。通过使用模块联邦，开发人员可以在多个独立的应用程序之间共享和重用代码，从而降低开发和维护成本，提高可维护性和灵活性。
- 模块联邦的核心思想是将一个大型应用程序拆分成多个较小的应用程序或组件，这些组件可以独立开发、部署和更新。这些组件之间通过模块联邦共享代码，从而实现跨应用程序的代码重用。
- 在实现模块联邦的技术方案中，Webpack 5（一款流行的 JavaScript 打包工具）引入了对模块联邦的原生支持，使得开发人员可以更轻松地在项目中实现这一概念。
