## 1. webRTC

#### 为什么出现 webRTC

- 浏览器本身不支持相互之间直接建立信道进行通信，都是通过服务器进行中转。比如现在有两个客户端，甲和乙，他们俩想要通信，首先需要甲和服务器、乙和服务器之间建立信道。甲给乙发送消息时，甲先将消息发送到服务器上，服务器对甲的消息进行中转，发送到乙处，反过来也是一样。这样甲与乙之间的一次消息要通过两段信道，通信的效率同时受制于这两段信道的带宽。同时这样的信道并不适合数据流的传输
- 所以如何建立浏览器之间的点对点传输，一直困扰着开发者，WebRTC 应运而生

#### 什么是 webRTC

- 类似 websocket，不过 websocket 用于 **浏览器和服务器之间** 的实时通信，而 webRTC 用于 **浏览器和浏览器之间** 的实时通信，视频流，音频流 或 其他任意数据的传输
- WebRTC 是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的 JavaScript 接口，说的简单明了一点，就是让浏览器提供 JS 的即时通信接口。这个接口通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器
- 并且 WebRTC 通过实现 MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频
- 现在 WebRTC 已经可以在较新版的 Chrome、Opera 和 Firefox 中使用了，WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能

#### 常用场景

- 音视频通话
- 视频/电话会议（屏幕录制，共享远程桌面）

#### webRTC 架构

<img src="https://img-blog.csdnimg.cn/b3035fb50b854592a64f09347cdb3c50.png">

整体架构分为应用层和核心层，应用层提供实现相关业务逻辑 API，核心层提供应用层需要的核心 API，具体分：

1. 第一层是 C++API，也就是说提供给外面的 API 接口，这些 API 其实非常少，最主要的就是 peerconnetion，对等链接，webRTC 最重要的就是 PtoP 传输
2. 第二层是 session 层，也就是会话管理层（上下层管理层），WebRTC 在两个 Peer 之间通信之前需要创建一个 Session，这一层就负责 session 的创建、管理。包括音频，视频还有非音频数据的传输，都可以通过 session 层做处理，都可以通过 session 层进行管理，这一层管理这些相关的逻辑
3. 第三层最重要，包括音频引擎，视频引擎，还有传输。这里的设计是将音频，视频还有传输分开，这种设计非常好，传输的时候可以只关心传输，而不需要了解其他的业务逻辑，音频与视频也分别走各自的逻辑
4. 最后一层，与硬件相关，包括音频的采集与渲染，视频的采集，注意 webRTC 的核心库里面没有视频的渲染，所有的渲染都需要应用层或者浏览器层去做
5. 最后是网络 IO

#### 基本概念

1. 媒体协商
   - 每个客户端的多媒体能力不同，因此两个客户端想要通信就需要先了解相互的多媒体能力，协商出大家都支持的能力集，然后才能通信，WebRTC 使用 SDP 协议来协商音视频能力
   - 发动端发送的 SDP 称为 Offer，接收端发送的 SDP 称为 Answer
2. ICE
   - 当媒体协商完成后，WebRTC 就开始建设网络连接，其过程称为 ICE（Interactive Connectivity Establishment）交互式连贯建设
   - ICE 在调用 setLocalDescription() 后就开始了，其操作过程如下：
     - 收集 Candidate
     - 替换 Candidate
     - 按优先级尝试建立关联
3. Candidate
   - 和对端建立连接前，需要获取对端的一些基本信息，如 IP 地址、端口号、传输协议、加密算法等。而 Candidate 正是 WebRTC 用来形容它能够关联的远端的基本信息，因而 Candidate 是包含 IP 地址、端口号、协议的一个信息集
   - 在 WebRTC 中有三种类型的 ICE 候选者（Candidate）：
     - 主机候选者：示意网卡本人的 IP 地址及端口。通过设施网卡获取，优先级最高。在 WebRTC 底层首先会尝试本地局域网内建设连贯
     - 反射候选者：示意通过 NAT 之后的外网 IP 地址和端口，由 ICE（STUN）服务器获取，依据服务器的返回状况，来综合判断并晓得本身在公网中的地址。其优先级低于主机候选者，当 WebRTC 尝试本地连接不通时，会尝试通过反射候选者取得的 IP 地址和端口进行连贯
     - 中继候选者：示意的是中继(TURN)服务器的转发 IP 地址与端口，由 ICE 中继服务器提供。优先级最低，前两个都不行则会按该种形式
   - 在新建 RTCPeerConnection 时可在构造函数指定 ICE 服务器地址，没有指定的话则意味着这个关联只能在内网进行
4. CandidatePair
   - WebRTC 收集好 Candidate 后，会通过信令将它们发送给对端。对端接收到这些 Candidate 后，会与本地的 Candidate 组成 CandidatePair（即候选者配对）。有了 CandidatePair，WebRTC 就能够开始尝试建立连接了。这里须要留神的是，Candidate 的发送不是等所有 Candidate 收集好后才进行的，而是收集到一个就发送
   - CandidatePair，候选者配对，即一个本地 Candidate，一个远端 Candidate
   - 当 WebRTC 造成 CandidatePair 后，便开始尝试进行关联。一旦 WebRTC 发现其中有一个能够连通的 CandidatePair 时，它就不再进行关联尝试了，但发现新的 Candidate 时依然会发送给对端
5. 关联
   - TCP 是面向连接的，一个连接只涉及两个 IP 地址间的通信，而 SCTP 是面向关联的，关联是指两个端点之间的一次通信，因此可以涉及不止两个 IP 地址，当然也就可以有多个连接

#### 常用接口

- webRTC 常用的有三个 API，分别是：
  - MediaStream：通过 MediaStream 的 API 能够通过设备的摄像头及话筒获得视频、音频的同步流
  - RTCPeerConnection：RTCPeerConnection 是 WebRTC 用于构建点对点之间稳定、高效的流传输的组件
  - RTCDataChannel：RTCDataChannel 使浏览器之间（点对点）建立一个高吞吐量、低延时的信道，可传输任意数据

#### MediaStream（getUserMedia）

- getUserMedia 负责让用户访问摄像头、麦克风和屏幕，**它仅为本地执行的操作提供服务，而无法实现实时对话**
- 下列是 getUserMedia 的部分常用用法：
  - 获取用户头像图片
  - 收集音频样本，将它们发送给音频转文本的引擎
  - 录制音频和视频（不会因为丢包而导致质量下降）

#### RTCPeerConnection

- PeerConnection 是 WebRCT 的核心内容，也是最难实现和理解的部分，实现了非常多功能
  - 它负责处理所有 SDP 信息交换（不是将它们通过网络发送，而是生成信息并处理传入的信息）
  - 为了连接媒体通道，它实现了 ICE（如果需要，它会经过 TURN 转发信息）
  - 它可以实时编码、解码视频和音频数据
  - 它通过网络发送和接收媒体
  - 它通过使用自适应 jitter buffer、带宽估计、丢包隐藏和前向纠错等算法处理网络问题（都是很重要的算法）
  - 使用回声消除等算法处理本地音频问题
- 大部分这些影响最终媒体质量的操作（发生在 PeerConnection 内部）都是基于探测：一组特定规则。因此，不同的实现也许具有不同的表现和媒体质量
- WebRTC 使用 RTCPeerConnection 来在浏览器之间传递流数据，这个流数据通道是点对点的，不需要经过服务器进行中转。但是这并不意味着我们能抛弃服务器，我们仍然需要它来为我们传递信令（signaling，下面有介绍）来建立这个信道，WebRTC 没有定义用于建立信道的信令的协议，信令并不是 RTCPeerConnection API 的一部分

#### RTCDataChannel

- 既然能建立点对点的信道来传递实时的视频、音频数据流，那也能用这个信道传一点其他数据，RTCDataChannel API 就是用来干这个的，基于它我们可以在浏览器之间传输任意数据，DataChannel 是建立在 PeerConnection 上的，不能单独使用
- 数据通道可以配置为可靠或者非可靠，如果将它设置为非可靠，那么信息将无法自动通过它重传
- 数据通道也可以被配置为有序和无序传输信息
- 数据通道被设计为在类似于 WebSocket 的 API 上运行，一旦你打开它，你可以按照类似的方式进行操作

#### 存在难点

- 虽然 WebRTC 提供浏览器之间的点对点信道进行数据传输，但是建立这个信道，必须有服务器的参与，WebRTC 需要服务器对其进行四方面的功能支持
  - 用户发现以及通信
  - 信令传输
  - NAT/防火墙穿越
  - 如果点对点通信建立失败，可以作为中转服务器

#### NAT/防火墙穿越

- 建立点对点信道的一个常见问题，就是 NAT 穿越技术
- 在处于使用了 NAT 设备的私有 TCP/IP 网络中的主机之间需要建立连接时需要使用 NAT 穿越技术。以往在 VoIP 领域经常会遇到这个问题
- 目前已经有很多 NAT 穿越技术，但没有一项是完美的，因为 NAT 的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的 IP 地址。在 RTCPeeConnection 中，使用 ICE 框架来保证 RTCPeerConnection 能实现 NAT 穿越
- ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的 NAT 穿越技术，它是一种框架，可以整合各种 NAT 穿越技术如 STUN、TURN（Traversal Using Relay NAT 中继 NAT 实现的穿透）。ICE 会先使用 STUN，尝试建立一个基于 UDP 的连接，如果失败了，就会去 TCP（先尝试 HTTP，然后尝试 HTTPS），如果依旧失败 ICE 就会使用一个中继的 TURN 服务器
- 可以使用 Google 的 STUN 服务器：stun:stun.l.google.com:19302

#### 信令传输

- 需要信令服务器，WebRTC 客户端做的第一件事就是连接信令服务器。这么做的目的是协调你发起的任何会话
- 信令服务器并不在 WebRTC 规定的范围之内，所以需要自行决定在此处使用的代码。大部分代码可以在 Github 中找到，实际上浏览器客户端将会成为信令服务器的实现
- 信令服务器可以和你的 Web 服务器分开，或者它们位于同一进程中（由你自己来决定）。不管如何，首先要做的是检查是否已经为你的应用提供了某种信令机制，用于检查非 WebRTC 事务。你也许可以在此机制上搭载 SDP 信息和其他与信令服务器相关的 WebRTC

## 2. WebAssembly（ WASM ）

#### 基础介绍

- 已经成为官方标准，是继 HTML、CSS 和 JavaScript 之后的第四种 Web 语言，已经有 94% 的浏览器支持了 WASM，但 WASM 并不是取代 JavaScript，而是作为一种补充，不同的场景下选择不同的技术来实现最佳的效果
- WASM 可以被多种编程语言来转换得到，包括 C/C++、Rust、Go，TypeScript 等
- 它能够在浏览器中实现接近本机的执行速度，使得我们有可能将桌面应用（ 如 AutoCAD ）甚至电子游戏（ 如 Doom 3 ）移植到 Web

#### 执行速度快的原因

- WASM 比 JavaScript 更快，这是因为它是一种低级字节码格式，可以更直接地被计算机执行，并且在设计上注重了性能优化
- JavaScript 是一种解释型语言，它需要在运行时动态解析和执行代码。这意味着每当代码被执行时，都需要经过大量的解析和分析来确定要执行的操作。而 WebAssembly 是一种低级字节码格式，可以直接由浏览器或其他执行环境解释执行，无需进行复杂的语法分析和解释
- 此外，WASM 通常比 JavaScript 更优化，因为它是为执行速度而设计的。WASM 的指令集和内存模型非常类似于本地机器代码，因此它可以更有效地利用计算机资源，特别是 CPU 和内存。而 JavaScript 则需要通过 JIT（Just-In-Time）编译器将代码转换为本地机器代码，这也会带来额外的开销

#### 优缺点

- 优点
  - 跨平台性：WebAssembly 可以在任何支持浏览器的设备上运行。这意味着可以使用单个代码库，同时在桌面和移动设备上提供高性能应用程序
  - 性能：WebAssembly 可以为各种编程语言提供低级别的虚拟机平台，并且通过编译成二进制格式实现了比 JavaScript 更快的加载速度和执行速度，并且还可以利用多核处理器来提高性能。尤其是在涉及到复杂计算和高并发访问时，WASM 表现的更加出色
  - 安全性：WebAssembly 提供了一种运行在沙盒环境中的虚拟机，它将应用程序与底层系统隔离开来，从而最大程度地保护用户数据和设备安全
  - 模块化：WebAssembly 能够将代码分割成更小的模块，这使得应用程序更易于维护和更新，也可以让您只需更新需要更改的模块，而不必重新部署整个应用程序
- 缺点
  - 不支持 DOM：WebAssembly 不能直接与 HTML 和 CSS 进行交互，因此开发人员仍然需要使用 JavaScript 或其他语言来操作 DOM 元素
  - 可读性差：WebAssembly 使用二进制格式表示代码，这使得它难以阅读和理解，尤其是对于非专业开发人员而言
  - 手动内存管理：在 WebAssembly 中，开发人员需要自己负责内存管理，这可能会导致内存泄漏和程序崩溃等问题
  - 编译时间：WebAssembly 的编译时间较长，这可能会增加开发人员的开发时间。另外，由于浏览器和操作系统之间的不同，可能需要为每个平台编译不同的二进制文件，这会增加维护成本

#### 第三方支持

- 可以用第三方的工具 生成 或 处理 WASM
  - AssemblyScript：它是一种类型安全的开发语言，旨在使 TypeScript 成为 WebAssembly 的首选目标
  - Emscripten：它是一个 LLVM 到 JavaScript 编译器，可以将 LLVM 字节码编译为 WASM
  - Cheerp：它是一个基于 LLVM 的编译器，可以将 C++ 代码编译为 WASM 和 JavaScript
  - Binaryen：它是一个工具链，可以将 WASM 代码优化和缩小，以便在浏览器中更快地运行
  - WebAssembly Explorer：是一个在线工具，可以将多种语言编写的代码转换为 WebAssembly 字节码，但它不是自己进行转换，而是需要使用别的不同的编译器或转换器将源代码转换为 WASM
    - C/C++：可以使用 Emscripten 或 clang 等编译器将 C/C++ 代码转换为 WASM
    - Rust：可以使用 Rust 编译器将 Rust 代码转换为 WASM
    - TypeScript：可以使用 AssemblyScript 编译器将 TypeScript 代码转换为 WASM
    - Kotlin/Java/Scala：可以使用 Kotlin/Native 编译器将这些语言的代码转换为 WASM
    - Python：可以使用 Pyodide 将 Python 代码转换为 WASM
    - Lua：可以使用 Wasmjit 将 Lua 代码转换为 WASM

#### 使用样例

- 首先需要将其他语言转换为 WASM（ 这个样例中，使用 [AssemblyScript](https://www.assemblyscript.org/introduction.html) 将 .ts 文件转换为 .wasm 文件 ）
  - 创建 test.ts 文件，内容如下
    ```
    export function add(a: number, b: number): number {
        return a + b;
    }
    ```
  - 转换为 test.wasm 文件，命令行输入
    ```
    asc test.ts --outFile test.wasm --optimize // 将 test.ts 文件转换为 test.wasm 文件
    ```
- 运行 .wasm 文件 （ nodejs 环境 ）

  - 命令行安装 WebAssembly 模块
    ```
    npm install --save @assemblyscript/loader
    ```
  - 调用 .wasm 文件内的函数

    ```
    const fs = require('fs');
    const loader = require('@assemblyscript/loader');

    const wasmModule = loader.instantiateSync(fs.readFileSync('test.wasm'));

    const result = wasmModule.exports.add(10, 100);
    console.log(result); // 输出 110
    ```

## 3. WebGIS

- WebGIS 主要作用是通过互联网提供地理信息服务，使得地理信息数据和功能可以在网络环境中广泛地被访问、使用和共享
- 易用性：WebGIS 允许用户通过 Web 浏览器访问和使用地理信息服务，无需安装专门的 GIS 软件。这降低了使用门槛，使得更多人可以轻松地获取和利用地理信息
- 交互性：WebGIS 提供了丰富的地图展示和交互功能，用户可以实时地操作地图和数据，例如放大/缩小、平移、查询等。此外，服务器端可以根据用户操作迅速返回处理结果，实现实时的地理信息呈现和查询
- 数据共享：WebGIS 使得不同来源的地理信息数据可以在网络环境中方便地共享和整合。这有助于提高数据利用效率，节省数据获取和处理的时间成本
- 可扩展性：WebGIS 可以通过添加新的数据、功能和服务来进行扩展，以满足不断变化的需求。这使得 WebGIS 应用具有很高的灵活性和可定制性
- 跨平台性：由于 WebGIS 基于 Web 技术，因此可以在不同的操作系统和设备上运行，如 Windows、Mac、Linux、Android 等。这使得用户可以在多种场景下使用 WebGIS 服务

#### 常用开源库

- Leaflet：是一个轻量级且易于使用的 WebGIS 库，适用于桌面和移动设备。它具有强大的扩展性，支持各种地图图层、交互操作和地理信息处理功能。Leaflet 拥有丰富的插件生态，可以通过添加插件来扩展其功能
- OpenLayers：OpenLayers 是一个功能丰富且高度可定制的 WebGIS 库。它支持矢量图层、栅格图层、Web 地图服务（ WMS ）、Web 要素服务（ WFS ）等多种数据源，提供地图导航、查询、编辑等功能。OpenLayers 适合创建复杂的、定制化的 WebGIS 应用
- Mapbox GL JS：Mapbox GL JS 是一个基于 WebGL 技术的 WebGIS 库，可以实现高性能的地图渲染和交互操作。它支持矢量地图、三维地图、地图样式定制等功能，同时提供丰富的 API 和 SDK。虽然 Mapbox GL JS 的部分功能依赖于 Mapbox 的地图服务，但其核心库和许多功能是开源的

## 4. puppeteer

## 5. pwa

https://learn.microsoft.com/zh-cn/microsoft-edge/progressive-web-apps-chromium/

## 6. Serverless

## 7. omi
