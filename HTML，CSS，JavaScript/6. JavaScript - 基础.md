## 1. 常用数组方法

#### es5 及之前的数组方法（改变原数组）

1. push()
   - 语法：arr.push(data1, data2, data3, ...)
   - 作用：就是往数组末尾添加数据，如果有多个会依次插入
   - 返回值：添加后数组的长度
2. pop()
   - 语法：arr.pop()
   - 作用：就是从数组的末尾删除一个数据
   - 返回值：删除的那个数据
3. unshift()
   - 语法：arr.unshift(data1, data2, data3, ...)
   - 作用：就是在数组的头部添加数据，如果有多个会依次插入
   - 返回值：添加后数组的长度
4. shift()
   - 语法：arr.shift()
   - 作用：头部删除一个数据
   - 返回值：删除的那个数据
5. reverse()
   - 语法：arr.reverse()
   - 作用：用来翻转数组
   - 返回值：翻转好的数组
6. sort()
   - 语法一：arr.sort() // 默认正序排列
   - 语法二：arr.sort(fn) // 自定义排序规则，例 function fn(a,b) { return a - b } 会正序排列
   - 作用：用来排序数组
   - 返回值：排序好的数组
7. splice()
   - 语法一：arr.splice(开始索引, 截取数量)
   - 作用：截取数组，原数组中会缺少被截取的数据
   - 返回值：返回一个新数组，里面就是截取出来的数据
   - 语法二：arr.splice(开始索引, 截取数量, 插入数据 1, 插入数据 2, 插入数据 3, ...)
   - 作用：先删除，再从开始索引的位置插入数据（截取数量为 0 时，可以用来专门插入数据）
   - 返回值：返回一个新数组，里面就是截取出来的数据

#### es5 及之前的数组方法（不改变原数组）

1. concat()
   - 语法：arr.concat(data1, data2, data3, ...)
   - 作用：合并多个数组（如果 data 是基本类型数据，就直接插入）
   - 返回值：返回合并后的新数组
2. join()
   - 语法：arr.join('连接符')
   - 作用：就是把一个数组转成字符串，每个元素之间用 连接符 连接起来
   - 返回值：转换后的字符串
3. slice()
   - 语法：arr.slice(开始索引, 结束索引)
   - 作用：截取数组中的一部分数据（左闭右开）
   - 返回值：截取出来的数据，放到一个新的数组中
4. indexOf()
   - 语法一：arr.indexOf(data)
   - 作用：检查这个数组中有没有该数据（从左向右检查）
   - 返回值：如果有就返回该数据第一次出现的索引，如果没有则返回 -1
   - 语法二：arr.indexOf(data, 开始索引)（从开始索引向右检查）
5. lastIndexOf()
   - 语法一：数组名.lastIndexOf(data)
   - 作用：检查这个数组中有没有该数据（从右向左检查）
   - 返回值：如果有就返回该数据第一次出现的索引，如果没有返回 -1
   - 语法二：arr.lastIndexOf(data, 开始索引)（从开始索引向左检查）

#### es6 新增的数组方法

1. fill()
   - 语法：arr.fill(value [,start [,end]])
   - 作用：填充数组
   - 返回值：填充完后的数组
2. flat()
   - 语法：arr.flat([depth])
     - depth：指定要提取嵌套数组的深度，默认值为 1，可以通过指定为 Infinity 来扁平化所有子数组
   - 作用：扁平化数组
   - 返回值：包含将数组与子数组中所有元素的新数组
3. forEach() （ 特别的，这个是 es3 就有的方法 ）
   - 语法：arr.forEach(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来循环遍历数组的，类似 for
   - 返回值：无返回值
   - 注意：
     - 如果 item 是基本数据类型，则修改 item 不影响原数组，如果 item 是引用类型，则修改 item 中属性会影响原数组
     - 不过可以通过数组的索引修改原数组
     - 因为只是遍历，所以参数函数没有返回值
4. map()
   - 语法：arr.map(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来映射一个新数组
   - 返回值：返回映射后的新数组
   - 注意：
     - 不违背使用原则的话，不应该修改原数组值，但如果非要想修改，可以和 forEach() 一样修改
     - 因为要生成一个新数组，所以参数函数有返回值，每个返回值作为原数组元素映射的新元素，添加进新数组
5. filter()
   - 语法：arr.filter(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来过滤数组
   - 返回值：返回过滤后的新数组
   - 注意：
     - 参数函数返回 bool 类型的值，如果是 true 表示该值通过，会放入新数组中，如果为 false，则不会放入新数组中
6. every()
   - 语法：arr.every(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来判断数组中是不是每一个元素都满足条件
   - 返回值：返回布尔值，如果所有元素符合条件，则返回 true，否则返回 false
   - 注意：
     - 参数函数返回 bool 类型的值，如果是 true，则当前元素表示符合条件，如果是 false，则当前元素不符合条件
7. some()
   - 语法：arr.some(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来判断数组中存不存在满足条件的元素
   - 返回值：返回布尔值，如果有元素符合条件，则返回 true，否则返回 false
   - 注意：
     - 参数函数返回 bool 类型的值，和 every 类似
8. find()
   - 语法：arr.find(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来获取数组中第一个满足条件的元素值
   - 返回值：返回满足条件的第一个元素值（不是索引），如果没有则返回 undefined
   - 注意：
     - 参数函数返回 bool 类型的值，和 every 类似
9. findIndex()
   - 语法：arr.findIndex(function(item, index, arr) {})
     - item：表示的是数组中的每一项
     - index：表示的是每一项对应的索引
     - arr：表示的是原数组
   - 作用：用来获取数组中第一个满足条件的元素索引
   - 返回值：返回满足条件的第一个元素索引（不是值），如果没有则返回 -1
   - 注意：
     - 参数函数返回 bool 类型的值，和 every 类似
10. reduce()
    - 语法：arr.reduce(function(prev, item, index, arr) {}, 初始值)
      - prev：一开始是初始值，当第一次有了结果以后，这个值就是上一次的结果
      - item：这个表示的是数组中的每一项
      - index：这个表示的是每一项对应的索引
      - arr：这个表示的是原数组
      - 初始值：可选参数
    - 作用：接收一个函数作为累加器，数组中的每个值（从左到右）开始计算，最终计算为一个值
    - 返回值：返回计算的最终结果值，如果数组为空，则返回初始值，如果数组空 + 没有传入初始值，则会报错
    - 注意：
      - 参数函数每次返回的值，作为下一次计算时传入的 prev 的值

## 2. 不同遍历方法的遍历速度

- 遍历时间上：**for < for…of < forEach == $.each < while < for…in 遍历 < map 遍历**
  - filter、every、some 跟 forEach，map 相近，所以本次不加入比较
- 实验的数据：
  - for
    - 速度为 fastest
    - 单纯使用 for 循环，且循环体内不调用其他函数最快，若函数体内调用其他函数速率与 forEach 相似
  - forEach
    - 速度为 -40%
    - for 比 foreach 快的原因，是因为 foreach 传入的函数，在每一次调用的时候，会消耗时间去创建一个执行上下文对象，这个对象包含了函数的变量、参数和调用堆栈等信息。并且 foreach 在执行每个元素对应的回调函数的时候，JavaScript 引擎都需要将代码的控制权从 forEach() 方法传递到回调函数中，然后在回调函数执行完成后再将控制权传回给 forEach() 方法。这个过程即是上下文的切换，由于每次切换上下文都需要进行一些额外的操作，如上下文的创建、变量的绑定、堆栈的压入或弹出等，所以当对大量数据进行遍历时，上下文切换的开销是很大的
    - 用 IIFE 包裹，执行速度会更快的，是因为可以将遍历限制在一个私有作用域范围内，这样调用变量的话，可能它只需要搜索一个较小的作用域链，另外，因为 IIFE 可以将 forEach 方法的上下文绑定到当前作用域，这样可以减少函数调用时的上下文切换。这种方式可以减少内存分配和垃圾回收的负载，从而提高代码的效率
  - $.each
    - 速度为 -40%
    - JQuery 封装循环，与 forEach 速率相近
  - while
    - 速度为 -45%
    - while 循环体内调用函数，速度比 for 中调用函数慢一些，在循环体内出现调用函数时
  - for...in
    - 速度为 -54%
    - for...in 是循环中最慢的，因为使用 for...in 循环遍历对象的属性时，原型链上的所有可枚举的属性都将被访问，所以效率低，属性有是否可枚举，由属性的 enumerable 值决定的
- 除此之外，**for 的 正序遍历 快于 逆序便利**，大概速度为 -10%

  - 通过实验可以发现，并不是因为 <，> 等 比较符号，或者 +，- ，++，-- 等 运算符号 导致执行速度差异，真正导致的原因是**一些 CPU 有针对递增访问内存的优化**，可以预取循环中的变量，以加快循环的执行速度，但是对于递减的循环这个优化就不适用了，实验如下

    ```
    // 为什么这两个遍历存在时间上一个较大的差异
        // 11128
        // var start = Date.now();
        // for(let i = 0; i < 10000000000; i++) { }
        // console.log(Date.now() - start);

        // 12521
        // var start = Date.now();
        // for(let i = 10000000000; i > 0; i--) { }
        // console.log(Date.now() - start);



        // 是否和 符号相关（大于号，小于号）或者和 两边数字的大小 有关
        // 11211
        // var start=Date.now();
        // for(let i = 0; i < 10000000000; i++) {
        //     let a = 1 < 1;
        // }
        // console.log(Date.now() - start);

        // 11143
        // var start=Date.now();
        // for(let i = 0; i < 10000000000; i++) {
        //     let a = 10000000000 < 10000000000;
        // }
        // console.log(Date.now() - start);

        // 11168
        // var start=Date.now();
        // for(let i = 0; i < 10000000000; i++) {
        //     let a = 10000000000 > 10000000000;
        // }
        // console.log(Date.now() - start);


        // 是否和 + 或者 -，++ 或者 -- 有关吗
        // 11119
        // var start=Date.now();
        // for(let i = 0; i < 10000000000; i++) {
        //     let a = 10000000000 + 1;
        //     a++;
        // }
        // console.log(Date.now() - start);

        // 11061
        // var start=Date.now();
        // for(let i = 0; i < 10000000000; i++) {
        //     let a = 10000000000 - 1;
        //     a--;
        // }
        // console.log(Date.now() - start);
    ```

## 3. for in 和 for of

1. for in 更适合遍历对象
   - 遍历索引
   - 遍历数组时为字符串型（"0"，"1" ...），不能直接进行几何运算
   - 使用 for in 会遍历所有的可枚举属性，包括原型，如果不想遍历原型方法和属性的话，可以在循环内部判断一下，使用 hasOwnProperty() 方法可以判断某属性是不是该对象的实例属性
2. for of 适用于遍历 Array，String，Map，Set 等
   - 遍历元素值
   - 只能遍历拥有迭代器对象（iterator）的集合，所以不能遍历对象

## 4. 有关异步与多线程

1. 为什么要有异步?
   由于类似 ajax 网络请求、setTimeout 时间延迟、DOM 事件的用户交互等，这些任务并不消耗 CPU，是一种空等，资源浪费，因此出现了异步
2. 为什么不用多线程?
   因为当使用多线程的情况，例现在我们在浏览器中同时操作一个 DOM，一个线程要求浏览器在这个 DOM 中添加节点，而另一个线程却要求浏览器删掉这个 DOM 节点，此时浏览器不知道该做什么事。虽然有 web worker，但它仅仅能进行计算任务，不能操作 DOM，所以本质上还是单线程
3. 浏览器类似于单线程还是多线程?
   类似于多线程，例 Chrome 确实将单独的多个组件（不同的选项卡，插件等）分离到单独的进程中

## 5. \=\= 和 ===

- ==

  - 用来进行一般比较检测两个操作数是否相等，可以允许进行类型转换
  - 规则 1：NaN 和其他任何类型比较永远返回 false（包括和他自己）
  - 规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型
  - 规则 3：String 和 Number 比较，先将 String 转换为 Number 类型
  - 规则 4：null == undefined 比较结果是 true，除此之外，null，undefined 和其他任何结果的比较值都为 false

    - 特殊规则，并不是转换为 Number 类型
      ```
      Number(null); // 0
      Number(undefined); // NaN
      ```

  - 规则 5：原始类型和引用类型做比较时，引用类型会依照 ToPrimitive 规则转换为原始类型
    - ToPrimitive 规则，是引用类型向原始类型转变的规则，它遵循先 valueOf 后 toString 的模式期望得到一个原始类型
    - 如果还是没法得到一个原始类型，就会抛出 TypeError
  - \[ ] == ! \[ \]
    > 第一步，! [ ] 会变成 false
        第二步，应用 规则2 ，题目变成： \[ \] =\= 0
        第三步，应用 规则5 ，\[ \] 的 valueOf 是 0，题目变成： 0 == 0
        所以， 答案是 true
  - \[ undefined \] == false
    >     第一步，应用 规则5 ，\[ undefined \] 通过 toString 变成 '',
        题目变成  '' =\= false
        第二步，应用 规则 2 ，题目变成  '' =\= 0
        第三步，应用 规则 3 ，题目变成  0 =\= 0
        所以， 答案是 true
        但是 if( \[ undefined \] ) 又是个 true

- ===
  - 用于严格比较，只要类型不匹配就返回 flase
  - null \=\=\= null 和 undefined \=\=\= undefined 都是返回 true
    （虽然显而易见，但我在被面试官追问的时候，说了为 false，细节掌握的不自信了）
  - 不过 NaN === NaN 结果为 false
- 但是对于 Array，Object 等高级类型之间比较，\=\= 和 === 是没有区别的

## 6. js 数据类型

es5 的时候，是 number，string，boolean，object，null，undefined
es6 的时候新增 symbol
es10 的时候新增 bigint

基本类型：number，string，boolean，null，undefined，symbol，bigint
引用类型：object （但这个时候并不是等着你只说 object，我就翻过车 ）

引用类型包括 Object 类型，Array 类型，Function 类型，Map 类型，WeakMap 类型，WeakSet 类型，Set 类型，RegExp 类型等等

## 7. 深拷贝

（深拷贝需考虑特殊情况，undefined，function，symbol，相互引用）

- 通过 JSON.parse(JSON.stringify(obj))
  - 但这种方式有局限性，当值为 undefined，symbol，Function 会在转换过程中被忽略
  - 如果被拷贝的对象中，存在 bigint，会报错
  - 如果被拷贝的对象中，存在循环引用的时候，会报错
    ```
    let obj = { }
    obj.a = obj
    JSON.parse(JSON.stringify(obj)) // 会报错
    ```
  - 如果 obj 里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串
  - 如果 obj 里有 Set，Map，RegExp，Error 对象，则序列化的结果将只得到空对象，如果直接 JSON.parse(JSON.stringify( )) 这些对象的时候，得到的也只是空对象，但是可以拷贝 Array 数组
  - 如果 obj 里有 NaN、Infinity 和 -Infinity，则序列化的结果会变成 null
  - 不能拷贝函数，JSON.stringify(function) 为 undefined
- 所以还得自己实现递归函数进行深拷贝

  - 先考虑各种特殊情况

    - 拷贝函数

      ```
      function fn(a, b, c) {
        return a * b * c;
      }

      // 方式 1，很多函数库都是用这个方法
      var newFn = new Function('return ' + fn.toString())();

      // 方式 2，利用 bind 返回函数，如果 bind 没有参数，或者传入的为 null，则指向 window
      var newFn = fn.prototype.bind();
      ```

    - 拷贝 symbol

      ```
      // 方法 1，返回对象身上全部 symbol 类型组成的数组
      Object.getOwnPropertySymbols(…)

      // 方法 2， 获取所有的键，同时包括 Symbol，但不会获取深拷贝原型链上的数据
      Reflect.ownKeys(…)
      ```

    - 解决循环引用
      - 用 map 存各个值或引用，如果碰到重复，直接返回引用

## 8. 事件捕获，事件冒泡，事件委托

#### 事件委托 和 事件冒泡

- 事件捕获
  - 事件捕获是先从最外层的 DOM 元素开始，逐层向内寻找目标元素，直到找到触发事件的元素为止，事件在捕获过程中被依次触发
- 事件冒泡
  - 事件触发后，会从目标元素开始，逐层向外冒泡，直到最外层的 DOM 元素，事件在冒泡过程中被依次触发
- 如何选择不同模式
  - 可以通过 addEventListener 方法的第三个参数（布尔值）来决定事件的绑定方式，即是在事件捕获还是事件冒泡的过程中触发，如果该参数为 true，则表示事件使用事件捕获机制，如果为 false 或者不传递该参数，则表示事件使用事件冒泡机制
- 触发事件的过程

  - 其实本质是三个阶段，① 捕获阶段，② 目标阶段，③ 冒泡阶段
  - 在目标阶段中，找到事件目标并触发相应的事件，而目标元素上的事件触发顺序，并不是先捕获，再冒泡的顺序，而是按照绑定在目标元素上的事件代码声明的顺序
  - 总结：**绑定在被点击元素的事件是按照代码的顺序发生的，其他非绑定的元素则是通过冒泡或者捕获的触发**（按照 W3C 的标准，先发生捕获事件，后发生冒泡事件）
  - 例，存在 div1，以及其子元素 div2，当我们点击 div2 元素的时候，并不是按照先触发 div2 的捕获事件，再触发 div2 的冒泡事件，在目标元素上，触发时，只看事件代码声明顺序

    ```
    // 点击 div2 的时候，结果是 div2_捕获 -> div_2冒泡 -> div1的顺序

    div1.addEventListener("click",function(){
        alert("div1");
    }, false);
    div2.addEventListener("click",function(){
        alert("div2_捕获");
    }, true);
    div2.addEventListener("click",function(){
        alert("div2_冒泡");
    }, false);
    ```

    ```
    // 点击 div2 的时候，结果是 div2_冒泡 -> div_2捕获 -> div1的顺序

    div1.addEventListener("click",function(){
        alert("div1");
    }, false);
    div2.addEventListener("click",function(){
        alert("div2_冒泡");
    }, false);
    div2.addEventListener("click",function(){
        alert("div2_捕获");
    }, true);
    ```

#### 事件委托

- 事件委托也叫事件代理，即是把原本需要绑定在子元素的响应事件（click、keydown…等）委托给祖先元素，让祖先元素担当事件监听的职务，事件代理的原理是 DOM 元素的事件冒泡，然后通过 target 参数来获取触发事件的目标元素，进行相应的不同处理
- 优点
  - 可以大量节省内存占用（代码量减少），减少事件注册，比如在 ul 上代理所有 li 的 click 事件
  - 可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
- 缺点
  - 事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件

## 9. 全局对象

- 在浏览器环境中，全局对象是 window 对象。而在 Node.js 环境中，全局对象是 global 对象
- 在浏览器环境下，不管是不是严格模式，通过 var 申明的变量都会出现在 window 对象身上
- 在 Node.js 环境下，

#### 10. 代码副作用

https://juejin.cn/post/7049997465814040606
https://zhuanlan.zhihu.com/p/379503009
https://juejin.cn/post/6908512860683370503
