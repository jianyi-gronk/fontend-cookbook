## 1. 无作用域导致样式污染

- CSS 有一个被大家诟病的问题就是没有本地作用域，所有声明的样式都是全局的
- SPA 应用流行了之后这个问题变得更加突出了，因为对于 SPA 应用来说所有页面的样式代码都会加载到同一个环境中，样式冲突的概率会大大加大
- 因此存在问题：
  - 很难为选择器起名字
  - 团队多人合作困难，容易冲突

## 2. 无用的 CSS 样式堆积

- 在开发新的功能或者进行代码重构的时候，由于 HTML 代码和 CSS 样式之间没有显式的对应关系，所以很难辨认出项目中哪些 CSS 样式代码是有用的哪些是无用的，这就导致了我们不敢轻易删除代码中可能是无用的样式。这样随着时间的推移，项目中的 CSS 样式只会增加而不会减少
- 因此存在问题：
  - 项目变得越来越重量级，加载到浏览器的 CSS 样式会越来越多，会造成一定的性能影响
  - 开发成本越来越高，堆积起来的样式难以理清

## 3. 基于状态的样式定义

- 对于 SPA 应用，特别是一些交互复杂的页面，页面的样式通常要根据组件的状态变化而发生变化
- 最常用的方式是通过不同的状态定义不同的 className 名，这种方案代码看起来十分冗余和繁琐，通常为了实现方案，需要同时改动 js 代码和 css 代码

（ 上面三个是存在的问题，下面是解决方案 ）

## 4. BEM

- 是一种 CSS 命名方法论，意思是模块（Block），元素（Element），修饰符（Modifier）的简写
  形式为 .block\_\_element--modifier，也就是模块名 + 元素名 + 修饰器名
- 这种命名方法让 CSS 便于统一团队开发规范和方便维护
- BEM 思想通常用于组件库，业务代码中结合 less 等预处理器
- 优点：
  - 人为严格遵守 BEM 规范，可以解决无作用域样式污染问题
  - 可读性好，一目了然是那个 dom 节点，对于无用 css 删除，删除了相应 dom 节点后，对应的 css 也能比较放心的删除，不会影响到其他元素样式
- 缺点：
  - 命名太长（个人开发习惯、部分人会觉得，我认为命名长提高了可读性，能解决一些问题，也不叫缺点），至于体积增大，gzip 可忽略

## 5. CSS in JS

- CSS in JS 是 2014 年推出的一种设计模式，它的核心思想是把 CSS 直接写到各自组件中，也就是说用 JS 去写 CSS，使用 JavaScript 的语法，是 JS 脚本的一部分，而不是单独的样式文件里
- 跟传统的前端开发思维不一样，传统的原则是关注点分离，如常说的不写行内样式、不写行内脚本
- 实现方式：
  - 唯一 CSS 选择器，样式名为唯一值，代表库：styled-components
  - 内联样式，天生可以防止样式污染，代表库：Radium
- 优点：
  - 没有无作用域问题样式污染问题
  - 没有无用的 CSS 样式堆积问题，CSS-in-JS 会把样式和组件绑定在一起，当这个组件要被删除掉的时候，直接把这些样式代码删除掉就好了
  - 由于 CSS 是写在 JavaScript 里面的，我们还可以利用 JS 显式的变量定义，模块引用等语言特性来追踪样式的使用情况，这大大方便了我们对样式代码的更改或者重构
  - 更好的基于状态的样式定义，因为会直接将 CSS 样式写在 JS 文件里面，所以样式复用以及逻辑判断都十分方便
- 缺点：
  - 代码可读性差：大多数 CSS-in-JS 实现会通过生成唯一的 CSS 选择器来达到 CSS 局部作用域的效果。这些自动生成的选择器会大大降低代码的可读性，给开发人员 debug 造成一定的影响
  - 运行时消耗大，由于大多数的 CSS-in-JS 的库都是在动态生成 CSS 的。这会有两方面的影响。首先你发送到客户端的代码会包括使用到的 CSS-in-JS 运行时（runtime）代码，这些代码一般都不是很小，例如 styled-components 的 runtime 大小是 12.42kB min + gzip，如果你希望你首屏加载的代码很小，你得考虑这个问题。其次大多数 CSS-in-JS 实现都是在客户端动态生成 CSS 的，这就意味着会有一定的性能代价。不同的 CSS-in-JS 实现由于具体的实现细节不一样，所以它们的性能也会有很大的区别
  - 不能结合成熟的 CSS 预处理器（或后处理器）Sass/Less/PostCSS，标签内联样式在处理 :hover 和 :active 伪类处理起来复杂

## 6. CSS modules

- css-modules 将 css 代码模块化，可以避免本模块样式被污染，并且可以很方便的复用 css 代码
- 依赖 webpack 的 css-loader
  - 配置如下
    ```
    module.exports = {
      module: {
          rules: [
              {
                test: /\.css$/i,
                loader: "css-loader",
                options: {
                    modules: true,
                },
              },
          ],
      },
    };
    ```
  - 取决于 modules 属性，默认值：undefined
    - undefined - 为所有匹配 /\\.module\\.\\w+\$/i.test(filename) 与 /\\.icss\\.\w+\$/i.test(filename) 正则表达式的文件启用 CSS 模块，例 test.module.css
    - true - 对所有文件启用 CSS 模块
    - false - 对所有文件禁用 CSS 模块
    - string - 对所有文件禁用 CSS 模块并设置 mode 配置项
    - object - 如果没有配置 modules.auto 则对所有文件启用 CSS 模块，否则 modules.auto 配置项则会决定其是否为 CSS 模块
  - 设置为 false 值会提升性能，因为避免了 CSS Modules 特性的解析，这对于使用普通 CSS 或者其他技术的开发人员是非常有用的
- 使用 CSS modules 示例

  - 存在 style.css，其中有 .title 样式
    ```
    .title {
        color: red;
    }
    ```
  - 将 CSS 文件 style.css 引入为 style 对象后，通过 style.title 的方式使用 title class

    ```
    import style from './style.css';

    export default () => {
      return (
        <p className={style.title}>
          I am KaSong.
        </p>
      );
    };
    ```

  - 打包工具会将 style.title 编译为带哈希的字符串
    ```
    <h1 class="_3zyde4l1yATCOkgn-DBWEL">
      Hello World
    </h1>
    ```
  - 同时 style.css 也会编译
    ```
    ._3zyde4l1yATCOkgn-DBWEL {
      color: red;
    }
    ```
  - 这样，就产生了独一无二的 class，解决了 CSS 模块化的问题

- 使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 :local，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 :global，:local 与 :global 的区别是 CSS Modules 只会对 :local 块的 class 样式做 localIdentName 规则处理，:global 的样式编译后不变

  ```
  .title {
    color: red;
  }

  :global(.title) { // 这个编译之后，就不会变为唯一的值，而是仍为 .title
    color: green;
  }
  ```

- 优点：
  - 简单，学习成本低
  - 解决 css 无作用域样式污染问题
- 缺点：
  - 代码可读性差，一串乱七八糟的值不方便 debug
  - 写法没有传统开发流程，如果你不想频繁的输入 styles.xxx，可以试一下 react-css-modules，它通过高阶函数的形式来避免重复输入 styles.xxx

## 7. 预处理器

- 绝大多数 CSS 预处理器会增加一些原生 CSS 不具备的特性，例如 代码混合，嵌套选择器，继承选择器 等
- 这些特性让 CSS 的结构更加具有可读性且易于维护
- 常见的有 sass，less，Stylus，PostCSS
- 优点：
  - 利用嵌套，人为严格遵守嵌套首类名不一致，可以解决无作用域样式污染问题
  - 可读性好，一目了然是那个 dom 节点，对于无用 css 删除，删除了相应 dom 节点后，对应的 css 也能比较放心的删除，不会影响到其他元素样式
- 缺点：
  - 需要借助相关的编译工具处理
- 预处理器是现代 web 开发中必备，结合 BEM 规范，利用预处理器，可以极大的提高开发效率，可读性，复用性

## 8. Shadow DOM

（ 这里只是简单介绍，详细的看另一篇 ）

- 经常在微前端领域看到 Shadow DOM，如下创建一个子应用
  ```
  const shadow = document.querySelector('#hostElement').attachShadow({mode: 'open'});
  shadow.innerHTML = '<sub-app>Here is some new text</sub-app><link rel="stylesheet" href="//unpkg.com/antd/antd.min.css">';
  ```
  由于子应用的样式作用域仅在 shadow 元素下，那么一旦子应用中出现运行时越界跑到外面构建 DOM 的场景，必定会导致构建出来的 DOM 无法应用子应用的样式的情况
  比如 sub-app 里调用了 antd modal 组件，由于 modal 是动态挂载到 document.body 的，而由于 Shadow DOM 的特性 antd 的样式只会在 shadow 这个作用域下生效，结果就是弹出框无法应用到 antd 的样式。解决的办法是把 antd 样式上浮一层，丢到主文档里，但这么做意味着子应用的样式直接泄露到主文档了
- 优点：
  - 浏览器原生支持
  - 严格意义上的样式隔离，如 iframe 一样
- 缺点：
  - 浏览器兼容问题
  - 只对一定范围内的 dom 结构起作用，上面微前端场景已经说明

## 9. vue scoped

- vue 中当 \<style\> 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素
- 不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式，父组件利用深度作用选择器影响子组件内部的样式
- 原理是组件元素加上 [data-v-f3f3eg9] 类似的 data-v-xxx 的唯一值，然后通过属性选择器，避免样式污染
- 优点：
  - 非常的简便
- 缺点：
  - 只能在 vue 身上用
