## 1. 常用标签

（百度他是真的问）

- 行内元素
  span，a
- 行内块元素
  img，button，input
- 块级元素
  h1 ~ h6（标题标签），div，p
- 接下来就是引导面试官的（不会就别说）
  - script
  - canvas
  - meta

## 2. html5 新增特性

1. 语义化标签，例如 header，footer，section，article 等，提升页面的阅读性（结构性增强），更有利于 SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如 strong 标签内的内容会重读）
2. 新增 canvas 标签用于绘图（标签只是图形容器，必须使用脚本来绘制图形）
3. SVG 绘图：SVG 是指可伸缩的矢量图形，SVG 是一种使用 XML 描述 2D 图形的语言（而 Canvas 通过 JavaScript 来绘制 2D 图形）
4. 增强表单功能：
   1. 更多 input 的 type 输入类型，这些新特性提供了更好的输入控制和验证，例如 color，date，datetime，url，email 等等
   2. 更多表单元素，例 datalist 标签，keygen 标签，output 标签
   3. 新增一些表单元素的属性，例 required（表示不能为空），pattern（值为正则表达式用于验证 input 的值），step（为输入域规定合法的数字间隔）等等
5. 获取地理定位，通过 Geolocation 用于定位用户的位置
   - 在 navigator 对象上，其提供浏览器及操作系统等信息，例如 浏览器名称，浏览器的平台和版本信息，运行浏览器的操作系统平台 等等
   ```
   window.navigator.geolocation {
       getCurrentPosition:  fn  用于获取当前的位置数据
       watchPosition: fn  监视用户位置的改变
       clearWatch: fn  清除定位监视
   }
   ```
6. 新增媒体元素 audio 和 video：这两标签能够很容易的输出音频或视频流，提供便利的获取文件信息的 api
7. 拖放 api：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放，拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。（在元素对象的身上放着的 api 用于获取或操作数据）
8. WebStorage：localStorage 和 sessionStorage 大伙应该都清楚，在本地存储数据
9. WebSocket：是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 Web Socket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send()方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。
   （详细可以看[这里](http://ruanyifeng.com/blog/2017/05/websocket.html)）
   （提一嘴，webpack 的热加载功能就用到了 websocket。为什么我们改动代码后，浏览器能自动的做出响应呢？这里就是 websocket 的全双工通信的作用，不仅浏览器可以给服务端发送请求，而且服务器也可以反向的给浏览器发送请求。当我们在编辑器（在开发环境就相当于是服务器端）改好代码后，编辑器会发送 websocket 请求到浏览器（就是我们控制台看到的那个 websocket），浏览器收到请求后就知道服务端的代码更新了，就会重新发送请求读取更新后的内容。所以我们开发的时候，在浏览器网络那块有时候能看到一堆 ws 请求）
10. Web Worker：其作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
    （详细可以看[这里](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)）
