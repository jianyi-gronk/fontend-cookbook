## 1. es5 实现继承

【 常用继承方式使用组合式继承、寄生式组合继承，具体场景具体使用 】

1. 通过原型链继承：

   - 就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果，让子类的构造函数的原型对象指向父类的实例对象
   - 存在缺陷：
     - 在创建子类实例的时候，不能向父类的构造函数中传递参数
     - 原型中包含的引用值会在所有实例之间共享，修改一个实例，另一个实例会跟着修改
       （不同子类实例，修改的同一个父类实例的值）

   ```javascript
   function Father() {
   	this.colors = ['red', 'blue', 'green']
   }

   function Son() {}
   Son.prototype = new Father()

   let instance1 = new Son()
   instance1.colors.push('black')
   console.log(instance1.colors) // "red,blue,green,black"

   let instance2 = new Son()
   console.log(instance2.colors) // "red,blue,green,black"
   ```

2. 借用构造函数继承：

   - 利用 call 调用父构造函数，且让 this 指向子构造函数
   - 存在缺陷：
     - 子类不能访问父类原型上定义的方法，所以必须在父构造函数中定义方法，因此函数不能复用

   ```javascript
   function Father(num) {
   	this.num = num
   }
   Father.prototype.test = function () {
   	console.log(111)
   }

   function Son(num) {
   	Father.call(this, num)
   	this.n = num
   }

   let instance = new Son(123)
   console.log(instance.n) // 123
   console.log(instance.num) // 123
   console.log(instance.test()) // instance.test is not a function
   ```

3. 组合继承：

   - 通过原型链继承来继承方法，借用构造函数继承来继承属性，这样函数可以复用，且子实例进行修改时，不会相互影响
   - 存在缺陷：
     - 组合式继承存在效率问题，父类构造函数会被调用两次，第一次在创建子类原型，第二次在子类构造函数中调用
     - 最终导致子类原型包含父类所有的实例属性，浪费空间（因为属性在子实例上，方法在原型链上，所以子构造函数的原型对象不需要包含父类属性）

   ```javascript
   function Father(name) {
   	this.name = name
   	this.colors = ['red', 'blue', 'green']
   }
   Father.prototype.sayName = function () {
   	console.log(this.name)
   }

   function Son(name, age) {
   	Father.call(this, name) // 第二次调用 Father()
   	this.age = age
   }
   Son.prototype = new Father() // 第一次调用 Father()
   subType.prototype.constructor = subType
   Son.prototype.sayAge = function () {
   	console.log(this.age)
   }

   let instance1 = new Son('Nicholas', 29)
   instance1.colors.push('black')
   console.log(instance1.colors) // "red,blue,green,black"
   instance1.sayName() // "Nicholas";
   instance1.sayAge() // 29

   let instance2 = new Son('Greg', 27)
   console.log(instance2.colors) // "red,blue,green"
   instance2.sayName() // "Greg";
   instance2.sayAge() // 27
   ```

4. 原型式继承：

   - 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。**从本质上讲，object()对传入其中的对象执行了一次浅复制**
     【 新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 name 和一个引用类型值属性 friends。这意味着 person.friends 不仅仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本 】
   - 存在缺陷：
     - 属性中包含的引用数值，会在对象之间共享，与原型链继承中引用数值会共享类似

   ```javascript
   function object(o) {
   	function F() {}
   	F.prototype = o
   	return new F()
   }

   let person = {
   	name: 'Nicholas',
   	friends: ['Shelby', 'Court', 'Van'],
   }

   let anotherPerson = object(person)
   anotherPerson.name = 'Greg'
   anotherPerson.friends.push('Rob')

   let yetAnotherPerson = object(person)
   yetAnotherPerson.name = 'Linda'
   yetAnotherPerson.friends.push('Barbie')

   console.log(person.name) // "Nicholas"
   console.log(person.friends) // "Shelby,Court,Van,Rob,Barbie"
   ```

5. 寄生式继承：

   - 将 object 封装，在函数中以某种方式增强这个继承后的对象
   - 存在缺陷：给对象添加函数会导致函数难以重用，与构造函数模式类似

   ```javascript
   function object(o) {
   	function F() {}
   	F.prototype = o
   	return new F()
   }

   function createAnother(original, sex) {
   	let clone = object(original) // 通过调用函数创建一个新对象
   	clone.sex = sex
   	clone.sayHi = function () {
   		// 以某种方式增强这个对象
   		console.log('hi')
   	}
   	return clone // 返回这个对象
   }

   let person = {
   	name: 'Nicholas',
   	friends: ['Shelby', 'Court', 'Van'],
   }

   let anotherPerson = createAnother(person, 'famle')
   console.log(anotherPerson.sex) // "famle"
   anotherPerson.sayHi() // "hi"
   ```

6. 寄生式组合继承：

   - 寄生组合继承的模式是现在业内公认的比较可靠的 JS 继承模式，ES6 的 class 继承在 babel 转义后，底层也是使用的寄生组合继承的方式实现的
   - 解决了上述几个方法的问题：
     - 继承属性，靠的是借用构造函数继承，修改不会影响其他子实例
     - 继承方法，指向一个 "空" 的构造函数的实例，这个空的构造函数的原型指向父构造函数的原型
       【 就是在这里，优化了 "父类构造函数会被调用两次" 这个问题，不通过指向 new 父构造函数，间接让父构造函数的原型在原型链上，而是想直接指向。但为了让子实例可以加私有方法，所以 new 一个空构造函数，让这个空构造函数指向父构造函数的原型，这样就避免了 new 父构造函数时，重复运行父类构造函数 】

   ```javascript
   // 实现继承的核心函数
   function inheritPrototype(subType, superType) {
   	function F() {}
   	//F()的原型指向的是superType
   	F.prototype = superType.prototype
   	//subType的原型指向的是F()
   	subType.prototype = new F()
   	// 重新将构造函数指向自己，修正构造函数
   	subType.prototype.constructor = subType
   }

   // 设置父类
   function SuperType(name) {
   	this.name = name
   	this.colors = ['red', 'blue', 'green']
   	SuperType.prototype.sayName = function () {
   		console.log(this.name)
   	}
   }

   // 设置子类
   function SubType(name, age) {
   	//构造函数式继承--子类构造函数中执行父类构造函数
   	SuperType.call(this, name) // 只在这里运行了一次父类构造函数
   	this.age = age
   }

   // 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费
   inheritPrototype(SubType, SuperType)

   // 添加子类私有方法
   SubType.prototype.sayAge = function () {
   	console.log(this.age)
   }

   var instance = new SubType('Taec', 18)
   console.dir(instance)
   ```

## 2. es5 实现箭头函数

其实就是拿个变量保存上下文的 this（通常用 \_this）

```javascript
ES6 function foo() {
    setTimeout(() => {
        console.log('id:', this.id);
    }, 100);
  }

ES5 function foo() {
    var _this = this;
    setTimeout(function () {
        console.log('id:', _this.id);
    }, 100);
}
```

## 3. 函数柯里化

- 固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成一个个的单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数，是 js 闭包的典型应用，例

```javascript
function add(a, b, c) {
	return a + b + c
}

function _add(a) {
	return function (b) {
		return function (c) {
			return a + b + c
		}
	}
}

add(1, 2, 3)
_add(1)(2)(3)
```

```javascript
function add() {
	// 第一次执行时，定义一个数组专门用来存储所有的参数
	// 因为 arguments 是类数组对象，不是数组，身上很多方法都没有
	// 伪数组的特性：
	//     具有 length 属性
	//     按索引方式储存数据
	//     不具有数组的 push , pop 等方法
	// 所以不能直接调用 slice
	// 利用闭包的特性保存 _args 并收集每一次传入的的参数值
	var _args = Array.prototype.slice.call(arguments)

	// 在内部声明一个函数
	var _adder = function () {
		// 每一次调用，都会向 _args 添加新传入的参数值
		// arguments 是对象，是可以用 ... 解构的
		_args.push(...arguments)
		return _adder
	}

	// 利用 toString 隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
	// toString 就是被 console.log 的时候，返回的值
	// 因为我们每一次返回的都是函数，但是打印出来需要时具体的结果值
	_adder.toString = function () {
		// 每一次被打印的时候，就把到现在为止，传进来的所有参数，进行累加操作
		return _args.reduce(function (a, b) {
			return a + b
		})
	}
	// 返回的是函数，_args 因为闭包，不会被垃圾回收
	return _adder
}

console.log(add(1)(2)(3).toString()) // 6
console.log(add(1, 2, 3)(4).toString()) // 10
console.log(add(1)(2)(3)(4)(5).toString()) // 15
console.log(add(2, 6)(1).toString()) // 9
```

#### 4. 打乱数组内容

1. 通过 sort

   ```javascript
   const arr = [4, 1, 67, 12, 45, 121, 3]
   arr.sort(() => 0.5 - Math.random())
   console.log(arr)
   ```

2. 通过 Fisher-Yates （ 也称为 Knuth ）洗牌算法

   ```javascript
   function shuffle(array) {
   	let currentIndex = array.length,
   		temporaryValue,
   		randomIndex

   	// 当数组中的元素尚未处理完时
   	while (currentIndex !== 0) {
   		// 从数组中随机选取一个元素的索引
   		randomIndex = Math.floor(Math.random() * currentIndex)
   		currentIndex -= 1

   		// 将随机选取的元素与数组的最后一个元素交换位置
   		temporaryValue = array[currentIndex]
   		array[currentIndex] = array[randomIndex]
   		array[randomIndex] = temporaryValue
   	}

   	return array
   }

   // 使用示例：
   const arr = [1, 2, 3, 4, 5]
   console.log(shuffle(arr))
   ```
