## 1. es6 常用新特性（没写完）

（说实话，一个个让我讲，我应该是会的，就是上次面试，突然提起来，让我列举一下，让我有点懵，这只是列举，不详讲）

1. **新增 Set，Map，WeakSet，WeakSet**
2. **新增 bigint 和 symbol**
3. **新增 模块化**
4. **新增 迭代器**
5. **新增 generator 和 yield**
6. **新增箭头函数**
7. **新增 Promise**
8. **新增 Proxy 代理**
9. **新增 Reflect 反射**
10. 新增 let，const
11. 新增 class
12. 新增模板字符串 \` ... \`
13. 新增解构表达式 ...
14. 数组相关扩展
    1. 新增静态方法
       1. from()
       2. of()
    2. 新增实例方法
       1. copyWithin()
       2. find()、findIndex()
       3. fill()
       4. entries()，keys()，values()
       5. includes()
       6. flat()，flatMap()
15. 新增 Decorator（这个高级，以前没见过，现在来补补）

## 2. 强引用 和 弱引用

- 引用数据类型，即引用类型在栈中存储了指针，这个指针指向堆内存中的地址，真实的数据存放在堆内存里
- 强引用
  - 将一个引用类型数据通过变量或常量保存，这个变量或常量就是强引用
  - 如果存在强引用指向堆内存，则堆内存不会被当作垃圾回收掉
  ```
  // test 就是强引用
  let test = { a: 1, b: 2 }
  ```
- 弱引用
  - WeakMap 的键只能是弱引用，WeakSet 的值只能是弱引用，WeakRef 传入对象，返回其弱引用
  - 如果存在弱引用指向堆内存，但没有强引用指向堆内存，则堆内存仍然会被当做垃圾回收掉
  - 但是注意，并不是说，没有强引用指向，就直接垃圾回收了，垃圾回收是懒回收，当觉得你这个占用内存过多，影响到运行，才会值行垃圾回收，否则频繁执行垃圾回收，会阻塞
  ```
  let a = new Set();
    let b = new WeakSet();
    for(let i = 0; i < 100; i++) {
        a.add({});
        b.add({});
    }
    console.log(a);
    console.log(b); // 此时 b 内还有 100 个元素，都没有被回收
  ```
  ```
  let a = new Set();
    let b = new WeakSet();
    for(let i = 0; i < 10000; i++) {
        a.add({});
        b.add({});
    }
    console.log(a);
    console.log(b); // 此时 b 内没有元素，全部都被回收了
  ```

## 3. WeakMap，WeakSet，WeakRef

#### WeakMap

- 与 Map 的 api 类似，且其中的键都是唯一的
- 与 Map 的区别为
  - 因为弱引用，WeakMap 的键是不可枚举的（没有方法能给出所有的键），如果键是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果
  - WeakMap 的键只能是 Object 类型，而不能像 Map 那样，可以是任何类型的任意值
  - 键为弱引用，如果没有其他的对 WeakMap 中键的引用，那么这些键值对会被垃圾回收掉

#### WeakSet

- 与 Set 的 api 类似，且其中的元素都是唯一的
- 与 Set 的区别为
  - 因为弱引用，WeakSet 的元素是不可枚举的（没有方法能给出所有的元素），如果元素是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果
  - WeakSet 只能是 Object 的集合，而不能像 Set 那样，可以是任何类型的任意值
  - 集合中对象的引用为弱引用，如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被垃圾回收掉

#### WeakRef

- new WeakRef()
  WeakRef 对象包含对对象的弱引用
  ```
  let ref = new WeakRef(targetObject) // ref 即是对 targetObject 的弱引用
  ```
- WeakRef.prototype.deref()
  deref 方法返回 WeakRef 实例的目标对象，如果目标对象已被垃圾收集，则返回 undefined
  ```
  let obj = ref.deref(); // 这个 obj 是强引用
  ```

## 4. Proxy

#### 构造函数

```
new Proxy(target, handler)
// target 表示的是要拦截（代理）的目标对象，handler 是一个对象，其属性提供某些操作发生时所对应的处理函数，用来定制拦截行为
```

#### handler 上的方法

- handler.apply(target, object, args)：函数调用劫持
- handler.construct(target, args)：new 操作符劫持
- handler.defineProperty(target, propKey, propKeypropDesc)：Object.defineProperty 调用劫持
- handler.deleteProperty(target, propKey)：delete 操作符劫持
- handler.get(target, propKey)：获取属性值劫持
- handler.getOwnPropertyDescriptor(target, propKey)：Object.getOwnPropertyDescriptor 调用劫持
- handler.getPrototypeOf(target)：Object.getPrototypeOf 调用劫持
- handler.has(target, propKey)：in 操作符劫持
- handler.isExtensible(target)：Object.isExtensible 调用劫持
- handler.ownKeys(target)：Object.getOwnPropertyNames 和 Object.getOwnPropertySymbols 调用劫持
- handler.preventExtensions(target)：Object.preventExtensions 调用劫持
- handler.set(target, propKey, value, receiver)：设置属性值劫持
- handler.setPrototypeOf(target, proto)：Object.setPrototypeOf 调用劫持

#### 小细节

- 代理对象不等于目标对象，它是目标对象的包装品
- 目标对象既可以直接操作，也可以被代理对象操作，且两者相互关联
- 如果直接操作目标对象，则会绕过代理定义的各种拦截行为，不过用了代理，那肯定是希望给对象的操作嵌入我们定义的特殊行为，所以一般就操作代理对象就好

## 5. Reflect 反射

#### 设计 Reflect 的意义是什么

借用 阮一峰大佬 对 Reflect 的解释

- Object 里已有的明显属于元编程的函数挪到 Reflect 里，日后如果加新的元编程函数将只会加在 Reflect 里
- 挪动时如果发现 Object 里的原始函数行为不合理，在挪动后的新版上做修正
- 把操作符作函数化（ delete，in，new 这三个 ）
- Proxy 支持（ 和 Proxy 的 handler 上方法名相同 ）

【 元编程的操作对象是代码，是程序，主要是给库和框架用的，在 day to day 的日常开发中几乎用不到，类似的还有 Symbol。这些东西怎么说呢，专家们探讨决策后发现必须得有，但不是让你日常经常去用的，所以业务程序员会觉得好像不怎么需要用，这是很正常的 】

#### Reflect 上的方法

- Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与 proxy 的 handler 上方法命名相同
  与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用
  Reflect 的所有属性和方法都是静态的（就像 Math 对象） - Reflect.apply(target, thisArgument, argumentsList)：
  对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似 - Reflect.construct(target, argumentsList[, newTarget])：
  对构造函数进行 new 操作，相当于执行 new target(...args) - Reflect.defineProperty(target, propertyKey, attributes)：
  和 Object.defineProperty() 类似。如果设置成功就会返回 true - Reflect.deleteProperty(target, propertyKey)：
  作为函数的 delete 操作符，相当于执行 delete target[name] - Reflect.get(target, propertyKey[, receiver])
  获取对象身上某个属性的值，类似于 target[name] - Reflect.getOwnPropertyDescriptor(target, propertyKey)：
  类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined - Reflect.getPrototypeOf(target)：
  类似于 Object.getPrototypeOf() - Reflect.has(target, propertyKey)：
  判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同 - Reflect.isExtensible(target)
  类似于 Object.isExtensible() - Reflect.ownKeys(target)
  返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响) - Reflect.preventExtensions(target)
  类似于 Object.preventExtensions()。返回一个 Boolean - Reflect.set(target, propertyKey, value[, receiver])
  将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true - Reflect.setPrototypeOf(target, prototype)
  设置对象原型的函数。返回一个 Boolean，如果更新成功，则返回 true

## 6. CommonJS 和 ES6 模块化的区别

1. CommonJS 是同步加载模块，ES6 是异步加载模块
   - CommonJS：
     - CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作，由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用
   - ES6：
     - 浏览器加载 ES6 模块是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本
2. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

   - CommonJS：
     - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值
   - ES6：

     - ES6 模块的运行机制，当 JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值
     - 因此，ES6 模块是动态引用，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块

       ```
       // m1.js
       export var foo = 'bar';
       setTimeout(() => foo = 'baz', 500);

       // m2.js
       import {foo} from './m1.js';
       console.log(foo);
       setTimeout(() => console.log(foo), 500);

       // 输出
       bar
       baz
       ```

     - 此外，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例

       ```
       // mod.js
       function C() {
         this.sum = 0;
         this.add = function () {
           this.sum += 1;
         };
         this.show = function () {
           console.log(this.sum);
         };
       }

       export let c = new C();
       ```

       ```
       // x.js
       import {c} from './mod';
       c.add();

       // y.js
       import {c} from './mod';
       c.show();

       // main.js
       import './x';
       import './y';

       // 输出
       1
       ```

     - 但这个引用变量类似于 const 变量，不可对它重新赋值

       ```
       // lib.js
       export let obj = {};

       // main.js
       import { obj } from './lib';

       obj.prop = 123; // OK
       obj = {}; // TypeError（相当于 const）
       ```

3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
   - CommonJS：
     - CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成
   - ES6：
     - ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成

## 7. export 和 export default

- ES6 中，在 JavaScript ES6 中，export 与 export default 均可用于导出常量、函数、文件、模块等

  - 在一个文件或模块中，export、import 可以有多个，export default 仅有一个
  - 通过 export 方式导出，在导入时要加 { }，export default 则不需要，并可以起任意名称

    - 输出单个值，使用 export default
    - 输出多个值，使用 export
    - export default 与 export **可以同时使用**，但是不建议（不如都用 export ）

    ```
    var arr = [1, 2, 3, 4];
    var obj = { name:'123', type:1 }
    export { arr, obj }
    export default {
        set(name) {
            console.log(name)
            return name + '123'
        }
    }
    ```

    ```
    import { arr, obj } from "@/utils/common";
    import comm from "@/utils/common";
    console.log(arr)
    console.log(obj)
    console.log(comm.set('abc'))
    ```

    ```
    // 引入简化
    import comm, { arr, obj } from "@/utils/common";
    ```

## 8. 箭头函数

1. 箭头函数不绑定 this，会捕获其所在上下文的 this，作为自己的 this
2. 箭头函数是匿名函数，不能作为构造函数，不可以使用 new 命令，否则后抛出错误
3. 箭头函数没有绑定 arguments，super，new.target 等，取而代之用 rest 参数解决
4. 使用 call，apply，bind 并不会改变箭头函数中的 this 指向
5. 箭头函数没有原型对象 prototype 这个属性，因为不可以通过 new 关键字调用，所以没有构建原型的需求，所以箭头函数没有 prototype 这个属性
6. 不能使用 yield 关键字，不能用作 Generator 函数

## 9. generator（生成器）

[详细介绍](https://juejin.cn/post/7111873446379782180)

#### generator 介绍

1. generator 是 ES6 提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行 generator，会生成返回一个遍历器对象。返回的遍历器对象，可以依次遍历 generator 函数的每一个状态。同时 ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Genarator 函数的 prototype 对象上的方法

2. 最简单的 generator 函数,其实它就是一个普通的函数，但是它有两个特征：
   - 第一就是 function 关键字与函数名之间有一个\*号
   - 其二就是函数体内使用 yield 表达式来遍历状态
   ```
   function* newGenerator() {
     yield 'hello';
     yield 'world';
     return 'ending';
   }
   ```
3. 执行 generator 函数之后，该函数并不会立即执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。通常使用遍历器对象的 next 方法。使得指针移向下一个状态。每一次调用 next() 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式位置，由此可以看出，generator 是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行

   【注：generator 函数可以随心所欲的交出和恢复函数的执行权，yield 交出执行权，next() 恢复执行权】

#### yield

1. yield 表达式在 generator 中是作为一个暂停标志，当碰到 yield 时，函数暂停执行。等到下一次 next() 执行时，函数才从当前 yield 位置开始执行。并且，yield 表达式只能用在 Generator 函数里边。同时，yield 如果后边带一个 \*，则就是相当于一个 for...of 的简写形式，如果 yield 后边不带 \*，则返回的是 generator 的值
   ```
   function* gen() {
     yield 'hello';
     yield* 'hello';
   }
   let f = gen();
   console.log(f.next().value); // hello
   console.log(f.next().value); // h
   console.log(f.next().value); // e
   console.log(f.next().value); // l
   console.log(f.next().value); // l
   console.log(f.next().value); // o
   ```
2. 无论是触发了 yield 还是 return，next() 函数总会返回一个带有 value 和 done 属性的对象，value 为返回值，done 则是一个 Boolean 对象，用来标识 Generator 是否还能继续提供返回值
   ```
   function * oddGenerator () {
     yield 1
     yield 3
     return 5
   }
   let iterator = oddGenerator()
   let first = iterator.next()  // { value: 1, done: false }
   let second = iterator.next() // { value: 3, done: false }
   let third = iterator.next()  // { value: 5, done: true  }
   ```

#### next，throw，return

1. 以上的三个方法在本质上其实是一样的，就是让 generator 恢复执行，并且使用不同的语句来替代 yield 语句

   - next() 是将 yield 表达式替换成一个值
   - throw() 是将 yield 表达式替换成一个 throw 语句
   - return() 是将 yield 表达式替换成一个 return 语句

   例：

   ```
   function* dataConsumer() {
     console.log('Started');
     console.log(`1. ${yield}`);
     console.log(`2. ${yield}`);
     return 'result';
   }
   let genObj = dataConsumer();
   genObj.next(); // Started
   genObj.next('a'); // 1. a
   genObj.next('b'); // 2. b
   ```

2. yield test() 时，值是还没有确定的，什么时候会确定呢，就是执行下一次 next 方法时，通过传参数 next(val) 的方式来确定值，什么意思呢，看下面这段代码

   ```
   const test = () => new Promise((resolve,reject) =>
     setTimeout(() => {
         resolve('test')
     },1000)
   )

   function* func(){
       const ans = yield test();
       console.log(ans);
       const ans2 = yield test();
       console.log(ans2);
   }

   const it = func();
   const p = it.next(); // 返回 {value: Promise,done: false }，这是 ans 并没有获取到 resolve 的值
   p.value.then(res => {
       console.log(res);
       const p2 = it.next(res); // 这一步时上面代码中的 ans 才会被确定值为 res;
       p2.value.then(res => {
           console.log(res);
       })
   })
   ```

   如果 next() 中不带参数，则 yield 每次运行之后的返回值都是为 undefined，即 yield 1 运行之后返回值为 undefined

   ```
   function * oddGenerator () {
     yield 1 // 值为 undefined
   }
   let iterator = oddGenerator()
   let first = iterator.next()
   ```

#### 应用场景

1. 协程
   - 协程可以理解成多线程间的协作，比如说 A，B 两个线程根据实际逻辑控制共同完成某个任务，A 运行一段时间后，暂缓执行，交由 B 运行，B 运行一段时间后，再交回 A 运行，直到运行任务完成。对于 JavaScript 单线程来说，我们可以理解为函数间的协作，由多个函数间相互配合完成某个任务
   - Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”，意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行
   - 如果将 Generator 函数当做协程，完全可以将多个需要互相协作的任务写成 Generator 函数，他们之间使用 yield 标识交换控制权
   - Generator 函数执行产生的上下文环境，一旦遇到 yield 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 next 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。
2. 异步编程
   解决回调地狱，异步流控（按顺序控制异步操作），例：

   - 普通方法实现肚包鸡的制作过程：
     ```
     setTimeout(function() {
       console.log("prepare chicken");
       setTimeout(function() {
         console.log("fired chicken");
         setTimeout(function() {
           console.log("stewed chicken");
           ....
         },500)
       },500)
     },500);
     ```
   - 用 Generator 函数来实现肚包鸡的制作过程：

     ```
     // 准备
     function prepare(sucess) {
       setTimeout(function() {
         console.log("prepare chicken");
         sucess();
       },500)
     }

     // 炒鸡
     function fired(sucess) {
       setTimeout(function() {
         console.log("fired chicken");
         sucess();
       },500)
     }

     // 炖鸡
     function stewed(sucess) {
       setTimeout(function() {
         console.log("stewed chicken");
         sucess();
       },500)
     }

     // 上料
     function sdd(sucess) {
       setTimeout(function() {
         console.log("sdd chicken");
         sucess();
       },500)
     }

     // 上菜
     function serve(sucess) {
       setTimeout(function() {
         console.log("serve chicken");
         sucess();
       },500)
     }

     // 流程控制
     function run(fn) {
       const gen = fn();
       function next() {
         // 返回工序函数的句柄给 result
         const result = gen.next();
         if (result.done) return; // 结束
         // result.value 就是yield返回的值，是各个工序的函数
         result.value(next); // value 就是制作过程中不同阶段的函数，next 作为入参，即本工序成功后，执行下一工序
       }
       next();
     };

     //工序
     function* task(){
       yield prepare;
       yield fired;
       yield stewed;
       yield sdd;
       yield serve;
     }

     //开始执行
     run(task);
     ```

     （重点在流程控制部分，很妙的思路）

#### 使用举例

1. 实现自增 id
   ```
   function* next_id() {
     for (id = 1; ; id++) {
       yield id;
     }
   }
   ```
2. 实现 async 和 await 功能

   1. await 实现

      ```
      const test = (data) => new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve(data);
          }, 1000)
      })

      async function func(){
          const aaa = await test(1)
          const bbb = await test(2)
          return 3;
      }
      ```

   2. Generator 实现

      ```
      const test = (data) => new Promise((resolve, reject) => {
          setTimeout(()=>{
              resolve(data);
          }, 1000)
      })

      // 重点在这
      function autoStart(generator) {
          const gen = generator();
          return new Promise((resolve, reject) => { // 最终应该返回一个 Promise 对象
              function _next(val) {
                  const p = gen.next(val);
                  if(p.done) { // 递归结束条件
                      console.log(p.value);
                      resolve(p.value);
                      return;  //递归结束
                  }
                  // p.value 即 test() 返回的 Promise，在 1000 毫秒后改变状态
                  // 避免 p.value 为基本类型的情况，不然应该是 p.value.then()
                  Promise.resolve(p.value).then(res => {
                    // 在 Promise 改变状态的时候，也就是 1000 毫秒后运行
                      _next(res); // 本质就是递归
                  })
              }
              _next();
          })
      }

      function* generator(){
        const aaa = yield test(1);
          console.log(aaa);
          const bbb = yield test(2);
          console.log(bbb)
          return 3;
      }

      let res = autoStart(generator);

      console.log(res);
      setTimeout(() => {
          console.log(res);
      }, 5000);
      ```

## 10. Promise，Generator，Async 的区别

- Promise 与 Async/await 函数都是用来解决 JavaScript 中的异步问题的，从最开始的回调函数处理异步，到 Promise 处理异步，到 Generator 处理异步，再到 Async/await 处理异步，每一次的技术更新都使得 JavaScript 处理异步的方式更加优雅

#### Promise 到 Generator

- Promise 一旦新建就会立即执行，不会阻塞后面的代码
- 当很多 .then() 接着调用的时候，使用体验感很差，还是类似于回调地狱的问题

#### Generator 到 Async

- async 函数对 Generator 函数的改进，体现在：
  - async 函数执行与普通函数一样，不像 Generator 函数，需要调用 next 方法
  - async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了，可以用 then 方法指定下一步操作
  - async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果

## 11. iterator（ 迭代器 ）

#### 为什么需要迭代器

- 在 JavaScript 中，可遍历的结构以及方式有很多。其中表示 “集合” 的数据结构，主要是数组（ Array ），ES6 又添加了 Map 和 Set，这样就有了 3 种数据集合，而遍历这 3 种结构都有不同的方法，而迭代器的目的就是要标准化迭代操作
  - 不过 WeakSet 和 WeakMap 没有迭代器，不能直接遍历
- 举个栗子，服务端提供数据给前端，前端进行数据可视化工作，对数据进行遍历展示使用的 for，但是由于业务的变化，使得后端返回的数据结构发生变化，返回对象或者是 set，map，导致前端遍历代码大量重写，所以需要迭代器来标准化迭代操作

#### 什么是迭代器

- 迭代器是 es6 中新引入的一种遍历机制，就是从一个数据集合中按照一定的顺序，不断取出数据的过程，比如数组的 forEach()、map()、reduce() 等方法的本质就是 Iterator
- 迭代器是一种特殊对象，它具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个 next() 方法，每次调用都返回一个结果对象
  - 结果对象有两个属性：一个是 value，表示下一个将要返回的值；另一个是 done，它是一个布尔类型的值，当没有更多可返回数据时返回 true，否则返回 false
- 迭代器还会保存一个内部指针，用来指向当前集合中值的位置，每调用一次 next() 方法，都会返回下一个可用的值
- 如果在最后一个值返回后再调用 next() 方法，那么返回的对象中属性 done 的值为 true，属性 value 则包含迭代器最终返回的值，这个返回值不是数据集的一部分，它与函数的返回值类似，是函数调用过程中最后一次给调用者传递信息的方法，如果没有相关数据则返回 undefined

#### 具体实现

```
function myIterator(list) {
    let i = 0;
    return {
        next: function() {
            let done = (i &gt;= list.length);
            let value = !done ? list[i++] : undefined;
            return {
                done: done,
                value: value
            };
        }
    };
}
```
