## 1. 手写实现深拷贝

#### 基础版

用递归简单写两下就行了

```
// 被复制的对象
const dataOld = {a: 1, b: {c: 2, d: {e: 3, f: 4}}, g: null, h: [5, 6, 7, 8]}

function deepCopy(data){
  const dataNew = {}
  for(i of Object.keys(data)){
    // 判断是否需要递归下去
    if(typeof i != "object" || i == null){
      dataNew[i] = data[i]
    }
    else{
      dataNew[i] = deepCopy(data[i])
    }
  }
  return dataNew
}
const dataNew = deepCopy(dataOld)
console.log(JSON.stringify(dataOld) == JSON.stringify(dataNew))
```

## 2. 手写实现 sleep

算手写里面，最简单的那批了

1. 用 while 阻碍主线程（感觉是最像 sleep 的，其他都是通过阻碍所在的异步）

```
function mySleep(time){
  // 每次都得new个新的Date，这个只能代表当前时间的对象
  const timeOld = new Date().getTime()
  while(new Date().getTime() - timeOld < time){}
}
mySleep(1000)
console.log("sleep结束")
```

2. 用 setTimeout

```
function mySleep(fn, time){
  setTimeout(fn, time)
}
function fn(){
  console.log("sleep结束")
}
mySleep(fn, 3000)
```

3. 用 promise+setTimeout（加 while 也行，同理）

```
function mySleep(time){
  return new Promise((resolve, reject)=> {
    setTimeout(() => {
      resolve()
    }, time)
  })
}
function fn(){
  console.log("sleep结束")
}
mySleep(3000).then(fn)
```

4. 用 async/await+setTimeout（加 while 也行，同理）
   （await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成，这个大伙应该都知道）

```
async function mySleep(fn, time){
  // 不能直接写await setTimeout(()=>{}, time)，await等的是promise执行完
  await new Promise((resolve) => {
    setTimeout(() => resolve(), time)
  })
  fn();
}
function fn(){
  console.log("sleep结束")
}
mySleep(fn, 3000)
```

## 3. 手写实现 instanceof

简单的很，如果想要更详细一点，可以先判断 b 的类型，例为 undefined 时，会报错
还有就是注意尽量别写内部属性**proto**，用 Reflect.getPrototypeOf()或 Object.getPrototypeOf()代替

```
// 判断A构造函数的原型是否在b的原型链上
function myInstanceof(A, b){
  a = A.prototype
  while(b !== null){
    if(a == b){
      return true
    }
    // 不推荐使用内部属性__proto__，即b = b.__proto__
    // 静态方法Reflect.getPrototypeOf()与Object.getPrototypeOf()方法几乎是一样的。都是返回指定对象的原型
    b = Object.getPrototypeOf(b)
  }
  return false
}
console.log(myInstanceof(Function, {}))
console.log(myInstanceof(Function, () => {}))
```

## ４. 手写实现 promsie

有点长，但是慢慢看不是很难（有问题可以私信告诉我，不保证全对）

1. 这个实现 then 的异步操作思路很简单，就是调用 then 的时候，如果 promise 的状态不确定，就把回调函数放入数组中保存（成功时调用的回调函数和失败时调用的回调函数分开存放），等 promise 的构造函数中修改了 promise 的状态的时候，根据状态变成的是成功或是失败，相应的遍历成功或者失败的回调函数数组，将其按顺序执行一遍就可以了
2. catch 就不多说了，then 的语法糖
3. 静态方法 resolve，挺巧妙的，我们得先判断参数的类别，如果是 Error 或者基本类型，那就没什么好说的，如果是 promise 的话，我们需要得到他的状态和成功或失败的结果，然后修改我们这个新创建的状态与结果。那么我们怎么得到呢，通过实例上的 then，我们把 resolve 和 reject 当成 onResolve 和 onReject 参数传入，如果是成功状态，会自动调用 onResolve（也就是 resolve，修改了新创建的 promise 的状态），如果是失败状态，同理，并且调用的同时，也会传入成功或失败的结果，从而被新创建的 promise 得到
4. 静态方法 reject 就不说了，比上一个简单，毕竟新建的 promise 必然是失败状态
5. 静态方法 all 和 race 也很简单，只要我们注意利用状态只能被修改一次，之后的调用修改状态是无效的（没有操作）就行，然后了解 all 和 race 是干嘛的就行，all 是全对的话，就返回成功的 promise，结果为成功结果的数组集合，只要有一个错误，就返回错误的 promise，结果为那个错误 promise 的错误结果，race 是谁快就是谁的状态和结果

（我感觉我写的不够标准，只能说大概基础的都差不多了，自己看看就行了，也可以看看[别人的](https://juejin.cn/post/7032564107899322381#heading-9)）

```
// 定义promise中的三种状态
const STATUS_PENDING = "pending"
const STATUS_FULFILLED = "fulfilled"
const STATUS_REJECTED = "rejected"

class MyPromise{
    constructor(executor){
        // 初始化状态及成功或失败的结果
        this.status = STATUS_PENDING
        // 成功和失败的结果值
        this.value = null
        this.reason = null
        // 保存回调队列（一个是成功时，需要执行的回调函数，一个是失败时，需要执行的回调函数）
        this.onResCallbacks = []
        this.onErrCallbacks = []

        // 显示绑定
        this.resolve = resolve.bind(this)
        this.reject = reject.bind(this)

        function resolve(value){
            // promise的状态只能从pending变成fulfilled或rejected
            if(this.status === STATUS_PENDING){
                this.status = STATUS_FULFILLED
                this.value = value
                // 把fulfilled对应要执行的累积的函数队列赶紧执行了
                this.onResCallbacks.forEach((fn) => {
                    fn(this.value)
                })
            }
        }

        function reject(reason){
            // promise的状态只能从pending变成fulfilled或rejected
            if(this.status === STATUS_PENDING){
                this.status = STATUS_REJECTED
                this.reason = reason
                // 把rejected对应要执行的累积的函数队列赶紧执行了
                this.onErrCallbacks.forEach((fn) => {
                    fn(this.reason)
                })
            }
        }

        // excutor里的代码是直接运行的，没有异步
        try{
            executor(this.resolve, this.reject)
        }catch(err){
            // 如果在调用executor中的代码时出现错误，则相当于失败
            this.reject(err)
        }
    }

    then(onResolve, onReject){
        // 如果状态是pending，那么我们就把事情拖下去，等到变状态时，会执行对应回调队列中的所有事情
        if(this.status === STATUS_PENDING){
            if(onResolve !== undefined) this.onResCallbacks.push(onResolve)
            if(onReject !== undefined) this.onErrCallbacks.push(onReject)
        }
        // 如果状态是fulfilled，不用拖，状态不会再改变了，拖下去就永远不会执行
        if(this.status === STATUS_FULFILLED && onResolve !== undefined){
            onResolve(this.value)
        }
        // 如果状态是rejected，不用拖，状态不会再改变了，拖下去就永远不会执行
        if(this.status === STATUS_REJECTED && onReject !== undefined){
            onReject(this.reason)
        }
        // 有的人是return new MyPromise，感觉他的更合理一点，不过更复杂
        return this
    }

    catch(onReject){
        // catch不过是then的语法糖罢了，大伙应该都知道
        return this.then(undefined, onReject);
    }

    static resolve(value){
        return new MyPromise((resolve, reject) => {
            if(value instanceof MyPromise){
                // 这个思路是，如果是状态是成功，则then会调用onResolve(也就是resolve)，
                // 并且会传入这个promise（value）身上的value，失败同理，
                // 注意this指向调用者value，也就是这个promise，
                // 再看then方法中这段【onResolve(this.value)】，其中onResolve就是传入的resolve，
                // 但是要注意，调用时，修改的是new出来的新的promsie的状态
                value.then(resolve, reject)
            }else if(value instanceof Error){
                reject(value.message)
            }else{
                resolve(value)
            }
        })
    }

    static reject(reason){
        return new MyPromise((resolve, reject) => {
            if(reason instanceof MyPromise){
                reject(reason.data)
            }else if(reason instanceof Error){
                reject(reason.message)
            }else{
                reject(reason)
            }
        })
    }

    static all(promiseArr){
        return new MyPromise((resolve, reject) => {
            let count = 0
            const values = []
            promiseArr.forEach((promise) => {
                promise.then(
                    value => {
                        count = count + 1
                        values.push(value)
                        // 当全部都成功的时候，转为成功状态
                        if (count === promiseArr.length) resolve(values)
                    },
                    // 只要有一次失败就转为失败状态
                    reason => reject(reason)
                )
            })
        })
    }

    static race(promiseArr){
        return new MyPromise((resolve, reject) => {
            promiseArr.forEach((promise) => {
                 promise.then(
                    // 每一个promise执行完后（不管成功或者失败），都会进入到这里面，
                    // 但是状态与结果只会改变一次，之后都不会再继续改变状态与结果，所以只会保存第一次
                    value => resolve(value),
                    reason => reject(reason)
                )
            })
        })
    }
}
```

## 5. 手写实现防抖节流

#### 实现防抖

```
function debounce(fn, delay) {

  // 闭包，不会被垃圾回收掉
  let t = null;

  // 这个才是 btn 点击时触发的函数，所以他里面 this 为 btn 元素
  // 不能写成箭头函数，不然该函数的 this 为 window
     return function(...args) { // 考虑调用该函数的时候，可能传了参数
         if(t) clearTimeout(t);
         t = setTimeout(() => {
           // 改变 this，该例子里，this 就是 btn 对象
           // 如果没有 apply，直接 fn(...args)，那么 fn 里面的 this 为 window
             fn.apply(this, args);
             t = null;
         }, delay);
     }
}

function fn() {
    console.log(this); // this 应该是 btn 元素
}

let test = debounce(fn, 1000);

let btn = document.getElementById('abc')
btn.onclick = test
```

#### 实现节流

（类似，不细说）

```
function throttle(fn, delay) {
    let flag = false;
    return function(...args) {
        if(flag) return;
        flag = true;
        setTimeout(() => {
            fn.apply(this, args);
            flag = false;
        }, delay);
    }
}
```

## 6. 扁平化数组

#### 递归实现

```
function myFlat(arr) {
  let res = [];
  for(let i = 0; i < arr.length; i++) {
      if(Array.isArray(arr[i])) {
          res = res.concat(myFlat(arr[i])); // 拼接数组，并返回新数组
      }
      else {
          res.push(arr[i]);
      }
  }
  return res;
}

let t = myFlat([1, 2, [3, [4, 5]]]);
console.log(t);
```

除了这种纯递归，还可以通过 ① 递归 + 扩展运算符，② 递归 + reduce

#### 迭代实现

1. 借助栈

   ```
   function myFlat(arr) {
       let res = [];
       let stack = [...arr];
       while(stack.length > 0) {
           let temp = stack.pop();
           if(Array.isArray(temp)) {
               stack.push(...temp);
           }
           else {
               res.push(temp);
           }
       }
       return res.reverse(); // 需要反向一下
   }

   let t = myFlat([1, 2, [3, [4, 5]]]);
   console.log(t);
   ```

2. 借助 apply 或 扩展运算符 皆可
   想一想，为什么用 apply，不用 call
   因为 apply 的性质，第二个参数是数组，会将数组依次作为参数传入，这是不是就是展开了一层，然后一层一层全展开就行
   本质和扩展运算符的思路相同

   ```
   function myFlat(arr) {
       let res = JSON.parse(JSON.stringify(arr));
       while(res.some(item => Array.isArray(item))) {
         // res = [].concat(...res); 因为本质就是扩展运算符，所以通过这个代码也可以实现
           res = Array.prototype.concat.apply([], res);
       }
       return res;
   }

   let t = myFlat([1, 2, [3, [4, 5]]]);
   console.log(t);
   ```

#### es6 新 api：arr.flat(dep)

dep 为展开数组的维数（整数），如果要全部展开，可传入 Infinity （ 全局属性 Infinity 是一个数值，表示无穷大 ）

```
function myFlat(arr) {
    return arr.flat(Infinity);
}

let t = myFlat([1, 2, [3, [4, 5]]]);
console.log(t);
```

#### toString + split 实现

toString 可直接去除掉中括号

```
function myFlat(arr) {
    // console.log(arr.toString()); 为 "1,2,3,4,5" 中间的括号全被去掉了
    return arr.toString().split(',').map(item => {
        return Number(item);
    });
}

let t = myFlat([1, 2, [3, [4, 5]]]);
console.log(t);
```

## 7. 手写实现 call，apply，bind

#### 实现 call

```
Function.prototype.myCall = function (context, ...args) {
    // 这里默认不传，或者传 null 就是给 window，也可以用 es6 给参数设置默认参数
    context = context || window
    args = args ? args : []
    // 给 context 新增一个独一无二的属性以免覆盖原有属性
    const key = Symbol()
    context[key] = this
    // 通过隐式绑定的方式调用函数
    const result = context[key](...args)
    // 删除添加的属性
    delete context[key]
    // 返回函数调用的返回值
    return result
}
```

#### 实现 apply

```
Function.prototype.myApply = function (context, args) {
    // 这里默认不传就是给 window，也可以用 es6 给参数设置默认参数
    context = context || window
    args = args ? args : []
    // 给 context 新增一个独一无二的属性以免覆盖原有属性
    const key = Symbol()
    context[key] = this
    // 通过隐式绑定的方式调用函数
    const result = context[key](...args)
    // 删除添加的属性
    delete context[key]
    // 返回函数调用的返回值
    return result
}
```

#### 实现 bind

```
Function.prototype.myBind = function (context, ...args) {
    const fn = this
    args = args ? args : []
    return function newFn(...newFnArgs) {
        return fn.apply(context, [...args,...newFnArgs])
    }
}
```
