## 1. 前端测试

- 单元测试（Unit Testing）：单元测试关注于测试代码中的最小可测试单元，通常是单个函数或方法。例如，测试一个字符串反转函数，确保在给定特定输入时返回预期的输出。 常用的前端单元测试框架有：
  - Jest
  - Mocha
  - Jasmine
  - QUnit
  - Ava
- 集成测试（Integration Testing）：集成测试主要关注于测试不同模块之间的交互，确保它们能够协同工作。例如，测试一个 React 应用程序中的父子组件之间的数据传递是否正确。 常用的前端集成测试框架有：
  - Jest
  - Mocha
  - Cypress
  - TestCafe
- 端到端测试（End-to-End Testing）：端到端测试涉及模拟用户与应用程序的实际交互，以验证整个系统是否按照预期工作。例如，测试一个电商网站的购物车功能，确保用户可以将商品添加到购物车并完成结算。 常用的前端端到端测试框架有：
  - Cypress
  - Protractor
  - Selenium WebDriver
  - Puppeteer
  - Playwright
- 性能测试（Performance Testing）：性能测试关注于评估前端应用程序的性能，例如加载速度、响应时间、资源消耗等。例如，测试一个网站的首页在不同网络条件下的加载速度。 常用的前端性能测试工具有：
  - Lighthouse
  - WebPageTest
  - YSlow
  - Sitespeed.io
- 可访问性测试（Accessibility Testing）：可访问性测试关注于确保前端应用程序对残障人士易于使用，遵循相关的可访问性标准和指南（如 WCAG）。例如，测试一个网站的所有图片是否都有 alt 属性。 常用的前端可访问性测试工具有：
  - axe-core
  - WAVE
  - Pa11y
  - Tenon.io
- 可用性测试（Usability Testing）：可用性测试关注于应用程序的用户体验，以确保应用程序易于使用、符合用户预期。例如，邀请一组用户在受控环境中使用应用程序，并收集他们的反馈。 可用性测试通常需要人工评估和用户反馈，一些辅助工具包括：
  - UserTesting
  - Optimal Workshop
  - Hotjar
- 跨浏览器测试（Cross-Browser Testing）：跨浏览器测试关注于确保前端应用程序在不同的浏览器和设备上正常运行。例如，测试一个网站在 Chrome、Firefox 和 Safari 浏览器上的显示效果和功能。 常用的前端跨浏览器测试工具有：
  - BrowserStack
  - Sauce Labs
  - LambdaTest
  - CrossBrowserTesting
- 很多测试工具，例 Jasmine，Jest 和 Karma，都可以用于持续集成（CI），可以与持续集成（CI）工具（如 Jenkins、Travis CI、CircleCI、GitHub Actions 等）集成，以自动执行测试并报告测试结果，只需要在 CI 配置文件中添加相应的命令来运行，就可以与持续集成（CI）工具集成，比如当向代码仓库提交代码更改时，CI 工具会自动运行 Jasmine，Jest 或 Karma 测试。如果测试失败，CI 流程将被中断，即可以查看测试结果来定位问题并修复错误。这有助于确保代码质量，并在新功能交付和错误修复过程中保持代码可靠性

## 2. Jasmine

#### 基础介绍

- 是一个 JavaScript 测试框架，用于对 JavaScript 代码进行单元测试和集成测试。Jasmine 受到行为驱动开发（BDD，Behavior-Driven Development）的启发，因此它的语法更注重描述代码的行为，而不是检查特定的实现细节
- 特点
  - 独立性：Jasmine 独立于任何浏览器、平台和其他技术，可以在任何 JavaScript 项目中使用
  - 简洁的语法：Jasmine 提供了一种描述性的语法，使测试用例易于编写和理解。它使用 describe 和 it 关键字组织测试用例，expect 和 toMatch 这样的匹配器（matcher）来验证结果
  - 内置匹配器：Jasmine 提供了许多内置的匹配器，用于检查变量的值、类型等。例如：toEqual, toBeTruthy, toContain 等
  - 支持自定义匹配器：如果内置的匹配器不能满足需求，可以自定义匹配器
  - 支持异步测试：Jasmine 支持对异步代码（如 Promise 和 async/await）进行测试
  - Spy 功能：Jasmine 提供了 Spy 功能，用于监视函数的调用情况，如被调用的次数、调用时的参数等。这在测试回调函数和事件处理程序时非常有用
  - 与其他工具集成：Jasmine 可以与其他测试工具（如 Karma、Protractor 等）和持续集成系统（如 Jenkins、Travis CI 等）集成，实现自动化测试

#### 主要语法

- describe：是一个全局函数，用于定义一个测试套件（test suite）。它接受两个参数：一个字符串（用于描述测试套件的目的或要测试的组件名称）和一个函数（包含要运行的测试用例，无参数和返回值）
  ```
  // 定义一个名为 "Array" 的测试套件
  describe('Array', function() {
    const a = 1;
    describe('test1()', function() {
       // 在这里编写测试用例
       const b = a + 1;
     }
     describe('test2()', function() {
       // 在这里编写测试用例
       const b = a + 2;
     }
  });
  ```
  - describe 里可以继续包裹 describe，主要作用是因为代码都是在参数函数中，有着自己的作用域，可以通过在 describe 中创建不同的 describe 来得到不同的变量作用域，并且都可以使用 父 describe 中的变量
- it：是一个全局函数，用于定义单个测试用例（test case/spec），它接受两个参数：
  - 描述字符串，用于描述测试用例的目的或预期行为
  - 测试函数，包含实际测试代码，可以编写测试断言来验证代码的执行结果是否符合预期
    - 参数：测试函数可以接收一个名为 done 的可选参数。当测试异步操作时，可以使用这个 done 参数。done 是一个函数，需要在异步操作完成后调用它，以通知 Jasmine 结束测试用例，一旦调用了 done()，Jasmine 就会认为当前测试用例已经完成，并不会继续执行测试用例中 done() 之后的代码，接下来 Jasmine 会继续执行下一个测试用例。如果不需要测试异步操作，那么测试函数不需要接收任何参数
    - 返回值：对于同步测试用例，测试函数通常不需要返回任何值。然而，当需要测试返回 Promise 的异步操作时，需要在测试函数中返回这个 Promise 对象。这样，Jasmine 就会等待 Promise 对象解析（resolve）或拒绝（reject），并在适当的时机执行测试断言
  ```
  describe('test()', function() {
    it('should return -1 when the value is not present', function() {
      // 在这里编写实际的测试代码
    });
  });
  ```
- expect：是一个全局函数，用于定义一个期望（expectation）。它接受一个参数：要测试的实际值。期望与匹配器（matcher）结合使用，以验证实际值是否符合预期
  ```
  expect([1, 2, 3].indexOf(4));
  ```
- 匹配器（Matchers）：匹配器是 Jasmine 提供的一组内置函数，用于验证实际值是否符合预期，提供了一系列强大的断言功能。这些函数包括：toEqual、toBe、toContain、toBeTruthy 等。匹配器通常与 expect 函数一起使用

  - toEqual：检查实际值是否等于预期值。对于基本类型（如数字、字符串、布尔值等），它会检查值的相等性；对于对象和数组，它会检查它们的结构和内容是否相等
    ```
    expect([1, 2, 3]).toEqual([1, 2, 3]); // 会对比内容
    ```
  - toBe：检查实际值是否严格等于预期值（即 ===）。这意味着对于对象和数组，它们必须引用相同的内存地址才会被视为相等
    ```
    const myObj = { a: 1, b: 2 };
    expect(myObj).toBe(myObj); // 相同引用
    ```
  - toBeGreaterThan，toBeGreaterThanOrEqual，toBeLessThan，toBeLessThanOrEqual：将实际值和目标值比较
    ```
    expect(5).toBeGreaterThan(4); // 检查值是否大于给定的值
    expect(5).toBeGreaterThanOrEqual(5); // 检查值是否大于或等于给定的值
    expect(3).toBeLessThan(4); // 检查值是否小于给定的值
    expect(3).toBeLessThanOrEqual(3); // 检查值是否小于或等于给定的值
    ```
  - toContain：检查实际值（数组或字符串）是否包含预期值。对于数组，它会检查是否至少有一个元素等于预期值；对于字符串，它会检查是否包含预期子字符串
    ```
    expect([1, 2, 3]).toContain(2);
    expect('hello world').toContain('world');
    ```
  - toBeTruthy：检查实际值是否为真值（即在布尔上下文中为 true 的值）。例如：非空字符串、非零数字、非空对象等
    ```
    expect('hello').toBeTruthy();
    ```
  - toBeFalsy：检查实际值是否为假值（即在布尔上下文中为 false 的值）。例如：null、undefined、空字符串、数字 0 等
    ```
    expect(null).toBeFalsy();
    ```
  - toMatch：检查字符串是否匹配给定的正则表达式
    ```
    const str = 'Hello, Jasmine!';
    expect(str).toMatch(/Jasmine/);
    ```
  - toThrow：检查函数是否抛出给定的错误
    ```
    const badFunction = () => {
      throw new Error('Something went wrong');
    };
    expect(badFunction).toThrow('Something went wrong');
    ```

- beforeEach/afterEach：都是全局函数，分别在测试套件中的每个测试用例之前和之后执行。它们常用于设置和清理测试用例所需的资源，例如初始化变量、创建对象、清理 DOM 元素等
  ```
  describe('test()', function() {
    let myArray;
    beforeEach(function() {
      myArray = [1, 2, 3];
    });
    afterEach(function() {
      myArray = [];
    });
    it('should return -1 when the value is not present', function() {
      expect(myArray.indexOf(4)).toEqual(-1);
    });
  });
  ```
- beforeAll/afterAll：都是全局函数，分别在整个测试套件的开始和结束时执行一次。它们常用于执行一次性的设置和清理操作，例如创建和关闭数据库连接、启动和停止服务器等
  ```
  describe('Database', function() {
    beforeAll(function() {
      // 连接数据库
    });
    afterAll(function() {
      // 关闭数据库连接
    });
    // 编写测试用例
  });
  ```
- Jasmine spy（间谍）：是 Jasmine 测试框架提供的一个功能，它可以替换一个对象的方法，用于监视函数的调用情况，例如被调用的次数、调用时的参数等，这在测试回调函数和事件处理程序时非常有用。通过创建 Jasmine spy，您可以轻松地为函数创建模拟实现（mock implementation），以便在测试过程中替换实际的函数实现

  - 创建 spy：

    - jasmine.createSpy：创建一个新的 spy。您可以为 spy 提供一个可选的名称，以便在测试报告中更容易识别
      ```
      const mySpy = jasmine.createSpy('mySpy');
      ```
    - spyOn：替换现有函数，将现有对象的方法替换为一个 spy。这样，在调用该方法时，您将实际调用 spy，而不是原始实现

      ```
      const myObj = {
        myMethod: function() {
          // 原始实现
        },
      };

      spyOn(myObj, 'myMethod');
      ```

  - 配置 spy 行为：Jasmine 提供了一组 API，用于配置 spy 的行为，例如调用原始实现、返回特定值、抛出错误等。以下是一些常用的 API：
    - and.callThrough()：在调用 spy 时执行原始实现
    - and.returnValue(value)：在调用 spy 时返回指定的值
    - and.callFake(function)：在调用 spy 时执行指定的函数
    - and.throwError(error)：在调用 spy 时抛出指定的错误
    ```
    spyOn(myObj, 'myMethod').and.callThrough();
    spyOn(myObj, 'myMethod').and.returnValue(42);
    spyOn(myObj, 'myMethod').and.callFake(function() { return 42; });
    spyOn(myObj, 'myMethod').and.throwError(new Error('Something went wrong'));
    ```
  - 检查 spy 调用情况：Jasmine 提供了一组匹配器（matcher），用于检查 spy 的调用情况。以下是一些常用的匹配器：

    - toHaveBeenCalled()：检查 spy 是否被调用过
    - toHaveBeenCalledTimes(count)：检查 spy 是否被调用了指定次数
    - toHaveBeenCalledWith(args)：检查 spy 是否被调用，并传递了指定的参数

    ```
    const mySpy = jasmine.createSpy('mySpy');
    mySpy(42);

    expect(mySpy).toHaveBeenCalled();
    expect(mySpy).toHaveBeenCalledTimes(1);
    expect(mySpy).toHaveBeenCalledWith(42);
    ```

- fail() 函数是一个用于主动失败测试的特殊函数。调用 fail() 函数会导致当前正在运行的测试立即失败，并生成一个指定的错误消息，例
  ```clike
  // 如果不符合预期，就主动让测试失败
  if (num <= 0) {
    fail("The number is not positive"); // 显示失败信息
  }
  ```

#### 举例

- 回调相关（callback）

  ```
  function fetchData(callback) {
    setTimeout(() => {
      callback('Hello, world!');
    }, 1000);
  }

  it('should fetch data with callback', function(done) {
    function callback(data) {
      expect(data).toEqual('Hello, world!');
      done(); // 异步操作完成，通知 Jasmine 结束测试用例
    }
    fetchData(callback); // fetchData 是一个异步操作，接收一个回调函数
  });
  ```

- 回调相关（Promise 和 async/await）

  ```
  function fetchData() {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('Hello, world!');
      }, 1000);
    });
  }

  // Promise 版
  it('should fetch data with promises', function() {
    return fetchData().then(data => {
      expect(data).toEqual('Hello, world!');
    });
  });

  // async/await 版
  it('should fetch data with async/await', async function() {
    const data = await fetchData(); // fetchData 是一个返回 Promise 的异步操作
    expect(data).toEqual('Hello, world!');
  });
  ```

- Jasmine spy 相关

  ```
  // 定义一个名为 "Callback" 的测试套件
  describe('Callback', function() {
    // 声明两个变量，分别用于存储测试对象和回调函数
    let myObj, callback;

    // 使用 beforeEach 在每个测试用例执行前设置测试环境
    beforeEach(function() {
      // 定义一个对象 myObj，它包含一个名为 doSomething 的方法
      // 该方法接受一个数字值和一个回调函数作为参数
      // 然后将该数字值乘以 2，并将结果传递给回调函数
      myObj = {
        doSomething: function(value, cb) {
          cb(value * 2);
        },
      };

      // 使用 jasmine.createSpy 创建一个名为 "callback" 的 Jasmine spy
      // spy 是一个用于监视函数调用的特殊对象
      callback = jasmine.createSpy('callback');

      // 使用 spyOn 函数将 myObj 的 doSomething 方法替换为一个 spy
      // 使用 and.callThrough() 使 spy 在被调用时仍然执行原始方法
      spyOn(myObj, 'doSomething').and.callThrough();

      // 调用 myObj 的 doSomething 方法，传递值 2 和我们创建的 callback spy
      myObj.doSomething(2, callback);
    });

    // 定义一个测试用例，检查回调函数是否被正确调用
    it('should call the callback with doubled value', function() {
      // 检查 myObj.doSomething 方法是否被调用
      expect(myObj.doSomething).toHaveBeenCalled();

      // 检查回调函数是否被调用，并传入了期望的值（输入值的两倍，即 4）
      expect(callback).toHaveBeenCalledWith(4);
    });
  });
  ```

#### 使用细节

- 一般 describe 的描述符号是一个函数，标识这个测试套件是为了测试某个函数
- 如果多个需要测试的函数之间关系很紧密，比如都在一个 对象 身上，可以在外面包一层 describe，然后在外层的 describe 中去实例化 class，然后再在内层 describe 中去测试实例化对象身上的函数
- it 其实就是对某个函数进行多方面测试，描述符描述测试的内容即可，比如 "should return -1 when the value is not present"
- 如果测试有问题的时候，报错信息有
  1.  将所有描述符（ 比如 describe，和 it ）拼接起来，可以通过这个来定位错误位置
  2.  具体错误信息，比如预期是 xxx，实际是 yyy
  3.  错误位置，比如某个文件某一行

## 3. Jest

#### 基础介绍

- Jest 最初是基于 Jasmine 开发的，因此 Jest 和 Jasmine 在语法和功能上有很多相似之处。然而，随着时间的推移，Jest 已经发展成为一个独立的、功能更为强大的测试框架，并在许多方面超越了 Jasmine
- Jest 在以下几个方面对 Jasmine 进行了改进和扩展：
  - 快照测试：Jest 提供了内置的快照测试功能，允许开发者捕获组件或数据结构的当前状态，并在后续测试中与之进行比较。Jasmine 则需要使用第三方插件（如 Jasmine-Snapshot）来实现快照测试
  - 强大的模拟（Mocking）功能：Jest 提供了丰富的模拟功能，包括模块模拟、自定义实现模拟、定时器模拟等。虽然 Jasmine 也提供了一些基本的模拟功能（Jasmine spy），但通常需要与其他库（如 Sinon）配合使用以实现更高级的功能
  - 并行测试：Jest 支持并行运行测试用例，以提高测试速度。Jasmine 默认并不支持并行测试，但可以通过配置 Karma 或其他工具来实现
  - 更简单的配置：Jest 提供了开箱即用的配置，很多功能不需要额外的设置。而 Jasmine 通常需要搭配其他工具（如 Karma、Chai 和 Sinon）来实现完整的测试功能，例：
    - 覆盖率报告：覆盖率报告功能是用来度量测试用例覆盖了多少源代码的指标，代码覆盖率是衡量测试质量的一个重要指标，它可以帮助了解哪些代码已经被测试，哪些代码尚未被测试。
      - Jasmine 本身没有内置的覆盖率报告功能，需通过集成例 Istanbul 这样的工具才能生成覆盖率报告
      - 而在 Jest 中启用覆盖率报告功能，只需使用 --coverage 命令行参数，或在配置文件中添加相应的选项
    - 自动化测试：在监视模式下运行，自动执行更改后的测试
      - Jasmine 本身没有内置的覆盖率报告功能，需借助例 jasmine-auto-runner 这样的插件
      - 而在 Jest 中启用覆盖率报告功能，只需使用 --watch 命令行参数，或在配置文件中添加相应的选项
  - 社区支持：Jest 在 JavaScript 社区中受到广泛的支持，特别是在 React 和 Node.js 生态中，更新和改进较为频繁
- 但是相比于 Jasmine，Jest 相对较新，尽管在社区中已经受到广泛的支持，但在某些旧的项目或技术栈中可能会遇到兼容性问题

#### 主要语法

- 和 Jasmine 一样，有 describe，it（Jest 中也可以叫 test），expect，beforeEach 和 afterEach，beforeAll 和 afterAll
- 匹配器（Matchers）和 Jasmine 也几乎一致，Jasmine 有的都有，除此之外还有：
  - toHaveLength：检查数组或字符串的长度是否等于给定的值
    ```
    const arr = [1, 2, 3];
    expect(arr).toHaveLength(3);
    ```
  - toHaveProperty：检查对象是否具有给定的属性和值
    ```
    const obj = { a: 1, b: 2 };
    expect(obj).toHaveProperty('a', 1);
    ```
  - toMatchObject：检查对象是否匹配给定的部分对象
    ```
    const obj = { a: 1, b: 2, c: 3 };
    expect(obj).toMatchObject({ a: 1, b: 2 });
    ```
- Jest 也具有类似于 Jasmine 中的 spy 功能，在 Jest 中，这些功能是通过 mock（模拟）的概念来实现的

  - 创建模拟：
    - jest.fn：用于创建独立的模拟函数。它可以接受一个可选的自定义实现函数作为参数。通常用于创建简单的模拟函数，以便在测试中手动替换其他函数或传递给需要测试的组件
      ```
      const mockFn = jest.fn();
      const mockAdd = jest.fn((a, b) => a + b);
      ```
    - jest.spyOn：主要用于创建对象方法的模拟，并将其替换为原始方法。它接受两个参数：一个是对象，另一个是对象上的方法名。适用于模拟和替换单个对象的方法，它可以用于测试对象方法的调用和行为，同时在需要的情况下还可以调用原始方法
      ```
      const myObj = {
        myMethod: () => 'original result',
      };
      // 创建模拟方法并替换原始方法
      const mockMethod = jest.spyOn(myObj, 'myMethod');
      ```
    - jest.mock：主要用于模拟整个模块。它接受一个模块路径作为参数，并可选地接受一个工厂函数作为第二个参数。工厂函数用于创建模拟模块的导出对象。适用于模拟整个模块，它会完全替换模块的实现，整个模块都将被替换为模拟对象。这在需要模拟复杂依赖关系或隔离模块的测试时非常有用
      ```
      // 创建模拟模块
      jest.mock('./path/to/module', () => ({
        functionName: jest.fn(() => 'mocked result'),
      }));
      // 导入模拟模块
      const mockedModule = require('./path/to/module');
      ```
    - 还有一些不太常用的 jest.doMock，jest.requireActual，jest.createMockFromModule 方法
  - 配置模拟行为：Jasmine 提供了一组 API，用于配置 spy 的行为，例如调用原始实现、返回特定值、抛出错误等。以下是一些常用的 API：（Once 即只指定下一次调用，以后的调用仍使用默认）

    - mockFn.mockReturnValue 和 mockReturnValueOnce：在调用 spy 时返回指定的值
      ```
      const mockFn = jest.fn();
      mockFn.mockReturnValue('mocked value');
      const result = mockFn();
      expect(result).toBe('mocked value');
      ```
      ```
      const mockFn = jest.fn();
      mockFn
        .mockReturnValueOnce('first call')
        .mockReturnValueOnce('second call');
      const result1 = mockFn();
      const result2 = mockFn();
      const result3 = mockFn();
      expect(result1).toBe('first call'); // 第一次调用返回 'first call'
      expect(result2).toBe('second call'); // 第二次调用返回 'second call'
      expect(result3).toBeUndefined(); // 第三次调用没有指定返回值，返回 undefined
      ```
    - mockFn.mockImplementation 和 mockFn.mockImplementationOnce：**为模拟函数提供自定义实现，非常非常灵活**

      ```
      // 实现类似 and.callThrough() 功能，在调用时执行原始实现
      // 使用 jest.spyOn() 模拟 Math.random
      const randomSpy = jest.spyOn(Math, 'random');

      // 使用 mockImplementation 调用原生实现
      randomSpy.mockImplementation(function() {
        return this.apply();
      });
      ```

      ```
      // 实现类似 and.throwError(error) 功能，在调用时抛出指定的错误
      // 使用 jest.fn() 创建模拟函数
      const mockFetchData = jest.fn();

      // 使用 mockImplementation 让模拟函数抛出错误
      mockFetchData.mockImplementation(() => {
        throw new Error('Fetch error');
      });
      ```

      ```
      // 举例 mockFn.mockImplementationOnce 功能
      const mockFn = jest.fn();

      mockFn
        .mockImplementationOnce((a, b) => a * b)
        .mockImplementationOnce((a, b) => a / b);

      const result1 = mockFn(2, 3);
      const result2 = mockFn(6, 3);
      const result3 = mockFn(3, 2);

      expect(result1).toBe(6); // 第一次调用使用乘法实现
      expect(result2).toBe(2); // 第二次调用使用除法实现
      expect(result3).toBeUndefined(); // 第三次调用没有实现，返回 undefined
      ```

  - 检查 mock 调用情况：Jest 提供了一组匹配器（matcher），用于检查 mock 的调用情况。以下是一些常用的匹配器：
    - mockFn.mock.calls：是一个数组，包含了模拟函数的所有调用记录。每个记录都是一个数组，表示传递给该函数的参数列表。可以使用 mock.calls.length 获取调用次数，或者通过索引访问特定调用的参数
    - mockFn.mock.results：是一个数组，包含了模拟函数的所有返回值和抛出的异常。每个记录都是一个对象，具有 type（'return' 或 'throw'）和 value（返回值或抛出的异常）属性。可以通过索引访问特定调用的结果
    - mockFn.mock.instances：是一个数组，包含了模拟构造函数的所有实例。可以通过索引访问特定实例
    - expect(mockFn).toHaveBeenCalled()：使用 toHaveBeenCalled 断言检查模拟函数是否被调用
    - expect(mockFn).toHaveBeenCalledTimes(count)：使用 toHaveBeenCalledTimes 断言检查模拟函数被调用的次数
    - expect(mockFn).toHaveBeenCalledWith(arg1, arg2, ...)：使用 toHaveBeenCalledWith 断言检查模拟函数是否被调用，并传递了特定的参数
    - expect(mockFn).toHaveBeenLastCalledWith(arg1, arg2, ...)：使用 toHaveBeenLastCalledWith 断言检查模拟函数最后一次调用时是否传递了特定的参数
    - expect(mockFn).toHaveBeenNthCalledWith(nthCall, arg1, arg2, ...)：使用 toHaveBeenNthCalledWith 断言检查模拟函数在第 nthCall 次调用时是否传递了特定的参数

- 还有一些特殊特性
  - 定时器模拟：允许控制和测试与 setTimeout、setInterval 和 clearTimeout 等函数相关的行为。一些常用的定时器模拟方法包括：
    - jest.useFakeTimers()：使用模拟定时器替换原生定时器
    - jest.runAllTimers()：立即执行所有挂起的定时器回调
    - jest.runOnlyPendingTimers()：仅执行当前挂起的定时器回调
    - jest.advanceTimersByTime(msToRun)：将模拟定时器向前推进指定的毫秒数
    - jest.useRealTimers()：恢复使用原生定时器
  - 快照测试：允许轻松地捕获和比较对象、组件或数据结构的不同状态。快照测试有助于确保在更改代码时，不会意外地破坏现有行为。常用的快照匹配器方法是 toMatchSnapshot()，它会将测试值与存储的快照进行比较
  - 并行测试：Jest 默认支持并行测试，可以自动地将测试用例分发到多个 worker 进程中，以提高测试执行速度
  - 自定义匹配器：除了内置匹配器之外，Jest 还允许您编写自定义匹配器，以扩展断言功能。创建自定义匹配器需要实现一个具有特定签名的函数，并将其添加到 expect.extend() 中

## 4. Karma

#### 基础介绍

- Jest 和 Karma 类似都是用于前端测试用例
  - 但 Jest 是测试框架，功能较为完善，旨在为开发人员提供一个简单、快速且灵活的测试解决方案，它默认不使用真实的浏览器环境来运行测试，而是使用 JSDOM（一个 JavaScript 实现的 DOM 模拟器），需借助 jest-puppeteer 配置使用真实的浏览器环境
  - 而 Karma 本身没有特定的测试语法，因为它是一个测试运行器，而不是测试框架，类似于在测试框架外面封装了一层。它的主要目的是支持在多种浏览器（包括 Chrome、Firefox、Safari、IE 等）中运行测试用例，这有助于确保您的代码在不同的浏览器和平台上具有一致的行为和兼容性，为了实现这一目标，Karma 可以与多种测试框架（如 Jasmine、Mocha 等）集成

#### 基础使用（集成 Jasmine）

1. 安装依赖：安装 Karma 及相关依赖，使用 npm 安装 karma、karma-jasmine、karma-chrome-launcher 和 jasmine-core
   ```
   npm install --save-dev karma karma-jasmine karma-chrome-launcher jasmine-core
   ```
2. 安装 Karma CLI：为了方便使用 Karma 命令行工具，全局安装 karma-cli
   ```
   npm install -g karma-cli
   ```
3. 初始化 Karma 配置：运行 karma init 命令，根据提示选择测试框架（如 Jasmine）、浏览器（如 Chrome）等。这将在项目根目录下生成一个 karma.conf.js 文件，其中包含 Karma 的配置信息
   ```
   karma init
   ```
4. 编写测试：使用 Jasmine 语法编写测试用例，例如，创建一个名为 sum.spec.js 的文件，其中包含以下内容

   ```
   function sum(a, b) {
     return a + b;
   }

   describe('sum', () => {
     it('should return the sum of two numbers', () => {
       expect(sum(1, 2)).toBe(3);
     });
   });
   ```

5. 修改 Karma 配置：在 karma.conf.js 文件中，修改 files 配置以包含刚刚编写的测试文件
   ```
   files: ['sum.spec.js'],
   ```
6. 运行测试：使用 karma start 命令运行测试，Karma 会启动浏览器并执行测试用例
   ```
   karma start
   ```

#### 存在缺陷

- 当使用 Karma 进行测试时，它通常会在**本地安装的浏览器上运行测试**。这意味着，如果要在多个浏览器和版本上测试，需要在本地环境中安装和配置这些浏览器。而且，对于某些操作系统和浏览器的组合，可能很难在本地环境中设置
- 所以可以配合云测试平台，例 BrowserStack。当将 Karma 与 BrowserStack 集成时，可以利用 BrowserStack 的云测试平台在多种不同的设备、操作系统和浏览器上运行测试，而无需在本地安装这些环境。这意味着，即使本地没有安装某个特定的浏览器环境，仍然可以通过 BrowserStack 在那些环境上进行测试

## 5. 测试小技巧

- 有时候测试用例报错太多，导致上方的报错内容被挤掉，可以通过一下子方法避免
  - 在运行命令时，可以使用重定向符号 > 或 >> 将错误输出重定向到一个文件中，而不是在命令行中显示
    ```
    xxx > error.log
    ```
  - 通过将输出通过分页工具进行分页，可以逐页查看命令行输出，防止信息被挤掉，在 Linux 和 macOS 上，你可以使用
    ```
    xxx | less
    ```
