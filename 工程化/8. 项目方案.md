## 3. 前端国际化

- 国际化（internationalization），简称 i18n（其来源是英文单词 internationalization 的首末字符 i 和 n，18 为中间的字符数），即希望编写的程序可以让全世界的用户使用，它要求从产品中抽离所有地域语言，国家/地区和文化相关的元素

#### 常见实现方案

1. 使用插件在线翻译：机器翻译难免存在误差，但是省事
2. 维护多套页面 / 语言代码：太麻烦
3. 语言包配置：例创建 i18n 目录，在其下创建各个目录代表各个语言包，在各个语言包目录中创建多个 json 文件，其中记录各个 xx 键对应的 yy 值，之后在代码中，用 xx 来代替 yy 字符串直接表示，切换不同语言时，加载不同的语言包即可
4. 各个框架也有插件来方便语言配置，例如 jQuery.i18n.properties，vue-i18n，react-i18next

## 4. 应对系统故障情况

#### 兜底 和 容灾

- 兜底 和 容灾，都是应对系统故障的应急措施，但是在实施方式和目的上存在一定的区别
  - 实施方式上 ，兜底 主要是前端进行操作，容灾 主要是后端进行操作
  - 目的上，兜底 主要是为了系统故障的情况下，进行提示或预先处理，让用户能够最大限度的使用系统，保证用户的体验感，容灾 主要是为了系统故障的情况下，保障系统的业务稳定性和可用性以及数据的可靠性，减少故障带来的影响
- 兜底通常包括以下几个方面：
  - 错误信息提示：在页面上显示错误信息或者对话框，告知用户出现了异常情况，并给出相应的解决方案
  - 默认数据填充：对于数据异常或者接口异常的情况，显示一些默认或者备选的数据，使得用户能够继续使用系统
  - 异常处理：对可能出现的问题进行捕获，并进行相应的处理，避免页面大范围报错
- 容灾通常包括以下几个方面：
  - 缓存策略：备份措施，用于备份关键数据和资源。当系统发生故障或者灾害时，可以通过缓存中备份的数据和资源来恢复系统的正常运行
  - 负载均衡：通过对服务器的资源进行分配和调度，使得系统能够在大量用户同时访问时保持稳定
  - 降级处理：将系统某些功能暂时关闭或部分降级，使得系统在异常情况下能够继续提供部分服务，而不至于彻底崩溃
  - 快速回滚：当系统出现严重故障时，快速回滚到稳定版本，保证用户可以访问到正常的页面和功能
  - 故障转移：在系统中主要的一台或几台服务器无法正常工作时，将对其负责的业务流量自动或手动地切换到另外一组备用的服务器上，保障业务不中断、不丢失，系统可用性得以保持

#### 兜底 常见的方案有（ 容灾 就不说了，一般后端来搞）

数据异常兜底，图片兜底，字体兜底，请求兜底，业务逻辑兜底 等等

1. 图片兜底方案：
   1. 通过 img 标签的 alt 属性：例 \<img src="xxx" alt="xxx"\>，但是这样用户体验非常差，太丑了
   2. 通过 onerror 事件：如果在加载外部文件（例如文档或图像）时发生错误，则会触发 onerror 事件，例\<img src="xxx" alt="xxx" onerror="this.src='xxx'"\>，在加载错误的时候，触发代码，从而加载另一个兜底的图片（一般是告诉用户加载错误的图片），但是可能因为网络，另一个图片也无法加载出来，所以可以进行计数，当多次加载均失败时，用 base64 图片兜底，可以通过 img[src="xxx"] {...} 来设置 css 样式，并且可以通过 ::before 和 ::after 来设置文字来提示用户
   3. 如果觉得上一种，直接在 img 标签上添加，可能会遗忘部分 img，并且代码侵入性过高，可以为所有 img 标签统一添加 error 处理事件，例
      ```
      const imgs = document.getElementsByTagName('img')
      Array.prototype.forEach.call(imgs, img => {
          img.addEventListener('error', e => {
              e.target.src = 'default.png'
          })
      })
      ```
2. 字体兜底方案：
   一般我们都采用 font-family 设置字体样式，可以列举一个或多个由逗号隔开的字体族，通常在列表的末尾至少有一个通用字体族名进行兜底
   注：当子元素设置 font-family，且其字体样式全都无法加载时，并不会再加载父元素的 font-family，而是会是无字体的默认样式，所以最好每个设置了字体的元素都设置一个或多个兜底字体
   （字体族即例 "Times" 和 "Helvetica" 都是字体族名，通用字体族名是一种备选机制，用于在指定的字体不可用时给出较好的字体。通用字体族名都是关键字，所以不可以加引号，例 serif 即带衬线字体，笔画结尾有特殊的装饰线或衬线，通用字体族中包含多种字体族）
3. 请求兜底方案：
   前端向后台请求数据时，为保证服务的可用性，以及防止服务雪崩，一般都会做熔断降级，会有一个兜底的方法，看具体情况，这些方法有时会直接返回友好提示，有时也会返回一些默认的值，这时候如果系统有引入缓存模块，就可能会把这兜底返回的默认值给缓存了，那之后哪怕远程调用的服务恢复了正常，但只要缓存没过期，用户就会一直访问到兜底值，这业务逻辑肯定是错的，所以需要作出相应的标识和判断，保证兜底的数据不会被缓存
   【服务熔断：类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用】
   【服务降级：服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性】

## 5. 对于前端，to B 和 to C 的区别

- B 端：即面向企业或者特定用户群体的企业级别产品
  - to B 的团队，用户稳增，但是系统逻辑通常较重，所以对 js 要求较高，团队的人大部分时间都是在写 js 逻辑，会涉及前端架构，可以尝试各种 MVVM 框架，了解各种设计模式等。从产品的展现上要求可能没有 C 端严格，基本不会写 css，html ，一般都是现成模板。产品主导而不是运营主导，需求都需要经过团队价值树的考验才能开始开发，而不是说干就干，团队有时间沉淀一些技术方面的积累
  - 从前端页面开发角度看，80%+ 的 B 端业务可以归结为数据查询、数据展示、数据录入三大业务类型，其中涉及到了四大组件：筛选器（查询）、表格（展示）、图表（展示）、表单（录入），四大组件涵盖了 80% 的前端代码量。能不能封装出功能强大、接口简单的大组件，直接影响前端日常开发效率和质量
- C 端：即面向普通大众消费者的产品
  - to C 的团队，用户量增长会很快，然后运营活动会偏多，页面改版频繁，做活动，或者是做各种促销模块。因为 C 端产品是可以面向大用户量开发，所以往往比较严格，会考虑各种兼容，对性能优化应该深有体会，html5，css3，js 以及一些前沿的 web 技术提升都有帮助，能比较均衡的提升

## 6. 前端具体内存泄露如何定位

#### 如果代码量较少

开发者通常可以基于以下基本原则进行快速自查：

- 是否滥用全局变量，没有手动回收
  - 把指向对象的变量设置为 null，这样没有变量指向对象的时候，就会被回收
- 是否没有正确销毁定时器，闭包

  - 销毁定时器 clearTimeout 和 clearInterval
  - 销毁闭包

    ```
    const outerFn = () => {
        let count = 0;
        const innerFn = () => {
            console.log('count', ++count);
        }
        return innerFn;
    }

    let closure = outerFn(); // 创建第一个闭包
    closure();
    closure();
    closure = outerFn(); // 销毁第一个闭包，创建第二个闭包
    closure();
    closure();
    closure = null; // 销毁闭包
    // 可在模块或应用结束后来进行空赋值处理，进行销毁，比如上面的：closure = null
    ```

- 是否没有正确监听事件和销毁事件
  - 销毁时间 removeEventListener(type, listener);
    - type：一个字符串，表示需要移除的事件类型，例 ’click‘
    - listener：需要从目标事件移除的事件监听器函数

#### 如果代码量较多

开发者可以借助外部工具（开发者工具）进行内存泄漏排查

- 使用 Chrome DevTools 定位内存泄漏 - Performance
  打开准备分析的页面和 DevTools 的 Performance 面板，勾选 Memory 并开始录制，在模拟用户操作一段时间后结束录制，DevTools 会将这段时间内的页面行为活动进行记录和分析
  通过生成的结果可以直观查看到内存时间线，了解内存随时间的占用变化，如果内存占用曲线成阶梯状一直上升，则可能存在内存泄漏。按需选取时间线中的区域片段，检查对应时间段内的活动类型和时间占用，作为排查和定位内存泄漏的辅助办法 - Memory
  打开准备分析的页面和 DevTools 的 Memory 面板，按需生成快照。每个快照的内容是快照时刻，进行一次垃圾回收后，应用中所有可达的对象
  当开发者明确知道与内存泄漏关联的用户交互步骤时，可以生成多次内存快照进行对比，排查出泄漏的对象：在做用户交互操作之前，进行一次正常内存堆栈信息的快照；在做用户交互操作中或操作结束时，进行内存快照。使用 Comparison 视图或使用 filter 按需查看快照之间的差异 - Node.js 中的内存泄漏定位
  如果需要定位 Node.js 中的内存泄漏，启动 Node.js 时带上 --inspect 参数，以便利用 Chrome DevTools 工具生成 Memory 快照数据。如图所示，启动 Node.js 服务后，打开 Chrome DevTools，会有 Node 标识，点击可以打开 Node 专用 DevTools

## 7. 构建 Web API 的技术（ RESTful 和 GraphQL ）

[详细介绍](http://www.17bigdata.com/study/programming/graphql/graphql-index.html) 和 [拓展](https://zhuanlan.zhihu.com/p/78962152)

#### RESTful 存在的缺陷

- RESTful API 遵循清晰且结构良好的面向资源的方法
  - 当数据变得更复杂时，路由会变得更长
  - 有时无法通过单个请求获取全部数据
  - 有时候无法获取想要的部分数据
  - 只能规定请求的类型，PUT，GET 等，但是无法规定请求的具体数据

#### GraphQL

- 常用框架 Apollo Server 和 Apollo Client，可以帮助开发人员轻松构建可扩展、高度灵活且易于维护的 GraphQL API，并且还有一些库封装了 Apollo Client，例如 react-apollo，vue-apollo，Apollo-Boost 等等
- GraphQL GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），用于构建 API，提供更灵活、更高效、更准确的数据获取方式，有以下特点

  - **精确的数据获取**

    - GraphQL 查询始终返回可预测的结果，限制从服务器获取的数据，使用应用程序快速而稳定
    - 假如具有属性 id，firstName，lastName 和 collegeName 的业务对象 Student。假设移动应用程序只需要获取 firstName 和 id。如果我们设计一个像 /api /v1/ students 这样的 REST 端点，它将最终获取学生对象的所有字段的数据。这意味着，RESTful 服务会过度提取数据。使用 GraphQL 可以解决此问题

      ```
      // GraphQL 查询
      {
         students(limit: 2) {
            id
            firstName
         }
      }

      // 这将仅返回 id 和 firstname 字段的值。查询不会获取 学生对象 的其他属性的值。上述查询的响应如下所示
      {
         "data": {
            "students": [
               {
                  "id": "S1001",
                  "firstName": "Mohtashim"
               },
               {
                  "id": "S1002",
                  "firstName": "Kannan"
               }
            ]
         }
      }
      ```

  - **可组合性**

    - GraphQL 查询能平滑地检索关联的业务对象，在单个请求中获取应用程序所需的所有数据，来降低网络请求次数
    - 再考虑一个业务对象，College，它具有属性，name 和 location。该学生的业务对象具有大学对象的关联关系。如果我们要使用 REST API 来获取学生及其大学的详细信息，我们最终会向服务器发出两个请求，例如 /api/v1/students 和 /api/v1/schools。这将导致每次请求获取数据不足，因此，移动应用程序被迫多次调用服务器以获取所需数据，但是，移动应用程序可以使用 GraphQL 在单个请求中获取 Student 和 College 对象的详细信息

      ```
      // GraphQL 查询
      {
         students(limit: 3) {
            id
            firstName
            lastName
            college {
               name
               location
            }
         }
      }

      // 返回 学生对象 及相关联的 大学对象
      {
         "data": {
            "students": [
               {
                  "id": "S1001",
                  "firstName": "Mohtashim",
                  "lastName": "Mohammad",
                  "college": {
                     "name": "CUSAT",
                     "location": "Kerala"
                  }
               },

               {
                  "id": "S1002",
                  "firstName": "Kannan",
                  "lastName": "Sudhakaran",
                  "college": {
                     "name": "AMU",
                     "location": "Uttar Pradesh"
                  }
               },

               {
                  "id": "S1003",
                  "firstName": "Kiran",
                  "lastName": "Panigrahi",
                  "college": {
                     "name": "AMU",
                     "location": "Uttar Pradesh"
                  }
               }
            ]
         }
      }
      ```

  - **强类型系统**（ 这是服务端的内容 ）

    - GraphQL 定义了一个类型系统，可以在运行时验证查询的正确性，从而保证了数据的有效性
    - GraphQL 是强类型的，查询基于字段及其关联的数据类型。如果 GraphQL 查询中存在类型不匹配，则服务器应用程序将返回明确且有用的错误消息。这有助于客户端应用程序顺利调试和轻松检测错误。GraphQL 还提供了客户端库，可以帮助减少显式数据转换和解析

      ```
      # 约定 学生对象 和 大学对象 相关数据操作，可写在 .graphql 文件中

      # 查询 操作
      type Query { # 查询类型，Query 定义数据获取操作的入口，是根级别类型之一
        student(id: ID!): Student
           students(limit: Int): [Student] # 清单类型，列表可用于表示 对象类型，标量 或 枚举 的值数组
      }

      type Student { # 对象类型，用于定义返回数据的类型，其中的每个字段都映射到另一个类型，从而允许嵌套类型
           id: ID! # 非可空类型，用于定义不可为空的字段
           firstName: String
           lastName: String
           fullName: String
          college: College
      }

      type College {
        id: ID!
          name: String
           location: Location
           students: [Student]
      }

      enum Location { # 枚举类型
        JIANGXI
        SHANGHAI
        BEIJING
      }

      # 创建，更新 或 删除 操作
      type Mutation { # 突变类型，Mutation 类型指定数据操作操作的入口，是根级别类型之一
           # addStudent(firstName: String, lastName: String): String 可改成
           addStudent(input: CreateStudent): String # String 是返回值的类型，返回唯一 ID
      }

      input CreateStudent { # 输入类型，用于定义输入参数的类型，通常用于定义 mutation 的输入参数
        firstName: String!
        lastName: String!
      }
      ```

  - 独立性
    - GraphQL 不依赖于任何特定的后端或前端框架，因此可以在各种语言和平台上使用
    - 并且可以与任何可用的网络协议一起使用，如 TCP，websocket 或任何其他传输层协议
    - 它对数据库也是中立的，因此可以将它与关系数据库或 NoSQL 数据库一起使用
  - 实时数据更新
    - GraphQL 支持实时数据更新，通过使用订阅功能来推送数据更新给客户端
  - 可扩展性
    - GraphQL 的架构可以轻松地扩展到支持大量并发用户和复杂的数据查询

#### 部署 GraphQL Server

- GraphQL Server 集成新系统
  - 该体系结构具有带有集成数据库的 GraphQL Server，通常可用于新项目。在收到 Query 时，服务器读取请求有效负载并从数据库中获取数据。这称为解析查询。返回给客户端的响应遵循官方 GraphQL 规范中指定的格式
  - 在下图中，GraphQL 服务器和数据库集成在一个节点上。客户端通过 HTTP 与 GraphQL 服务器通信。服务器处理请求，从数据库中提取数据并将其返回给客户端
    <img src="https://img-blog.csdnimg.cn/dedffdd5e2af4c26b2891b22aaa2fc82.png">
- GraphQL Server 集成现有系统
  - 这种方法对于具有遗留基础结构和不同 API 的公司很有帮助。GraphQL 可用于统一现有系统中的微服务，遗留基础架构和第三方 API
  - 在下图中，GraphQL API 充当客户端与现有系统之间的接口。客户端应用程序与 GraphQL 服务器通信，后者又解析查询
    <img src="https://img-blog.csdnimg.cn/31a1ddc629d84017a3bf52016244263d.png">
- 混合方法
  - 可以结合上述两种方法并构建一个 GraphQL 服务器。在此体系结构中，GraphQL 服务器将解析收到的任何请求。它将从连接的数据库或集成的 API 中检索数据
    <img src="https://img-blog.csdnimg.cn/fb0c6ec1f5fb4285af465a59b5779cbf.png">

#### 服务端使用 GraphQL（ 简略版 ）

```
// schema.graphql 文件中
type Query {
     greeting(name:String!):String
     students:[Student]
     studentById(id:ID!):Student
}

type Student {
     id:ID!
     firstName:String
     lastName:String
     fullName:String
}

type Mutation {
     createStudent(collegeId:ID,firstName:String,lastName:String):String
}


// resolvers.js 文件中
const db = require('./db')
const Mutation = {
     createStudent:(root,args,context,info) => {
        return db.students.create({collegeId:args.collegeId,
        firstName:args.firstName,
        lastName:args.lastName})
     }
}
const Query = {
     greeting:(root,args,context,info) => `Hi ${args.name}`,
     students:() => db.students.list(),
     studentById:(root,args,context,info) => {
        //args will contain parameter passed in query
        return db.students.get(args.id);
   }
}
const Student = {
     fullName:(root,args,context,info) => {
        return root.firstName+":"+root.lastName
     }
}

module.exports = {Query,Student,Mutation}
```

```
// 对于客户端发来的请求如下
{
     students{
        id
        fullName
     }
}

// 响应数据
{
     "data": {
        "students": [
           {
              "id": "S1001",
              "fullName": "Mohtashim:Mohammad"
           },
           {
              "id": "S1002",
              "fullName": "Kannan:Sudhakaran"
           },
           {
              "id": "S1003",
              "fullName": "Kiran:Panigrahi"
           }
        ]
     }
}
```

#### 客户端使用 GraphQL

- easy 版（ 服务器给啥我要啥）
  ```
  async function loadSayhello(name) {
       const response = await fetch('http://localhost:9000/graphql', {
          method:'POST',
          headers:{'content-type':'application/json'},
          body:JSON.stringify({query:`{greeting(name:"${name}")}`})
       })
  }
  ```
- medium 版（ 规定返回过来的数据（ 只要一部分数据 ） ）

  ```
  import {ApolloClient, HttpLink, InMemoryCache} from 'apollo-boost'
  import gql from 'graphql-tag'

  const endPointUrl = 'http://localhost:9000/graphql'
  const client = new ApolloClient({
       link: new HttpLink({uri:endPointUrl}),
       cache:new InMemoryCache()
  });
  async function loadStudentsAsync() {
       const query = gql`
       {
          students {
             id
             firstName
             lastName
             college {
                name
             }
          }
       }
       `
       const { data } = await client.query({ query }) ;
       return data.students;
  }
  ```
