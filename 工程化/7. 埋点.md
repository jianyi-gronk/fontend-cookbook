## 1. 前端埋点

#### 1.1 基础介绍

- 用于收集用户行为数据，例如 域名，ip，每个页面的停留时间，页面的操作（ 搜索的内容，点了什么按钮，常按的按钮名称 ），由哪个页面跳转过来 等数据

#### 1.2 常见前端埋点方案

- 代码埋点：需要在开发代码的时候，通过代码的方式在页面中嵌入逻辑，比如捕获一个点击事件，在这个点击事件之前加入代码埋点,上报给后台
  - 定制程度高，可以精准地自定义什么时候什么事件传什么数据到后台
- 可视化埋点：一般需要第三方的服务商（ 例如神策 ）支持，可视化埋点开发人员除集成采集可视化 SDK 外，不需要额外去写埋点代码，而是由业务人员或运营人员通过访问分析平台的圈选功能，来 “圈” 出需要对用户行为进行捕捉的控件，并给出事件命名。圈选完毕后，这些配置会同步到各个用户的终端上，由采集 SDK 按照圈选的配置自动进行用户行为数据的采集和发送
  - 工作量小，更新代价小，直接借助第三方即可，只需要业务同事勾选想要埋点捕捉的控件即可，可跳过代码开发流程，极大提升生产力
- 全埋点（ 无痕埋点 ），利用浏览器或 APP 自带的监听方式，对用户的浏览页面、点击等行为进行收集，一般用于粗颗粒度的数据分析，例如公司的 slardar
  - 数据噪声大，不管有用没有，数据都会被收集，用户操作行为收集非常完整，几乎不会遗漏，数据太多，也会增加服务器压力
  - 无法定制化埋点，无法采集到指定事件和业务属性
  - 可供 DA 使用的信息较少
  - 接入简单，几乎无侵入，不需要额外的开发成本

#### 1.3 常见上报事件

- 交互，逻辑事件上报
  - 交互事件：用户交互事件触发时，比如点击、长按等
  - 逻辑事件：符合逻辑条件时，比如登陆、跳转页面等
  - 可以通过给元素绑定自定义指令的方式实现（ 减少对原有代码的侵入 ），将信息存储在缓存池中定时上报（ 缓解服务器压力 ），上报之后清空之前的上报信息
- 停留事件上报：
  - 需要重新封装路由，创建路由拦截，若当前页面切换，在跳转之前记录来源，以及上一个页面的停留时间，当拦截器捕获成功之后，如果发现停留时间大于 xx 秒进行上报（ 缓解服务器压力 ）

## 2. 数据上报

#### 2.1 基础介绍

- 比如上面的埋点数据上报，或者日志数据上报，前端性能，异常监控数据上报等等

#### 2.2 通过 ajax 请求上报数据

- 最熟悉的方式，发送一个 post 请求，那为什么这个方案没有人用呢
- 比如我们常用的 axios 和 fetch 都是异步请求，那如果在页面卸载或刷新时进行上报的话，请求可能会在浏览器关闭或重新加载前还未发送至服务端就被浏览器 cancel 掉，导致数据上报失败
  所以如果我们要用 ajax 请求上报数据，需要用 XMLHttpRequest 发送同步请求，这样就能保证请求一定能发送到服务端
- 但是同步请求，会在接收响应之前，一直阻塞主线程（ 用户界面做任何操作都是无效的，都是不会响应的，只有当请求数据完毕之后，才会响应用户交互，这是同步请求的缺陷，但是浏览器关闭或重新加载的时候，可能影响用户操作问题不大（ 都要关闭或者刷新了，你还操作个啥 ）），所以还是存在很大缺陷

#### 2.3 通过 GIF 图片 上报

- 利用图片的 src 属性发送请求进行数据上报，其优点有：
  - 因为大部分浏览器会延迟卸载（ unload ）文档以加载图像（ 只是大多数浏览器，还是存在兼容性的 ），所以用图片上报就可以解决上一种方法的漏洞
  - 图片请求方式不会出现跨域问题
  - 防止阻塞页面加载，影响用户体验，并且构造图片来上报，不用插入 DOM，只要在 js 中 new 个 Image 对象就能发起请求
- 那为什么要用 GIF 图片上报呢？
  - 因为 gif 图片格式体积小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）
  - 一般采用 1\*1 像素的透明 gif 进行上报，因为 1x1 像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积
  - 并且可以避免跨域问题

#### 2.4 sendBeacon

- Beacon 可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（ 解决 ajax 页面卸载会终止请求的问题 ）
- 虽然好，但是存在兼容性问题（ 经典问题， IE 低版本不兼容 ）
  ```
  navigator.sendBeacon(url, data);
  ```

#### 2.5 实际使用方式

- 因为 sendBeacon 方法存在兼容性问题，所以通常优先使用 sendBeacon 的方式，Image 方式作为 fallback
  ```
  function sendLog(url: string, params: object) {
      if（navigator.sendBeacon) {
          sendBeacon(url, params)
      } else {
          sendImage(url, params)
      }
  }
  ```

## 3. 埋点通道化

## 1. 整体方案

#### 1.1 现状问题

- 各业务埋点自成体系，标准不互通，所以很难进行跨业务分析埋点数据
- 目前为了跨业务分析埋点，都是侵入其他业务代码添加埋点，或传递埋点参数
- 当前的埋点问题，不仅会造成埋点重复上报和错报等问题，也加重了埋点开发工作和维护成本，制约了业务的告诉迭代

#### 1.2 标准化

- 治理埋点，首先要制定统一的埋点标准，各业务间能够形成统一认识，能够快速理解各业务埋点，轻松的做到基于标准去发布和开发埋点需求，并且能在不侵入上下游业务的情况下，做到跨业务的数据分析
- 用户行为数据可分为 5 个属性组成，时间，地点，人物，交互，交互的内容，其中，时间和人物在通常在埋点时会自动拼接，但其他三个属性经常缺乏标准约束
