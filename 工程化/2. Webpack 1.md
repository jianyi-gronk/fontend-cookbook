## 1. webpack 是什么，用来做什么

- 官方话，本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个依赖图，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容
  - 这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源，即可以直接被获取打包进 bundle.js 的资源
- 简而言之，webpack 是一个打包模块化 JavaScript 的工具，它会从入口模块出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中
- webpack 五个核心内容：
  1.  Entry：可以在配置文件中配置 entry 属性，来指定一个或多个入口点，指示 webpack 以哪个（些）文件为入口起点开始打包
  2.  Output：输出指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名，不过即使可以存在多个 entry 起点，但只指定一个 output 配置
  3.  Loader：可以看作具有文件转换功能的翻译员，配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换
  4.  Plugin：用于扩展 Webpack 功能，各种各样的 Plugin 几乎让 Webpack 可以做任何构建相关的事情
  5.  mode：指示 webpack 使用开发模式或者生产模式

## 2. webpack 的优缺点

- 优点：
  1.  相比于 vite，parcel，Snowpack 等构造工具，webpack 大而全，很多常用功能开箱即用，例 HRM、Tree-shaking 等功能
  2.  可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间
  3.  生态环境好，社区更丰富，出现的问题更容易解决，且有很多现成强大的 Plugin 接口，具有更好的灵活性和扩展性
  4.  一切皆是模块，对 js、css、图片等资源文件都支持打包
  5.  智能解析，对 CommonJS 规范，AMD 规范，CMD 规范，ES6 规范的语法做了兼容
  6.  易于调试，支持 SourceUrls 和 SourceMaps
  7.  快速运行，webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快
- 缺点：
  1.  只能用于采用模块化开发的项目
  2.  配置复杂
  3.  官方文档混乱，文档缺失，尤其中文文档
  4.  webpack 在首次打包的时候，需要做长时间的准备工作，比如加载插件等
  5.  新版本对旧版本存在向上兼容问题，例 npm i XXX -g(-d) 一定要指定版本，尽量低版本，也不最新版本，会导致不兼容和指令不一样的问题

## 3. webpack 的构建流程

1. 初始化参数：从 webpack.config.js 配置文件和 Shell 语句中读取与合并参数，得出最终的参数
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的 Plugin 插件，执行对象的 run 方法开始执行编译
3. 确定入口：根据配置中的 entry 找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
5. 完成模块编译：在经过上一步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

## 4. module、chunk、bundle 的区别

![image](https://img-blog.csdnimg.cn/b4ce9845d163438ea95c24ac6aedb0f8.png)

- module、chunk 和 bundle 其实就是同一份代码在不同转换场景取的三个名称
- 编写的是 module，webpack 处理时是 chunk，最终生成供浏览器允许的是 bundle

#### module 是什么

- 官方概念：Module 是离散功能块，相比于完整程序提供了更小的接触面。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的
- module 其实就是一个文件或者文件内通过 import 等方式引用代码块或第三方等均可认为是一个 module，也就是说任何一个可以被导入导出的文件都是一个模块
- 对于 webpack 来说，项目源码中所有资源（ 包括 JS、CSS、Image、Font 等等 ）都属于 module 模块。可以配置指定的 Loader 去处理这些文件

#### chunk 是什么

- 官方概念：chunk 此 webpack 特定术语在内部用于管理捆绑过程。输出束（ bundle ）由块组成，其中有几种类型（ 例如 entry 和 child ）。通常，块 直接与 输出束 ( bundle ）相对应，但是，有些配置不会产生一对一的关系
- 当使用 webpack 将我们编写的源代码进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这些 chunk 文件进行一些操作
- 当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作

#### bundle 是什么

- 官方概念：bundle 由许多不同的模块生成，包含已经经过加载和编译过程的源文件的最终版本
- webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行
- Bundle 就是我们最终输出的一个或多个打包文件。大多数情况下，一个 chunk 会生产一个 bundle

## 5. 如何借助 webpack 优化前端性能

1. 压缩 js
   - terser 可以帮助我们压缩、丑化我们的 js 代码，让 bundle 更小，在 production 模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的
2. 压缩 CSS
   - CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等，这个插件使用 cssnano 来优化和缩小你的 CSS 可以使用一个插件：css-minimizer-webpack-plugin
3. 压缩 html
   - 使用 HtmlWebpackPlugin 插件来生成 HTML 的模板时候，可以通过配置属性 minify 进行 html 优化，例是否折叠空格，是否移除注释等
4. 图片压缩
   - 除了在 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，对于其他较大图片可以用 image-webpack-loader 来压缩图片
5. 打包公共代码
   - 通过 CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件（ 又称作 chunk ）的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个很大的文件
6. Tree Shaking
   - 开发环境下的配置
     - 配置 usedExports 后，会通过标记某些函数是否被使用，之后通过 Terser 来进行优化的
     - 使用之后，没被用上的代码在 webpack 打包中会加入 unused harmony export mul 注释，用来告知 Terser 在优化时，可以删除掉这段代码
       ```
       module.exports = {
         mode: 'development',
         optimization: {
           usedExports: true,
         }
       };
       ```
     - 如下面 sum 函数没被用到，webpack 打包会添加注释，terser 在优化时，则将该函数去掉
   - 生产环境下的配置
     - 在生产环境下，Webpack 默认会添加 Tree Shaking 的配置，所以只要设置 mode 就行，但还需要通过配置 sideEffects 控制是否跳过整个模块/文件，即该文件是否有副作用（在 package.json 中添加字段：sideEffects: false）
     - sideEffects 默认为 true， 告诉 Webpack ，所有文件都有副作用，他们不能被 Tree Shaking
     - sideEffects 为 false 时，告诉 Webpack ，没有文件是有副作用的，他们都可以 Tree Shaking
     - sideEffects 为一个数组时，告诉 Webpack ，数组中那些文件不要进行 Tree Shaking，其他的可以 Tree Shaking
   3. 注意
      - 对于那些直接引入到 js 文件的文件，例如全局的 css，它们并不会被转换成一个 CSS 模块，例
        ```
        import "./styles/reset.css"
        ```
      - 这样的代码，在打包后，打开页面，你就会发现样式并没有应用上，原因在于：上面我们将 sideEffects 设置为 false 后，所有的文件都会被 Tree Shaking，通过 import 这样的形式引入的 CSS 就会被当作无用代码处理掉，所以需要添加 sideEffects: true

## 6. 常见的 loader 有哪些

- webpack 是基于 node 的模块化打包工具，它默认只知道如何处理 JS 和 JSON 模块，对于其他格式的模块如 CSS、图片等，就不知道如何处理了。这时候我们就需要定义相应的 loader ，告诉 webpack 如何处理。loader 就相当于是一个翻译机，将源文件经过传化后输出能被 webpack 处理的新内容，并且一个文件还可以链式的经过多个翻译机翻译
- 加载文件相关
  1.  file-loader：把文件输出到一个文件夹中，在代码中通过相对路径去引用输出的文件
  2.  url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
- 加载样式相关
  1.  style-loader：用于把 css 插入到 DOM 中，默认通过使用多个 \<style> 自动把 styles 插入到 DOM 中。需要注意 loader 执行顺序，style-loader 放到第一位，因为 loader 都是从下往上执行，最后全部编译完成挂载到 style 上
  2.  css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，css-loader 会对 @import 和 url() 导入进行处理，就像 js 解析 import/require() 一样
  3.  less-loader：把 Less 代码转换成 CSS 代码
  4.  sass-loader：把 SCSS/SASS 代码转换成 CSS
  5.  postcss-loader：使用 PostCSS 处理 CSS 的 loader
      postcss 一种对 css 编译的工具，类似 babel 对 js 的处理，常见的功能如： 1. 使用下一代 css 语法 2. 自动补全浏览器前缀 3. 自动把 px 代为转换成 rem 4. css 代码压缩等等
- 转换脚本语言相关
  1.  babel-loader：将 es6+ 语法转换为 es5 语法。注意 babel-loader 运行很慢，确保转译尽可能少的文件，避免去转译 node_modules 目录或者其他不需要的源代码，并且可以设置 cacheDirectory（默认值为 false），当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程
  2.  ts-loader：把 TypeScript 转换成 JavaScript
- 框架相关
  1.  vue-loader：用于编译.vue 文件
- 检查代码相关
  1.  eslint-loader：用于检查代码是否符合规范，是否存在语法错误

## 7. 常见的 plugin 有哪些

- HtmlWebpackPlugin：在打包结束后，⾃动生成⼀个 html 文件，并把打包生成的 js 模块引⼊到该 html 中
- CleanWebpackPlugin：用于在打包前清理上一次项目生成的 bundle 文件，它会根据 output.path 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大
- DefinePlugin：我们可以通过 DefinePlugin 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，DefinePlugin 是 webpack 自带的插件
- MiniCssExtractPlugin：本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载
  - 本插件基于 webpack v5 的新特性构建，并且需要 webpack 5 才能正常工作
  - 与 extract-text-webpack-plugin 相比优点：
    1. 异步加载
    2. 没有重复的编译（性能）
    3. 更容易使用
    4. 特别针对 CSS 开发
- CopyWebpackPlugin：复制文件或目录到执行区域，如 vue 的打包过程中，如果我们将一些文件放到 public 的目录下，那么这个目录会被复制到 dist 文件夹中。例我们在 public/index.html 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 copy-webpack-plugin 就可以很好地帮我做拷贝的工作了
- HotModuleReplacementPlugin：启用 HMR（模块热替换功能） 很容易，且在大多数情况下不需要任何配置。但注意 HMR 绝对不能被用在生产环境

## 8. loader 和 plugin 区别

1. 功能上的区别
   1. loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中
   2. plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事
2. 运行时机上的区别
   1. loader 运行在打包文件之前，实质是一个转换器，将 A 文件进行编译形成 B 文件，操作的是文件，比如将 A.scss 或 A.less 转变为 B.css，单纯的文件转换过程
   2. plugins 在整个编译周期都起作用，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果

## 9. 如何提高 webpack 的构建速度

1. 优化 loader 配置

   - 在使用 loader 时，可以通过配置 include、exclude、test 属性来匹配文件，通过 include，exclude 可以减少处理的文件数，通过 test 可以提升匹配文件效率

   ```
   module.exports = {
     module: {
         rules: [
             {
               // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
               test: /\.js$/,
               // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
               use: ['babel-loader?cacheDirectory'],
               // 只对项目根目录下的 src 目录中的文件采用 babel-loader
               include: path.resolve(__dirname, 'src'),
             },
         ]
       },
   };
   ```

2. 使用 cache-loader
   - 在一些性能开销较大的 loader 之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度，但是保存和读取这些缓存文件会有一些时间开销，所以应该只对性能开销较大的 loader 使用此 loader
   ```
   module.exports = {
       module: {
           rules: [
               {
                   test: /\.ext$/,
                   use: ['cache-loader', ...loaders],
                   include: path.resolve('src'),
               },
           ],
       },
   };
   ```
3. terser 启动多线程

   - 使用多进程并行运行来提高构建速度

   ```
   module.exports = {
     optimization: {
       minimizer: [
         new TerserPlugin({
           parallel: true,
         }),
       ],
     },
   };
   ```

4. 合理使用 sourceMap
   - 打包生成 sourceMap 的时候，如果信息越详细，打包速度就会越慢

## 10. 有没有自己写过 loader

- 一个 loader 就是一个 node.js 模块，这个模块需要导出一个函数，这个函数的工作就是获得处理前的源内容，对源内容进行处理后，返回处理后的内容。并且函数中的 this 作为上下文会被 webpack 填充，是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息，因此我们不能将 loader 设为一个箭头函数
- 编写自定义 loader 时，需要遵守原则：
  1.  职责单一：每个 loader 只做一件事
  2.  链式调用：第一个 loader 接收到的是源文件的内容，后续 loader 都是接收到的是上一个 loader 返回的处理结果，webpack 会按顺序链式调用每个 loader
  3.  统一原则：遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用
  4.  模块化：保证 loader 是模块化的。loader 生成模块需要遵循和普通模块一样的设计原则
  5.  无状态：在多次模块的转化之间，我们不应该在 loader 中保留状态。每个 loader 运行时应该确保与其他编译好的模块保持独立，同样也应该与前几个 loader 对相同模块的编译结果保持独立
- 注：loader 返回分同步和异步
  1.  同步
      1. return source 返回
         ```
         module.exports = function (source) {
             // 处理 source ...
             const content = source.replace("hello", "哈哈");
             return content;
         }
         ```
      2. this.callback() 返回
         - 可以返回除了处理内容以外的其它信息，this.callback 是 webpack 注入的 API，方便 loader 和 webpack 之间通信
         ```
         module.exports = function (source) {
           // 处理 source
           const content = source.replace("hello", "哈哈");
           /*
            * 使用 this.callback 返回内容，参数有：
              * error：Error | null，当 loader 出错时向外抛出一个 error
              * content：String | Buffer，经过 loader 编译后需要导出的内容
              * sourceMap：为方便调试生成的编译后内容的 source map
              * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
              */
           this.callback(null, content);
           // 使用 this.callback 返回内容时，该 loader 必须返回 undefined，
           // 以让 webpack 知道该 loader 返回的结果在 this.callback 中，而不是 return 中
           return;
         };
         ```
  2.  异步
      - 在某些场景下转换内容需要异步才能完成，例如需要通过网络请求才能得到结果，如果使用同步的方式，网络请求就会阻塞整个构建过程，导致构建变得十分缓慢
      ```
      module.exports = function (source) {
          // 调用 this.async() API，告诉 webpack本次转换是异步的，loader 会在 callback 中返回结果
          const callback = this.async();
          // 使用 setTimeout 模拟异步过程
         setTimeout(() => {
            const content = source.replace("hello", "哈哈");
            // 通过 callback 返回执行异步后的结果
            callback(null, content);
        }, 3000);
      };
      ```
  3.  实战：（ mini 版 style-loader ）
      ```
      module.exports = function(source) {
          return `const styleTag = document.createElement('style');
              styleTag.innerHTML = ${source};
              document.head.appendChild(styleTag);
          `
      }
      ```

## 11. 有没有自己写过 plugin

- 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务
- webpack 编译会创建两个核心对象：
  1.  compiler：是一个对象，该对象代表了完整的 webpack 环境配置。整个 webpack 在构建的时候，会先初始化参数也就是从配置文件(webpack.config.js)和 Shell 语句("build": "webpack --mode development")中去读取与合并参数，之后开始编译，也就是将最终得到的参数初始化这个 Compiler 对象，然后再会加载所有配置的插件，执行该对象的 run()方法开始执行编译。因此我们可以理解为它是 webpack 的支柱引擎。包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子
  2.  compilation：是一个对象，不过它表示的是某一个模块的资源、编译生成的资源、变化的文件等等，因为在使用 webpack 进行构建的时候可能是会生成很多不同的模块的，而它的颗粒度就是在每一个模块上。作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建
- 编写自定义 plugin 时，需要遵守原则：
  1.  插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例
  2.  传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改
  3.  异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住
- webpack 生命周期钩子：

  - 生命周期钩子具体有哪些在[这里](https://webpack.docschina.org/api/compiler-hooks/)，例 run，emit，compile 等等
  - 我们可以在具体钩子下面看到类似于 SyncHook 这种标签，这个即是钩子的种类，有九种：
    1. Sync\*（同步）
       1. SyncHook：同步串行，不关心返回值
       2. SyncBailHook：同步串行，如果返回值不为 null 则跳过之后的函数
       3. SyncLoopHook：同步循环，如果返回值为 true 则继续执行，返回值为 false 则跳出循环
       4. SyncWaterfallHook：同步串行，上一个函数返回值会传给下一个监听函数
    2. Async\*（异步）
       1. AsyncParallel\*（异步并发）
          1. AsyncParallelBailHook：异步并发，只要监听函数的返回值不为 null，就会忽略后面的监听函数执行，直接跳跃到 callAsync 等触发函数绑定的回调函数，然后执行这个被绑定的回调函数
          2. AsyncParallelHook：异步并发，不关心返回值
       2. AsyncSeries\*（异步串行）
          1. AsyncSeriesHook：异步串行，不关心 callback() 的参数
          2. AsyncSeriesBailHook：异步串行，callback()的参数不为 null，就会忽略后续的函数，直接执行 callAsync 函数绑定的回调函数
          3. AsyncSeriesWaterfallHook：异步串行，上一个函数的 callback(err, data)的第二个参数会传给下一个监听函数
  - 九种钩子对应了三种方法：
    - 例，现在想要注册一个 compile 的钩子，根据官方文档，可以发现它是 SyncHook 类型的钩子，那么只能用 tap 来注册它，如果用 tapAsync 的话，打包时，会发现控制台报错
    1. tap：可以注册同步钩子也可以注册异步钩子
    2. tapAsync：回调方式注册异步钩子
    3. tapPromise：Promise 方式注册异步钩子

- 大概模板：

  ```
  class MyPlugin {
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
      apply (compiler) {
        // 找到合适的事件钩子，实现自己的插件功能
        compiler.hooks.emit.tap('MyPlugin', compilation => {
            // compilation: 当前打包构建流程的上下文
            console.log(compilation);

            // do something...
        })
      }
  }
  ```

- 实战：
  ```
  module.exports = class FileListPlugin{
      constructor (options) {
          this.options = options || {};
          this.filename = this.options.filename || 'fileList.md'
      }
      apply (compiler) {
          // await/async
          compiler.hooks.emit.tapPromise('FileListPlugin', async (compilation) => {
              await new Promise(resolve => {
                  setTimeout(() => {
                      resolve()
                  }, 1000)
              })
              const fileListName = this.filename;
              let len = Object.keys(compilation.assets).length;
              let content = `# 一共有${len}个文件\n\n`;
              for (let filename in compilation.assets) {
                  content += `- ${filename}\n`;
              }
              compilation.assets[fileListName] = {
                  source: function () {
                      return content;
                  },
                  size: function () {
                      return content.length;
                  }
              }
          })
      }
  }
  ```
