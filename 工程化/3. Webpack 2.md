## 1. webpack 热更新原理（ [详情](https://blog.csdn.net/u012244479/article/details/129640030) ）

#### 什么是热更新

- HMR 即 Hot Module Replacement 是指当你对代码修改并保存后，webpack 将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面
- 热更新技术包含了 监听本地文件、增量编译构建、代码热替换、socket 通信 等技术点

![image](https://img-blog.csdnimg.cn/8794fdfec84b42438a8897821113c912.png)

#### 实际场景作用

- 在 HMR 之前，应用的加载、更新是一种页面级别的原子操作，即使只是单个代码文件发生变更都需要刷新整个页面才能最新代码映射到浏览器上，这会丢失之前在页面执行过的所有交互与状态，例如：
  - 对于复杂表单场景，这意味着你可能需要重新填充非常多字段信息
  - 弹框消失，你必须重新执行交互动作才会重新弹出
- 引入 HMR 后，虽然无法覆盖所有场景，但大多数小改动都可以实时热更新到页面上，从而确保连续、顺畅的开发调试体验，对开发效率有较大增益效果

#### 热更新主要涉及的插件

- webpack-dev-server（ 用于服务端，这是还有其他的插件可以使用 ）
  - 是 node-express（ 启动服务 ）+ webpack-dev-middleware + webpack-hot-middleware 的集成封装，可以方便的启动一个具有热更新功能的本地服务器
  - 会创建两个服务器：一个用于提供静态资源的服务（ express 服务器 ），另一个用于提供 Socket 服务
    - express server：会接受浏览器端发送的 AJAX 请求来获取资源
    - socket server：会与浏览器端的 HMR runtime 通过 WebSocket 保持连接，以推送更新信息，发送 hash 值
  - webpack-dev-middleware
    - 最主要是能够将 webpack 编译产物提交给服务器，并且将产物放置在内存中，会在内存中创建一个虚拟的打包文件，而不是将打包文件输出到磁盘上，这样可以减少磁盘 IO 操作，提高性能（ 这也是为什么在开发过程中在文件夹中找不到打包代码 ）
  - webpack-hot-middleware
    - 提供热更新的能力，负责建立一个 WebSocket 连接，用于将文件变化的信息推送给浏览器（ 通过使用 webpack 提供的热更新 API 实现，所以实际干活的还是 webpack ）
- HotModuleReplacementPlugin（ 用于客户端 ）
  - 在生成的模块代码中注入 HMR runtime：
    - 负责在浏览器端与开发服务器建立 WebSocket 连接，接收更新通知
  - 监听模块变更：
    - 在运行时，HMR runtime 会与开发服务器保持连接，并监听模块的变更。当某个模块发生改变时，开发服务器会向 HMR runtime 发送更新通知
  - 应用模块更新：
    - 接收到更新通知后，HMR runtime 会负责应用更新的模块代码，而无需刷新整个页面。它使用特定的更新策略，通过替换、移除或添加新的模块来实现热替换

#### 热更新涉及的模块

- HMR 插件：Webpack 提供了 HotModuleReplacementPlugin 插件，用于在构建过程中启用和配置热更新功能。这个插件会自动将必需的代码注入到生成的 bundle 中，并生成一个 HMR manifest，用于在运行时确定哪些模块需要进行热替换
- HMR runtime（ 运行时 ）：HMR runtime 是 Webpack 在构建过程中注入到生成的 bundle 中的代码。它负责在浏览器端管理模块热替换的逻辑。HMR runtime 在浏览器运行时与开发服务器建立 WebSocket 连接，用于接收更新通知并处理模块的更新
- HMR manifest（ 清单 ）：HMR manifest 是一个 JSON 文件，包含了每个模块的标识符和更新后的路径。它用于在热更新过程中确定哪些模块需要被更新。HMR runtime 会通过 WebSocket 接收新的 HMR manifest，并根据其中的信息进行模块热替换
- 模块更新回调（ accept callback ）：当某个模块发生更新时，HMR runtime 会触发相应的模块更新回调。这是一个可选的回调函数，允许开发者处理模块更新的逻辑。通过这个回调，开发者可以决定如何在模块更新时更新应用程序的状态或执行其他自定义操作
- HMR server（ 开发服务器 ）：开发服务器负责监听文件变化、构建项目并提供热更新服务。HMR server 可以是 Webpack Dev Server 或其他支持热更新的开发服务器。它与浏览器端的 HMR runtime 通过 WebSocket 保持连接，以推送更新信息

#### 热更新原理

1. 使用 webpack-dev-server（ 简称 WDS ）托管静态资源，同时 HotModuleReplacementPlugin 以 Runtime 方式注入 HMR 客户端代码
2. 浏览器加载页面后，Runtime 与 WDS 建立 WebSocket 连接
3. Webpack 监听到文件变化后，增量构建发生变更的模块，生成 [hash].hot-update.json（ manifest 文件 ）和 [hash].hot-update.js 文件（ update chunk ），并通过 WebSocket 发送文件改动后生成的 hash 值
   - hot-update.json：这是一个描述热更新补丁的元数据文件。它保存了与每个模块相关的 hash 值和文件路径，用于与服务器进行比对，确定哪些模块需要被更新
   - hot-update.js：这是一个增量更新的 JavaScript 文件，包含了发生变化的模块的新代码。浏览器通过加载和执行这个文件，将更新的模块替换掉旧的模块，从而实现热模块替换
4. 浏览器接收到 hash 事件后，发送 AJAX 请求 [hash].hot-update.json 和 [hash].hot-update.js 文件
5. 浏览器加载发生变更的增量模块，替换掉旧的模块
6. 当使用热更新功能时，HMR 的模块 API 会在特定的情况出发，比如 模块发生变化，接受更新并应用，处理错误 等

#### 常用 HMR 的模块 API（ [详细](https://webpack.docschina.org/api/hot-module-replacement/#module-api) ）

- HMR 的模块 API 接口将被暴露在 module.hot 以及 import.meta.webpackHot 属性下
- accept

  - 接受（ accept ）给定 依赖模块（ dependencies ）的更新，并触发一个 回调函数 来响应更新，除此之外，可以附加一个可选的 error 处理程序
  - 当使用 ESM import 时，所有从 dependencies 中导入的符号都会自动更新。注意：依赖项字符串必须与 import 中的 from 字符串完全匹配。在某些情况下， 甚至可以省略 callback。在 callback 中使用的 require() 在这里没有任何意义
  - 在使用 CommonJS 时，你应该通过 callback 中的 require() 手动更新依赖模块。省略 callback 在这里没有任何意义

  ```clike
  module.hot.accept(
    dependencies, // 可以是一个字符串或字符串数组
    callback // 用于在模块更新后触发的函数
    errorHandler // (err, {moduleId, dependencyId}) => {}
  );

  // or
  import.meta.webpackHot.accept(
    dependencies, // 可以是一个字符串或字符串数组
    callback, // 用于在模块更新后触发的函数
    errorHandler // (err, {moduleId, dependencyId}) => {}
  );
  ```

- accept（ self ）

  - 接受自身更新
  - 在此模块或依赖模块更新时，可以在不通知父依赖的情况下，对此模块处理和重新取值。如果此模块没有导出（ 或以其他方式更新的导出 ），这是有意义的
  - 当执行此模块（ 或依赖模块 ）抛出异常时，会触发 errorHandler

  ```clike
  module.hot.accept(
    errorHandler // 在计算新版本时处理错误的函数
  );

  // or
  import.meta.webpackHot.accept(
    errorHandler // Function to handle errors when evaluating the new version
  );
  ```

- decline

  - 拒绝给定依赖模块的更新，使用 'decline' 方法强制更新失败
  - 将依赖模块标记为不可更新（ not-update-able ）。在处理「依赖的导出正在更新」或「尚未实现处理」时，这是有意义的
  - 取决于 HMR 管理代码， 此依赖模块（ 或其未接受的依赖模块 ）更新，通常会导致页面被完全重新加载

  ```clike
  module.hot.decline(
    dependencies // 可以是一个字符串或字符串数组
  );

  // or
  import.meta.webpackHot.decline(
    dependencies // Either a string or an array of strings
  );
  ```

- decline（ self ）

  - 拒绝自身更新
  - 将依赖模块标记为不可更新（ not-update-able ）。当此模块具有无法避免的外部作用（ side-effect ），或者尚未对此模块进行 HMR 处理时，这是有意义的
  - 取决于 HMR 管理代码，此依赖模块（ 或其未接受的依赖模块 ）更新，通常会导致页面被完全重新加载

  ```clike
  module.hot.decline();

  // or
  import.meta.webpackHot.decline();
  ```

## 2. Tree Shaking 原理（ [详情 1](https://zhuanlan.zhihu.com/p/403901557) ，[详情 2](https://juejin.cn/post/6844903640533041159)，[详情 3](https://juejin.cn/post/7105022295474700295) ）

#### Tree Shaking 作用

- 为了移除 JavaScript 上下文中的未引用代码 （ Dead Code ）
- 它依赖于 ES2015 模块语法的静态结构特性，通过在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾被其它模块使用，并将其删除，以此实现打包产物的优化

#### 前提条件

- 在 Webpack 中，启动 Tree Shaking 功能必须同时满足三个条件：
  - 使用 ESM 规范编写模块代码
  - 配置 optimization.usedExports 为 true，启动标记功能
  - 启动代码优化功能，可以通过如下方式实现：
    - 配置 mode = production
    - 配置 optimization.minimize = true
    - 提供 optimization.minimizer 数组
- 例如：
  ```
  // webpack.config.js
  module.exports = {
    entry: "./src/index",
    mode: "production",
    devtool: false,
    optimization: {
      usedExports: true,
    },
  };
  ```

#### 理论基础

- 在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的，例如：
  ```
  if(process.env.NODE_ENV === 'development'){
    require('./bar');
    exports.foo = 'foo';
  }
  ```
- 而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：
  ```
  if(process.env.NODE_ENV === 'development'){
    import bar from 'bar';
    export const foo = 'foo';
  }
  ```
- 所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件

#### 实现原理

- Webpack 中，Tree-shaking 的实现一是先 **标记** 出模块导出值中哪些没有被用过，二是使用 **Terser 删掉** 这些没被用到的导出语句
- 标记功能只会影响到模块的导出语句，真正执行 “Shaking” 操作的是 Terser 插件
- 标记过程大致可划分为三个步骤：（ 本质上和 垃圾回收一样 都是用的图的可达性算法 ）
  - Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中
  - Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用
  - 生成产物时，若变量没有被其它模块使用则删除对应的导出语句
- Shaking（ 删除 Dead Code，[详情](https://blog.csdn.net/Dong_HFUT/article/details/129289094#:~:text=DCE%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%201%20%E9%A6%96%E5%85%88%EF%BC%8C%E6%A0%87%E8%AF%86%E6%89%80%E6%9C%89%E8%AE%A1%E7%AE%97%E5%BF%85%E8%A6%81%E5%80%BC%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%82%20%E6%AF%94%E5%A6%82%E5%9C%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%A6%81%E8%BF%94%E5%9B%9E%E6%88%96%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%EF%BC%8C%E6%88%96%E8%80%85%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%B9%E4%BB%8E%E8%BF%87%E7%A8%8B%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E6%9C%89%E5%BD%B1%E5%93%8D,2%20%E7%84%B6%E5%90%8E%EF%BC%8C%E4%BB%A5%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E9%80%90%E6%AD%A5%E6%A0%87%E8%AE%B0%E5%AF%B9%E8%BF%99%E7%A7%8D%E5%AF%B9%E8%AE%A1%E7%AE%97%E5%BF%85%E8%A6%81%E5%80%BC%E6%9C%89%E8%B4%A1%E7%8C%AE%E7%9A%84%E6%8C%87%E4%BB%A4%203%20%E5%BD%93%E4%BB%A5%E4%B8%8A%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B%E7%A8%B3%E5%AE%9A%E4%B8%8D%E5%8F%98%E6%97%B6%EF%BC%8C%E6%89%80%E6%9C%89%E6%9C%AA%E6%A0%87%E8%AE%B0%E7%9A%84%E6%8C%87%E4%BB%A4%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%AE%A4%E4%B8%BA%E6%98%AFDead%20Code%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4) ）
  - 因为导出的语句已经被删掉，所以会形成一段不可能被执行的 Dead Code 效果
  - 将由 Terser、UglifyJS 等 DCE 工具“摇”掉这部分无效代码，构成完整的 Tree Shaking 操作
- 具体过程：
  - 在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中
  - 在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo.\_usedInRuntime 集合中
  - 在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语
  - 使用 DCE 工具删除 Dead Code，实现完整的树摇效果

#### 举例

- 存在代码

  - bar.js

    ```
    const bar = 'bar';
    const foo = 'foo';

    export { bar, foo };
    ```

  - index.js
    ```
    import { bar } from './bar';
    console.log(bar);
    ```

- 标记过程

  - 发现模块导出值中哪些没有被用过，并删掉（ 标记功能只会影响到模块的导出语句 ）
  - 得到结果（ bar.js ）

    ```
    const bar = 'bar';
    const foo = 'foo';

    export { bar };
    ```

- Tree Shaking 过程

  - foo 变量经过标记后，已经变成一段 Dead Code（ 不可能被执行到的代码 ），被 Shaking 掉
  - 得到结果（ bar.js ）

    ```
    const bar = 'bar';

    export { bar };
    ```

## 3. Tree Shaking 的最佳实践

#### 问题背景

- 虽然 Webpack 自 2.x 开始就原生支持 Tree Shaking 功能，但受限于 JS 的动态特性与模块的复杂性，直至最新的 5.0 版本依然没有解决许多代码副作用带来的问题，使得优化效果并不如 Tree Shaking 原本设想的那么完美
- 所以需要使用者有意识地优化代码结构，或使用一些补丁技术帮助 Webpack 更精确地检测无效代码，完成 Tree Shaking 操作

#### 优化导出值的粒度

- Tree Shaking 逻辑作用在 ESM 的 export 语句上，因此对于下面这种导出场景
  ```
  export default {
      bar: 'bar',
      foo: 'foo'
  }
  ```
- 即使实际上只用到 default 导出值的其中一个属性，整个 default 对象依然会被完整保留。所以实际开发中，应该尽量保持导出值颗粒度和原子性，上例代码的优化版本：

  ```
  const bar = 'bar'
  const foo = 'foo'

  export {
      bar,
      foo
  }
  ```

#### 避免无意义的赋值

- 使用 Webpack 时，需要有意识规避一些不必要的赋值操作，观察下面这段示例代码：
  ![image](https://img-blog.csdnimg.cn/1e94e967874d403ba048ceb8498bfa52.png)
- 示例中，index.js 模块引用了 bar.js 模块的 foo 并赋值给 f 变量，但后续并没有继续用到 foo 或 f 变量，这种场景下 bar.js 模块导出的 foo 值实际上并没有被使用，理应被删除
- 但 Webpack 的 Tree Shaking 操作并没有生效，产物中依然保留 foo 导出：
  ![image](https://img-blog.csdnimg.cn/9af2546f251e4b08a301d3122a838cd7.png)
- 造成这种现象的原因是：

  - 浅层原因：
    - Webpack 的 Tree Shaking 逻辑停留在代码静态分析层面，只是浅显地判断：
      - 模块导出变量是否被其它模块引用
      - 引用模块的主体代码中有没有出现这个变量
    - 没有进一步，从语义上分析模块导出值是不是真的被有效使用
  - 深层原因：

    - JavaScript 的赋值语句并不 “纯”，视具体场景有可能产生意料之外的副作用，例如

      ```
      import { bar, foo } from "./bar";

      let count = 0;

      const mock = {}

      Object.defineProperty(mock, 'f', {
          set(v) {
              mock._f = v;
              count += 1;
          }
      })

      mock.f = foo;

      console.log(count);
      ```

    - 示例中，对 mock 对象施加的 Object.defineProperty 调用，导致 mock.f = foo 赋值语句对 count 变量产生了副作用，这种场景下即使用复杂的动态语义分析也很难在确保正确副作用的前提下，完美地 Shaking 掉所有无用的代码枝叶

- 因此，在使用 Webpack 时开发者需要有意识地规避这些无意义的重复赋值操作

#### 禁止 Babel 转译模块导入导出语句

- Babel 是一个非常流行的 JavaScript 代码转换器，它能够将高版本的 JS 代码等价转译为兼容性更佳的低版本代码，使得前端开发者能够使用最新的语言特性开发出兼容旧版本浏览器的代码。
- 但 Babel 提供的部分功能特性会致使 Tree Shaking 功能失效，例如 Babel 可以将 import/export 风格的 ESM 语句等价转译为 CommonJS 风格的模块化语句，但该功能却导致 Webpack 无法对转译后的模块导入导出内容做静态分析，示例：
  ![image](https://img-blog.csdnimg.cn/ca8fe2331c9340a2a53fa4079ff423b5.png)
- 示例使用 babel-loader 处理 \*.js 文件，并设置 Babel 配置项 modules = 'commonjs'，将模块化方案从 ESM 转译到 CommonJS，导致转译代码(右图上一)没有正确标记出未被使用的导出值 foo。作为对比，右图 2 为 modules = false 时打包的结果，此时 foo 变量被正确标记为 Dead Code
- 所以，在 Webpack 中使用 babel-loader 时，建议将 babel-preset-env 的 moduels 配置项设置为 false，关闭模块导入导出语句的转译

#### 使用 #pure 标注纯函数调用

- 与赋值语句类似，JavaScript 中的函数调用语句也可能产生副作用，因此默认情况下 Webpack 并不会对函数调用做 Tree Shaking 操作。不过，开发者可以在调用语句前添加 \/\*#\_\_PURE\_\_\*\/ 备注，明确告诉 Webpack 该次函数调用并不会对上下文环境产生副作用，例如：
  ![image](https://img-blog.csdnimg.cn/2ecd1ebdf34140c99bd374d90da9af88.png)
- 示例中，foo('be retained') 调用没有带上 \/\*#\_\_PURE\_\_\*\/ 备注，代码被保留；作为对比，foo('be removed') 带上 Pure 声明后则被 Tree Shaking 删除

#### 使用 sideEffects 标记不存在副作用的模块

- 与 \/\*\#\_\_PURE\_\_\*\/ 注释类似，"sideEffects" 也可以标记不存在副作用的内容，与前者不同的是，它作用于模块层面
- "sideEffects" 是 package.json 的一个字段
  - 默认值为 true，表明这个模块有副作用，就算值没有被别的模块导入，也不删除
  - 如果你非常清楚你的 package 是纯粹的，不包含副作用，那么可以简单地将该属性标记为 false，来告知 webpack 可以安全地删除未被使用的代码（ Dead Code ）
  - 如果你的 package 中有些模块确实有一些副作用，可以改为提供一个数组
    ```
    // package.json
    {
      "name": "your-project",
      "sideEffects": ["./src/some-side-effectful-file.js"]
    }
    ```
- 尤其注意，在打包过程中，存在 CSS，Less 等文件类型的情况
  - css-loader 会将 CSS 文件转译为导出该文件中所有 CSS 规则集的 JS 模块
  - 而我们在 index 中并没有导入它的导出值，仅仅是简单的将其 import 进来，导致这个 ”CSS 模块“ 的导出值被标记为 unused，由于还被标记为无副作用，所以整个模块就被删除了
  - 因此，当项目中存在 CSS 文件时，我们就不能简单粗暴的将 sideEffects 标记为 false 了
- 举例
  - 存在模块 a，但并未被引用
    ```
    // a.js
    export function a(v) { reutrn v }
    console.log(a(1))
    ```
  - sideEffects 为 true 的情况，Tree Shrinking 之后，得到
    ```
    // b.js
    console.log(function (v){return v}(1))
    ```
    - 虽然 b 模块的导出是被忽略了，但是副作用代码被保留下来了
    - 而通常我们期望的是 b 模块既然不被使用了，其中所有的代码应该不被保留才对
  - 这个时候 sideEffects 的作用就显现出来了
    - 如果我们引入的 包/模块 被标记为 sideEffects: false 了，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除

#### 使用支持 Tree Shaking 的包

- 如果可以的话，应尽量使用支持 Tree Shaking 的 npm 包，例如：
  - 使用 lodash-es 替代 lodash ，或者使用 babel-plugin-lodash 实现类似效果
- 不过，并不是所有 npm 包都存在 Tree Shaking 的空间，诸如 React、Vue2 一类的框架原本已经对生产版本做了足够极致的优化，此时业务代码需要整个代码包提供的完整功能，基本上不太需要进行 Tree Shaking
