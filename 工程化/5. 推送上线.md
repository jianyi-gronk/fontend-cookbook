## 1. CI/CD 基础介绍（ [详情](https://zhuanlan.zhihu.com/p/422815048) ）

- CI/CD 是一种通过在自动化来频繁向客户交付应用的方法。CI / CD 的核心概念是持续集成、持续交付和持续部署。作为一种面向开发和运维团队的解决方案，CI / CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。 CI/CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控

#### CI 和 CD

1. CI 指的是持续集成
   它属于开发人员的自动化流程。成功的 CI 表明应用代码的新更改会定期构建、测试并合并到共享存储库中。这种方法可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题

2. CD 指的是 持续交付 和 持续部署
   这些相关概念有时会交叉使用，两者都关于管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度

（持续交付和持续部署都属于 CD，概念没有分的那么清晰，可以用来表示自动化程度，许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化）
![image](https://img-blog.csdnimg.cn/1105712ec19241f5a1cd4e186fd819da.png)

#### 持续集成

现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起，最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜
持续集成可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或主干中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误

【单元测试：是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块】
【集成测试：也叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试，因为一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来】

#### 持续交付

持续交付通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub 或容器注册表），然后由运维团队将其部署到实时生产环境中。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是确保尽可能减少部署新代码时所需的工作量
完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。
在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中

#### 持续部署

持续部署指的是自动将开发人员的更改从存储库发布到生产环境，以供客户使用。它主要为了解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化
对于一个成熟的 CI / CD 管道来说，最后的阶段是持续部署。作为持续交付（自动将生产就绪型构建版本发布到代码存储库）的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化
实际上，持续部署意味着开发人员对云应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI / CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI / CD 管道中的各种测试和发布阶段，因此前期投资还是会很大

#### 常用 CI / CD 工具

（公司可能用自己的 CI / CD 平台）

1. Jenkins，自动化服务器，从简单的 CI 服务器到完整的 CD 集线器，Jenkins 都可以处理
2. Tekton Jenkins 是一个面向 Kubernetes 平台的 CI / CD 框架，可通过容器为您提供标准的云原生 CI/CD 体验
3. Spinnaker，一个面向多云环境构建的 CD 平台
4. GoCD，一个侧重于建模和可视化呈现的 CI / CD 服务器
5. Concourse，一个开源的持续作业器
6. Screwdriver，一个面向 CD 设计的构建平台

此外，任何工具只要是 DevOps 的基本工具，就有可能属于 CI/CD 流程的一部分。用于配置自动化（如 Ansible、Chef 和 Puppet）、容器运行时（如 Docker、rkt 和 cri-o）以及容器编排（如 Kubernetes）的工具严格来说不算是 CI / CD 工具，但它们也现身于许多 CI / CD 工作流中

## 2. Jenkins

#### 基础介绍

- Jenkins 是一款开源的易于扩展的持续集成与持续部署（CI/CD）工具，用于自动化软件开发过程中的构建、测试和部署等任务。它支持多种版本控制系统（如 Git、SVN 等）和构建工具（如 Maven、Gradle、Ant 等），并且具有丰富的插件系统，可以轻松地扩展其功能
- 以下是 Jenkins 的一些主要特性：
  - 易于安装和配置：Jenkins 可以在各种操作系统（如 Windows、Linux、macOS 等）上安装，提供了基于 Web 的图形用户界面，方便用户进行配置和管理
  - 插件生态：Jenkins 拥有超过 1500 个插件，可以与各种开发、构建、测试和部署工具集成，满足不同项目的需求
  - 分布式构建：Jenkins 支持使用多个构建代理（Build Agent）进行分布式构建，可以提高构建速度和并行能力
  - 流水线（Pipeline）：Jenkins 支持编写声明式或脚本式的流水线配置（Jenkinsfile），用于定义整个 CI/CD 过程。流水线可以分为多个阶段（Stage），每个阶段可以包含一系列步骤（Step），如拉取代码、编译、测试、打包、部署等
  - 定时构建和触发机制：Jenkins 支持定时构建（如每天凌晨执行）或基于触发器的构建（如代码提交、其他任务完成等）
  - 用户管理和权限控制：Jenkins 提供了用户管理和角色授权功能，可以为不同用户分配不同的权限，确保项目的安全性
  - 监控和通知：Jenkins 支持实时监控构建过程，可以查看构建日志、测试报告等信息。此外，Jenkins 还可以配置通知机制（如邮件、Slack 等），在构建失败或成功时通知相关人员

#### 基础使用

1. 安装 Jenkins：首先，需要在服务器或本地计算机上安装 Jenkins，它支持各种操作系统，如 Windows、Linux 和 macOS。可以从 [Jenkins 官方网站](https://jenkins.io/download/)下载适合系统的安装包。按照官方文档的指南进行安装
   ```
   brew install jenkins-lts
   ```
2. 配置 Jenkins：安装完成后，启动 Jenkins 并访问其 Web 界面（默认地址为 http://localhost:8080）,根据提示输入初始密码，并完成安装向导。在安装向导中，您可以选择安装推荐的插件或根据项目需求手动选择插件
   - 启动 Jenkins
     ```
     brew services start jenkins-lts
     或
     /opt/homebrew/opt/openjdk@17/bin/java -Dmail.smtp.starttls.enable=true -jar /opt/homebrew/opt/jenkins-lts/libexec/jenkins.war --httpListenAddress=127.0.0.1 --httpPort=8080
     ```
   - 在首次访问 Jenkins 控制台时，会要求提供一个初始管理员密码（通常在 Jenkins 安装目录的 .jenkins/secrets/initialAdminPassword 文件中）
     ```
     在启动 Jenkins 时，其实会在命令行直接显示出来提示
     或
     sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword
     ```
3. 创建一个新的 Jenkins 任务：登录 Jenkins 后，点击 “新建任务”（New Item），输入任务名称，选择 “流水线”（Pipeline）类型，然后点击 “确定”（OK）
4. 编写 Jenkinsfile：在项目根目录下创建一个名为 Jenkinsfile 的文件。这个文件用于定义 CI/CD 流程。Jenkinsfile 可以使用声明式或脚本式的语法编写。以下是一个基本的 Jenkinsfile 示例，用于构建和测试一个基于 Node.js 的项目：
   ```
   pipeline {
       agent any
       stages {
           stage('Install dependencies') {
               steps {
                   sh 'npm install'
               }
           }
           stage('Build') {
               steps {
                   sh 'npm run build'
               }
           }
           stage('Test') {
               steps {
                   sh 'npm test'
               }
           }
       }
   }
   ```
5. 配置任务的源代码管理和触发器：在 Jenkins 任务的配置页面，滚动到“流水线”（Pipeline）部分。在“定义”（Definition）下拉菜单中选择“Pipeline script from SCM”。然后选择您的版本控制系统（如 Git、SVN 等），并输入仓库 URL。您还可以在“构建触发器”（Build Triggers）部分选择适当的触发器，例如 “轮询 SCM”（Poll SCM）或“GitHub hook trigger for GITScm polling”
6. 保存并触发构建：保存任务配置后，您可以点击“立即构建”（Build Now）手动触发构建。您也可以根据设置的触发器等待自动构建
7. 监控构建过程：在 Jenkins 任务页面，您可以查看构建历史、控制台输出和其他相关信息。这有助于您了解构建过程的详细情况并排查潜在问题
8. 配置部署（可选）：根据您的部署目标（如服务器、云平台等），您可以将部署脚本添加到 Jenkinsfile 中，部署脚本应在构建和测试成功后执行，例在 Jenkinsfile 中添加
   ```
   stage('Deploy') {
       steps {
           sshagent(['ssh-credentials-id']) {
               sh 'scp -r dist/ user@remote-server:/path/to/deploy'
               sh 'ssh user@remote-server "pm2 restart my-app"'
           }
       }
   }
   ```
   - 将构建好的 Node.js 项目部署到远程服务器：添加了一个名为 "Deploy" 的阶段，用于将构建好的项目（假设在 dist/ 目录下）通过 SCP 命令复制到远程服务器上，然后使用 PM2（一个 Node.js 进程管理器）重启应用
   - 注意，为了实现 SSH 访问远程服务器，此处使用了 sshagent 插件（请确保已在 Jenkins 中安装此插件）和预先配置好的 SSH 凭据

#### 细节内容总结

- Jenkins 可以运行在本地服务器，也可以运行在云服务器，并且一个 Jenkins 可以对应很多个项目，可以在 Jenkins 上集成各种插件，然后对不同项目进行不同配置
- 创建一个新的 Jenkins 任务（Job）时，可以选择任务类型（如 “自由风格项目” 或 “流水线”）
  - 对于“自由风格项目”，您需要在任务配置的“构建”部分添加构建步骤（如执行 shell 命令、运行 Maven 任务等）
  - 对于“流水线”类型的任务，您需要在项目的根目录下创建一个名为 Jenkinsfile 的文件，其中定义构建、运行和测试等操作。在任务配置的“流水线”部分，指定从源代码管理系统中检出 Jenkinsfile
- 简单来说，Jenkins 就是安装完之后，通过在 Web 图形用户界面上配置任务（Job），可以实现对托管在 GitHub、GitLab 等仓库里的项目代码进行自动或手动的构建、运行和测试。如何执行这些操作取决于项目根目录下的 Jenkinsfile（Pipeline（流水线） 类型的任务）或者任务配置中的构建步骤（自由风格项目类型的任务）
- 在 Jenkins 的 Web 界面中，可以执行以下操作：
  - 创建和管理任务：点击 "新建任务"（New Item）按钮来创建新的任务，或者点击现有任务的名称来查看和修改任务的配置
  - 配置插件和全局设置：点击左侧导航栏中的 "管理 Jenkins"（Manage Jenkins）链接，进入管理页面。在这里可以安装和管理插件、配置全局设置、管理安全策略等
  - 用户管理和权限控制：在 "管理 Jenkins" 页面中，可以找到 "管理用户"（Manage Users）和 "配置全局安全"（Configure Global Security）选项。这些选项允许管理用户、分配角色和权限
  - 查看构建历史和日志：在任务页面中，可以查看构建的历史记录、控制台输出和测试报告等信息。这有助于了解构建过程的详细情况并排查潜在问题
  - 手动触发构建：在任务页面中，可以点击 "立即构建"（Build Now）按钮来手动触发构建
- Jenkins 通常用于构建、运行和测试托管在 GitHub、GitLab 等代码仓库上的项目。虽然 Jenkins 也可以对本地项目进行构建、运行和测试，但这种做法在实际项目中较少使用，因为它不利于团队协作和版本控制
  - 步骤
    - 在 Jenkins 的 Web 界面中创建一个新任务（Job）
    - 在任务配置页面的“源代码管理”（Source Code Management）部分，选择“无”（None）。这意味着 Jenkins 不会从远程代码仓库检出代码
  - 使用 Jenkins 对本地项目进行构建、运行和测试的做法存在一定的局限性，例如无法自动触发构建、无法利用 Jenkins 插件对代码仓库进行操作等
- Jenkins 主要在远程代码仓库更新时执行操作，但也有其他触发器，以下是一些常见的 Jenkins 任务触发器：
  - 远程代码仓库更新：这是最常见的触发器，当远程代码仓库（如 Git、SVN 等）有新的提交或分支合并时，Jenkins 会自动拉取代码并执行预定义的任务，如构建、测试和部署等
  - 定时触发：可以为 Jenkins 任务配置定时触发器（使用类似于 cron 的语法），使任务在预定的时间间隔或特定时间点执行。这对于需要定期进行构建、测试或部署的项目非常有用
  - 手动触发：可以在 Jenkins 界面上为任务配置手动触发器，以便在需要时手动启动任务。这在需要临时执行特定任务或调试 Jenkins 配置时非常有用
  - 上游（Upstream）任务触发：如果项目中有多个相互依赖的 Jenkins 任务，可以配置任务触发器，使一个任务在其上游任务成功完成后自动执行。这有助于实现项目中的任务流水线（pipeline）
  - 使用 Webhooks：许多代码托管服务（如 GitHub、GitLab 或 Bitbucket 等）支持 Webhooks，可以配置 Webhooks 以在代码仓库发生特定事件（如新的提交、分支合并或发布等）时通知 Jenkins。这使 Jenkins 能够根据实际需求灵活地触发任务

## 3. commitlint

#### 基础介绍

- 是一个用于规范化提交消息格式的工具。它通过定义一套规则，帮助开发团队在提交代码时保持一致的提交消息风格。commitlint 可以与 Git 配合使用，确保每次提交都符合指定的规范。这有助于提高代码库的可读性和维护性，并方便查找和回溯代码变更历史

#### 使用步骤

1. 安装 commitlint
   - 这里使用了 @commitlint/config-conventional，它是 commitlint 提供的一个默认的规范配置，可以满足大部分项目的需求。如果有特定的需求，可以自定义配置
   ```
   npm install @commitlint/cli @commitlint/config-conventional --save-dev
   ```
2. 安装完成后，在项目根目录下创建一个名为 .commitlintrc.js 的文件，并将以下内容复制到文件中

   ```
   module.exports = {
     extends: ['@commitlint/config-conventional'],
   };
   ```

3. 接下来，在项目根目录下创建一个名为 commitlint.config.js 的文件，并将以下内容复制到文件中
   - 这里使用了 commit-msg 钩子，它会在每次提交消息时触发 commitlint 进行校验
   ```
   module.exports = {
     hooks: {
         'commit-msg': 'commitlint -E HUSKY_GIT_PARAMS',
        },
   };
   ```
4. 接下来可以在项目中使用 commitlint 了，在提交代码之前，commitlint 会检查你的提交消息是否符合规范。如果不符合规范，会给出相应的错误提示

## 4. husky

#### 基础介绍

- Husky 是一个开源的 Git 钩子（hooks）管理工具，它可以帮助开发者在 Git 代码版本控制中自动执行一些任务，例如在代码提交之前进行代码检查、格式化、测试等。Husky 的主要目的是确保代码库的代码质量，避免不合格的代码被提交到代码库中。Husky 通常与 lint 工具（如 ESLint、Prettier 等）一起使用，自动检查和修复代码风格问题

#### husky 和 Jenkins

- 区别
  - Husky 是在本地进行预处理的工具，在本地的 Git 仓库中起作用（在 CI 之前），用于在特定的 Git 操作（如提交、推送等）之前或之后执行自定义任务，例进行代码检查、格式化、测试等
  - Jenkins 是在代码推送后进行的自动化操作，在服务器上运行，用于自动构建、测试和部署应用程序
- 所以我们可以用 husky 去辅助 CI 过程，去确保开发者在提交代码之前对其进行检查、格式化和测试，从而保持代码质量并减少 CI 过程中可能出现的问题

#### 使用步骤

1. 安装 Husky
   ```
   npm install husky --save-dev
   ```
2. 初始化 Husky，这会在项目中创建一个 .husky 文件夹，并自动设置 Git 的 core.hooksPath 参数，使其指向该文件夹
   ```
   npx husky install
   ```
3. 添加 Git 钩子
   ```
   npx husky add xxx yyy
   ```
   - 在提交之前运行 npm test
     ```
     npx husky add .husky/pre-commit "npm test"
     ```
   - 在提交之前检查代码风格
     ```
     npx husky add .husky/pre-commit "eslint --fix"
     ```

## 5. GitHub Actions

#### 基础介绍

- GitHub Actions 和 Jenkins 都是常用的持续集成和持续部署（CI/CD）工具，但它们在一些方面有一些区别
  - 托管平台：
    - GitHub Actions 是由 GitHub 提供的一项服务，与 GitHub 仓库紧密集成
    - Jenkins 是一个独立的开源工具，可以在自己的服务器上部署和管理
  - 配置和使用：
    - GitHub Actions 的配置相对简单，使用 YAML 文件定义工作流程，并通过 GitHub 界面进行管理和触发
    - Jenkins 的配置相对复杂，需要通过 Jenkins 的界面进行配置和管理
  - 可视化界面：
    - GitHub Actions 的界面相对简洁，主要通过 YAML 文件进行配置，可视化界面相对较少（在提交完代码的 github 界面可以去查看）
    - Jenkins 提供了丰富的可视化界面，可以方便地查看和管理构建和部署任务
  - 插件和扩展性：
    - GitHub Actions 的操作库相对较少，但可以通过自定义操作来满足特定的需求
    - Jenkins 拥有大量的插件和扩展，可以满足各种不同的需求。它可以与各种工具和服务集成，并提供了丰富的自定义选项
  - 成本和维护：
    - GitHub Actions 是一个托管服务，使用起来相对简单，无需自行维护服务器
    - Jenkins 需要自行部署和维护服务器，需要考虑成本和资源管理
  - 社区和支持：
    - GitHub Actions 作为 GitHub 的一项服务，也有相当数量的用户和社区支持
    - Jenkins 是一个开源工具，拥有庞大的社区支持和活跃的开发者社区
- 开源项目中，一般会采用 GitHub Actions，而公司的项目中，一般会采用 Jenkins

#### 使用步骤

- 在编辑器中打开新建的 yml 文件（位于 .github/workflows/ 目录下），比如 vue.yml，node.yml
- 编辑 yml 文件以定义你的工作流程，比如 vue.yml

  ```
  name: Vue CI

  # 指定何时触发
  on:
    push:
      branches: [main]
    pull_request:
      branches: [main]
    schedule:
      - cron: '0 2 * * *'

  # 指定触发后的执行流程
  jobs:
    build:
      runs-on: ${{ matrix.os }}

      strategy:
        fail-fast: false
        matrix:
          node-version: [16, 19]
          os: [ubuntu-latest, windows-latest, macos-latest]

      steps:
        - name: Checkout Git Source
          uses: actions/checkout@v2

        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v1
          with:
            node-version: ${{ matrix.node-version }}

        - name: Install Dependencies
          run: npm install

        - name: Lint Project
          run: npm run lint

        - name: Build Project
          run: npm run build

  ```

- 之后在 github 提交代码的时候，就会自动触发了

## 6. SonarSource

#### 基础介绍

- SonarSource 是代码质量管理平台，静态代码分析的工具。提供代码分析和可视化功能，并可以与 CI/CD 工具集成。通过与 CI/CD 流程的集成，SonarSource 可以在代码提交、构建和部署过程中自动执行代码分析，并提供实时反馈和报告
- 便于及时检测和解决代码质量问题，确保交付的软件具有良好的质量和可维护

#### 可视化分析的部分

- 代码 Bug：
  - SonarSource 可以帮助开发人员发现代码中的 bug。它通过扫描代码，检查潜在的错误和问题，例如空指针引用、数组越界、未初始化的变量等。SonarSource 会给出警告或错误提示，帮助开发人员找到并修复这些问题，从而提高代码的质量和可靠性
- 代码异味：
  - 代码异味是指代码中存在的不规范、低效或容易出错的编码方式。SonarSource 可以检测出代码中的异味，并给出相应的建议和优化建议。例如，过长的方法、复杂的条件判断、重复的代码块等都属于代码异味 SonarSource 可以帮助开发人员识别这些问题，并提供相应的重构建议，以提高代码的可读性和维护性
- 代码重复度：
  - 代码重复度是指代码中存在的重复片段或模式。重复的代码会增加维护成本，并可能引入错误。SonarSource 可以分析代码，找出重复的代码片段，并给出相应的警告。开发人员可以通过重构来消除这些重复的代码，从而提高代码的可维护性和可读性
- 代码覆盖率：
  - 代码覆盖率是指测试用例对代码的覆盖程度。SonarSource 可以通过分析代码和测试用例的关系，计算代码的覆盖率。它可以告诉开发人员哪些代码没有被测试到，从而帮助他们提高测试用例的质量和覆盖率。通过提高代码的覆盖率，可以减少潜在的 bug 和错误
- 代码安全漏洞：
  - SonarSource 还可以检测代码中的安全漏洞。它可以识别出一些常见的安全问题，例如 SQL 注入、跨站脚本攻击、密码泄露等。SonarSource 会给出相应的警告和建议，以帮助开发人员修复这些安全漏洞，从而提高代码的安全性和可靠性
