## 1. 应用架构设计模式（ [详情](https://zhuanlan.zhihu.com/p/140071889) ）

- MVC，MVP，MVVM 一直都是 GUI 领域常见的设计模式，这三个模式每个都在各自独特的领域独占一方。例如 MVC 一直都是一些后端应用框架标榜的设计模式，而安卓应用开发更多在使用 MVP 设计模式，而 MVVM 的思想或者 MVVM 的变体一直活跃在现在 Web 前端开发框架中

## 2. MVC（ Model-View-Controller ）

![image](https://img-blog.csdnimg.cn/aba7fe36ce0c47fb95da0be2596d0ede.png)

- MVC 主要用于分离应用程序的数据、展示和控制逻辑
  - Model（模型）：表示应用程序的数据结构和业务逻辑，负责数据的存储和处理
  - View（视图）：负责数据的展示，通常是用户界面
  - Controller（控制器）：负责处理用户输入，以及协调 Model 和 View 之间的交互
- MVC 这个设计模式可以说是一个很老的技术了，最早在 1978 被提出来，现在主要活跃在 Web 领域，尤其在后端代码对页面渲染这一块上，其中，在 Java 中的 SpringMVC 尤为著名
- 如上面，MVC 中，Model 模型代表者后端代码中的业务模型抽象，表意范畴比较大，可以是 DDD 领域模型，服务等，也可以是一些具体的组件和类，例如 Book 对象等，甚至是一些“事物脚本”中的事物对象。因为 MVC 只是一种设计模式，一种分层模型，跟代码架构不冲突，代表着后端的业务模型
- 而 Controller 控制器就相当于一个分发的工具，熟悉 Spring 的人知道这就是 Spring 中的 @Controller，一个请求进来，需要什么样的 Model，获取什么样的数据，返回什么样的页面，都是 Controller 的工作
- View 则负责 UI 渲染工作，传统的 MVC 中，一个 View 就是一个 Web 页面，通常还有有 Javascript 代码在其中负责一些页面逻辑
- Model 模型表示着业务逻辑和数据，模型把这些数据逻辑渲染到 View 中，比较常见的做法是后端的模版技术，例如 jsp 之类的，把预期的数据填入 jsp 模版中，返回给浏览器。当然，像现在的 restful 应用中，前端都为 SPA 单页面应用，那么 api 返回的 json 数据也相当于为 View
- 一般来说，MVC 中的数据流动是单向的，Model 用数据来渲染 View，View 用户界面交互完成后更新数据，然后 Controller 做分发和控制。但是从交互的角度来看并不是单向的，如上图中的红线，Controller 当收到更新数据请求的时候，Controller 会更新数据，更新完就会重定向到的 View ，View 拿到更新完的 Model 数据，进行渲染，Controller 多充当了一个调度者的角色

## 3. MVP（ Model-View-Presenter ）

![image](https://img-blog.csdnimg.cn/6690113ade5c41ce8a2c4cc91ef32363.png)

- MVP 是一种将视图和业务逻辑进一步解耦的设计模式
  - Model（模型）：表示应用程序的数据结构和业务逻辑，负责数据的存储和处理
  - View（视图）：负责数据的展示，通常是用户界面
  - Presenter（表现者）：负责处理业务逻辑和协调 View 和 Model 之间的交互
- MVP 模式属于 MVC 的变体，这个设计模式在安卓开发上比较常见，如上图所示，Presenter 跟 View 层交互，完全阻隔了 Model -> View 或 View -> Model 的数据流。 Presenter 负责将一个或多个 Model 的数据组装起来，返回给 View 界面，同时 View 界面的一些交互，验证等逻辑操作都委托给 Presenter，Presenter 负责更新数据或者发送 Api 请求等，View 专注于界面和人机交互，更能清楚划分层的职能
- 一般来说，MVP 架构中，一个 View 对应一个 Presenter，这跟 MVC 中的 Controller 不同，因为 Controller 负责分发请求，一个 Controller 可能会对应多个 View，从这点上看，在 MVP 模式中，Presenter 跟 View 的关系更密切一些，Presenter 更像是一个操控 View 的角色，View 则是像傻鸭子一样，没有自己的思想，只负责 UI 和交互，被 Presenter 操控着，这样做更能够分离职责
- MVP 虽然于 MVC 在思想上差不了多少，但是从这两种设计的定位上看，有很大的区别。首先，MVP 属于纯客户端的设计，MVC 中的 Model 和 Controller 都是属于服务器端的

## 4. MVVM（ Model-View-ViewModel ）

![image](https://img-blog.csdnimg.cn/452b7a667ae0423fac2da8a1ecb5f263.png)

- MVVM 是一种主要用于前端开发的设计模式，特点是通过双向数据绑定将视图和数据模型连接起来
  - Model（模型）：表示应用程序的数据结构和业务逻辑，负责数据的存储和处理
  - View（视图）：负责数据的展示，通常是用户界面
  - ViewModel（视图模型）：充当视图和模型之间的桥梁，负责处理视图的逻辑和数据模型的更新
- MVVM 模式 (Presentation Model）设计模式的变体。MVVM 以 MVP 相同的方式抽象出视图的状态和行为。MVVM 是 Model-View-View Model 的缩写，相比 MVP，MVVM 简化了 Presentation 这个模型，只用了 Model-View 来衔接 Model 和 View 之间的通信
- MVVM 模式的亮点是 Mode 和 View Model 之间实现了双向绑定，这一点也确实可以说是划时代，解决了当时很多状态同步的问题，如上图，在这种模式下，开发者可以专注开发 View 和 Model 的内容，省去了同步 UI 和 Javascript 数据的繁琐
- 只有 MVVM 实现了双向流，通过双向数据绑定将 View（视图）和 Model（数据模型）连接起来。这意味着当视图中的数据发生变化时，数据模型会自动更新；相反，当数据模型发生变化时，视图也会自动更新。这种双向数据流简化了视图和数据模型之间的交互，使得数据状态的管理变得更加容易。MVVM 主要应用于前端开发，如 Angular 和 Vue 等框架

## 5. Controller，Presenter 和 ViewModel

- 三者都是为了解藕 Model 和 View，，使得应用程序的各个部分更加独立、可测试和可维护。通过将应用程序划分为不同的层次，这些设计模式有助于提高代码的模块化和可重用性
- Controller（控制器）： 它负责处理用户操作，协调视图（用户界面）和数据模型之间的交互。Controller 直接与视图和数据模型进行通信，可能导致它们之间的关系较为紧密。在 MVC 中，Controller 处理大部分视图操作业务和展示业务逻辑
- Presenter（展示器）：它负责协调视图（用户界面）和数据模型之间的交互，但让它们遵循一个固定的流程。这样，当需要改变流程时，只需要修改 Presenter，而不需要改变视图和数据模型。这使得视图和数据模型之间的关系相对松散，更容易进行独立的测试和维护
- ViewModel（视图模型）：它在视图（用户界面）和数据模型之间充当中介，实现它们之间的解耦。ViewModel 将数据模型中的数据转换为视图可以理解的格式，并处理视图中的操作，将其转换为数据模型可以处理的指令。此外，ViewModel 支持双向数据绑定，可以自动将视图中的变化更新到数据模型中。在 MVVM 中，ViewModel 主要负责展示的业务逻辑

- 通俗解释，有一群学生（View），在音乐（Model）
  - Controller 类似于教练，需要时刻关注学生和音乐，需要根据不同的学生，调节音乐，根据不同的音乐，指挥学生，担任的任务更加全面，包括了很多的业务逻辑
  - ViewModel 类似于翻译，将音乐组装成对应的学生能理解的乐谱，学生需要什么音乐，就直接根据需求切音乐就行。简化甚至剔除了业务逻辑，主要的工作就只是把 Model 中的数据组装成适合 View 使用的数据
  - Presenter 类似于机器人，学生只能根据一种形式切换音乐，音乐只能通过一种固定形式影响学生训练，如果需要不同交互方式，则需要换一个机器人

## 6. Flux（ [详情](http://fluxxor.com/what-is-flux.html) ）

- Flux 的核心思想是单向数据流。数据总是从 View 到 Action，再到 Dispatcher，然后到 Store，最后回到 View。这种单向数据流使得应用程序更容易理解和调试
- Flux 是一种用于构建客户端 Web 应用程序的架构设计模式，由 Facebook 开发。Flux 旨在解决单向数据流的问题，使得应用程序的数据流更加清晰、可预测和易于维护。Flux 主要包括以下几个部分：
  - Dispatcher（调度器）：它是整个应用程序的中央枢纽，负责管理所有的数据流。当一个动作被触发时，Dispatcher 会将动作分发到所有已注册的回调函数，这些回调函数通常是 Store 中定义的
  - Actions（动作）：动作是用来描述发生在应用程序中的事件的对象。它们通常包含一个描述事件类型的属性（例如，'ADD_ITEM'）以及与事件相关的任何数据。动作通常通过调用 Action Creator（动作创建器）函数来创建，并通过 Dispatcher 分发到 Store
  - Store（存储）：Store 包含应用程序的状态和逻辑。它们负责处理 Dispatcher 分发的动作并更新应用程序的状态。当 Store 的状态发生变化时，它会通知已注册的视图组件，让它们根据新的状态重新渲染
  - View（视图）：视图是应用程序的用户界面，通常是 React 组件。视图订阅 Store 的更改事件，并在状态发生变化时重新渲染。视图还可以触发动作，从而改变应用程序的状态

## 7. 总体前端设计模式趋势

- MVC, MVP, MVVM，FLUX 这四种模式是按顺序出现的，其实也代表着一些趋势的变化，一开始 MVC 中的 Model 和 View 和 Controller 是十分临近的，整个模式是偏服务端的，到 MVP，MVVM，这两个设计模式属于纯前端了，Model 的重要性也开始有一点降低，更多重点开始转移到 View 中。到 Flux，已经彻底转移了 Model 的概念，前端中不再包含领域模型的逻辑和概念，前端只有数据模型和 UI 模型，数据都放在 Reducer 中处理，这里面的数据基本上都是展示数据，也不涉及领域模型，而 View 和 Component 关注的事也只是 UI 和交互而已，可以说，到 Flux 这种设计模式，前端已经开始独立化了，职责也更分明，也跟现在社区“大前端”所契合
