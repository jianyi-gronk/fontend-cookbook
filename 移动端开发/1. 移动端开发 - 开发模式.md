## 1. 移动端开发模式

#### 1.1 常见开发模式

- Native 原生开发：
  - 使用平台提供的原生开发工具和语言，如 IOS 的 Objective-C（ 简称 OC，主要用于苹果公司的 OS X 和 IOS 操作系统的应用程序开发，在苹果公司推出 Swift 编程语言之前，Objective-C 一直是苹果平台上主要的应用程序开发语言之一 ）和 Swift，Android 的 Java 和 Kotlin 等
- Hybrid 混合开发：
  - 使用原生开发和 Web 技术的混合模式
  - 基于 WebView 控件以全屏格式呈现 HTML，CSS 和 JavaScript 文件，同时使用原生代码实现一些高性能和特定平台的功能
  - 换句话说，它是包装在原生移动容器内的网页
- Cross-Platform 跨平台开发（ 跨端开发 ）：
  - 使用一种跨平台的开发框架，如 React Native、Flutter 等，可以在不同的移动平台上使用相同的代码进行开发，从而减少开发成本和维护成本
- Mobile Web 开发：
  - 使用标准的 Web 技术，如 HTML、CSS 和 JavaScript 进行移动端开发，可以在不同的移动设备上通过浏览器访问
- PWA 开发：
  - PWA（ Progressive Web App ）是一种特殊类型的移动 Web 应用程序，它利用了现代 Web 技术的优势，为用户提供了类似于原生应用程序的体验。PWA 可以在浏览器中安装并脱机工作，具有更快的加载速度和更好的用户体验

#### 1.2 开发模式优缺点

- Native 原生开发：
  - 优点：
    - 性能优越，可以充分利用设备的硬件资源
    - 用户体验好，可以提供与原生应用程序相同的用户体验
    - 可以访问平台的原生 API，实现更丰富的功能
  - 缺点：
    - 开发成本高，需要针对不同的平台进行开发
    - 维护成本高，需要针对不同的平台进行维护和更新
- Hybrid 混合开发：
  - 优点：
    - 开发效率高，可以使用 Web 技术进行开发，同时可以利用原生代码实现一些高性能和特定平台的功能
    - 可以跨平台运行，只需要开发一次，就可以在不同的平台上运行
    - 可以访问平台的原生 API，实现更丰富的功能
  - 缺点：
    - 用户体验可能不如原生应用程序好，因为需要通过 WebView 加载 Web 页面
    - 性能可能不如原生应用程序好，因为需要在原生代码和 Web 代码之间进行通信
- Cross-Platform 跨平台开发（ 跨端开发 ）：
  - 优点：
    - 开发效率高，可以使用一种跨平台的开发框架，如 React Native、Flutter 等，在不同的平台上使用相同的代码进行开发
    - 可以跨平台运行，只需要开发一次，就可以在不同的平台上运行
    - 用户体验好，可以提供与原生应用程序相同的用户体验
  - 缺点：
    - 性能可能不如原生应用程序好，因为需要在不同的平台上进行适配
    - 可能无法访问平台的某些原生 API，实现某些功能可能会受到限制
- Mobile Web 开发：
  - 优点：
    - 开发效率高，可以使用标准的 Web 技术进行开发，无需学习特定平台的开发技术
    - 可以跨平台运行，只需要开发一次，就可以在不同的移动设备上通过浏览器访问
    - 维护成本低，只需要维护一个 Web 应用程序，无需针对不同的平台进行维护和更新
  - 缺点：
    - 用户体验可能不如原生应用程序好，因为需要通过浏览器加载 Web 页面
    - 可能无法访问平台的某些原生 API，实现某些功能可能会受到限制
- PWA 开发：
  - 优点：
    - 用户体验好，可以提供与原生应用程序相同的用户体验，如快速加载、离线访问等
    - 可以跨平台运行，只需要开发一次，就可以在不同的平台上运行
    - 可以通过浏览器或应用商店进行安装，无需通过应用商店进行审核
  - 缺点：
    - 开发成本高，需要使用一些新技术进行开发，如 Service Worker、Web Push 等
    - 可能无法访问平台的某些原生 API，实现某些功能可能会受到限制

#### 1.3 混合开发 和 跨端开发 的区别

- 两者都可以使用 HTML、CSS 和 JavaScript 等 Web 技术来构建应用程序的大部分界面。并且都可以通过 JavaScript 与原生平台进行通信，以实现一些特定的功能，如访问设备硬件、处理本地文件等。因此非常容易弄混这两者
- 如何区分
  - Hybrid 混合开发：**完全依赖原生 App 中的 WebView 组件**，本质上只是对 WebView 组件做更多的扩展，为它提供更多的 api，Web 技术只是起到补充作用，**由原生做主导**
  - 跨端开发：**由 web 做主导**，编译转成原生 Native APP 的 Objective-C 或 Java 代码

#### 1.4 几种开发模式的联系

- Native 开发 用户体验和性能好，但开发和维护成本高，Web 开发 用户体验和性能差，但开发和维护成本低
- 而混合开发和跨端开发就是融合了这两者的优点

## 2. Hybrid 混合开发原理

#### 2.1 基础介绍

- 浏览器本就是一个跨端实现方案，因为只需要输入网址，就能在任何端的浏览器上打开你的网页
- 如果把浏览器嵌入 app 中，再将地址栏等内容隐藏掉，是不是就能将网页嵌入原生 app 了。而这个嵌入 app 的浏览器，称之为 webview，所以只要某个端支持 webview ，那么它就能使用 Hybrid 混合开发

#### 2.2 WebView

- WebView 是一个基于 webkit 的引擎，可以解析 dom 元素，展示 html 页面，执行 JS 脚本的控件，它和浏览器展示页面的原理是相同的，所以可以把它当做浏览器看待（ chrome 浏览器也是基于 webkit 引擎开发的，Mozilla 火狐浏览器是基于 Gecko 开发的 ）
- 该组件是运行自己浏览器或者在你的线程中展示线上内容的基础。使用 Webkit 渲染引擎来展示，并且支持前进后退等基于浏览历史，放大缩小，等更多功能
- 简单来说 WebView 是手机中内置了一款高性能 Webkit 内核浏览器，在 SDK 中封装的一个组件。不过没有提供地址栏和导航栏，只是单纯的展示一个网页界面
- WebView 可以简单理解为页面里的 iframe。原生 app 与 WebView 的交互可以简单看作是页面与页面内 iframe 页面进行的交互。就如页面与页面内的 iframe 共用一个 Window 一样，原生与 WebView 也共用了一套原生的方法
- Android WebView
  - Android 4.4 前：
    - Android WebView 在低版本和高版本采用了不同的 Webkit 版本的内核
    - 正因为如此，H5 的很多新特性，在 Android 版本小于 4.4 的安卓机上，都不支持
  - Android 4.4 后：
    - 原本基于 Webkit 的 WebView 开始基于 Chromium 内核，这一改动大大提升了 WebView 组件的性能以及对 HTML5, CSS3, JavaScript 的支持
    - 不过它的API却没有很大的改动，在兼容低版本的同时只引进了少部分新的API，并不需要做很大的改动
- IOS WebView
  - 在 IOS2 到 IOS7 之间，苹果手机的 WebView 使用的 UIWebView，UIWebView 长期以来存在某些问题：
    - 加载速度慢
    - 存在内存泄漏
    - 内存占用多，内存优化困难
    - 如果内存占用过多还可能因为占用过多被系统杀掉
  - 在 WWDC 2014 大会上，IOS8 推出了 WKWebView
    - WKWebView 是现代 Webkit API 在 iOS 8 和 OS X Yosemite 应用中的核心部分
    - 它代替了 UIKit 中的 UIWebView 和 AppKit 中的 WebView，提供了统一的跨双平台 API
    - 拥有 60fps 滚动刷新率、内置手势、高效的 app 和 web 信息交换通道、和 Safari 相同的 JavaScript 引擎

#### 2.3 JSBridge

- 既然使用了 WebView 来承载 H5，那么便少不了与 Native 之间发生交互，WebView 所承载的页面，通过 JS 与 Native 进行通信，这个通信的桥梁即为 JSBridge
- JSBridge 简单来讲，主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用地址位置、摄像头甚至支付等 Native 功能
- JSBridge 核心是构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道
  - JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等
  - Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等
- JavaScript 是运行在一个单独的 JS Context 中（ 例如，WebView 的 Webkit 引擎、JSCore ）。由于这些 Context 与原生运行环境的天然隔离，可以将这种情况与 RPC（ 远程过程调用 ）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用

## 3. 跨端开发（ 以 React Native 为例 ）

#### 3.1 基础介绍

- RN 主要有三个重要组成模块：平台层（ Android 或者 OC 环境），桥接层（ C++ ）和 JS 层
  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e01a82f7d174e67b8be4d47487d2c45~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1100&h=926&s=682019&e=png&b=fefcfc">
  - 平台层负责原生组件的渲染和提供各式各样的原生能力，由原生语言实现
  - 桥接模块负责解析 JS 代码，JS 和 原生平台（ Java/OC 代码 ）相互调用，由 C++ 语言实现
  - JS 层负责跨端页面具体的业务逻辑
- 相比起 Webview 的结构来说，RN 的结构多了一层桥接层，也就是 C++ 层

#### 3.2 桥接层（ C++ 层 ）

- 桥接层包括 JSCore、Native 模块、JavaScript 模块
- JSCore
  - React Native 和 H5 一样，使用了 JS 作为跨端页面的开发语言，因此它必须要有一个 JS 执行引擎，而在使用 H5 的情况下，WebView 是 JS 的执行引擎，同时 WebView 还是页面的渲染引擎
  - RN 不一样的地方在于，已经有了自己的渲染层，这个功能交给了原生组件，因为 RN 的 JS 组件代码最后都会渲染成原生组件。因此 RN 只需要一个 JS 执行引擎来跑 React 代码
- Native 模块和 JavaScript 模块
  - 说起通信的话，整个过程肯定存在信源和信宿，也就是消息的发送者和接收者，在 RN 的通信中，它们是 Native 和 JS 的模块，它们向对方提供能力都是以模块为功能单位的，类似 JSBridge 协议中的 ModuleID 的概念
  - Native 模块在 Android 系统下是 Java 模块，由平台代码实现，JS 通过模块 ID（ moduleID ） 和方法 ID（methodID） 来进行调用，可以给 RN 页面开放原生系统的能力，如计时器的实现模块 Timing，给 JS 代码提供计时器的能力
  - JavaScript 模块是由 JS 实现，对 Java 环境来说，作用是提供操作 JS 环境的 API，如回调，广播等
- JS 环境中会维护一份所有 Native 模块的 moduleID 和 methodID 的映射 NativeModules，用来调用 Native 模块的时候查找对应 ID；Java 环境中也会维护一份 JavaScript 模块的映射 JSModuleRegistry，用来调用 JS 代码。而在实际的代码中，Native 模块和 JS 模块的通信需要通过中间层也就是桥接层的过渡，也就是说 Native 模块和 JS 模块实际上都只是在和 桥接 模块进行通信

#### 3.3 如何通信

- JS 层如何和桥接层通信
  - JS 代码会在 global 对象中注入一些原生模块需要的 API，而 JSCore 可以让 桥接层 拿到 JS 运行环境的 global 对象并能操作它的属性。通过 NativeModules 的映射，开发者能拿到调用模块和方法的 moduleID 和 methodID ，在调用过程中会映射到具体的 Native 的方法
- 桥接层如何和原生层通信（ 以安卓为例 ）
  - Java 跟 桥接层 的互相调用通过 JNI（ Java Native Interface ），通过 JNI，桥接层 会暴露出来一些 API 来给 Java 层调用，来让 Java 能跟 JS 层进行通信
- 简单来说，RN 初始化的时候就已经形成了映射表，并且往 JS 环境注入了一些 API，Java 模块和 JS 模块可以通过 NativeModules 和 JS 回调函数互相调用，来达成一次跨端调用

## 4. PWA 基础介绍

#### 4.1 什么是 PWA

- 渐进式 Web 应用（ Progressive Web App ），简称 PWA，是 Google 在 2015 年提出的一种使用web平台技术构建的应用程序，官方认为其核心在于 Reliable（ 可靠的 ）、Fast（ 快速的 ）、Engaging（ 可参与的 ），结合了 web 网站程序和原生应用程序两者的优点，可以带给用户更佳的使用体验
- PWA 既能像网站一样，通过一套代码在多个平台运行，而且可以通过浏览器进行访问，并通过 Url 链接进行分享。又能像原生应用一样，通过应用商店或网页安装在设备上，安装之后可以通过图标访问，作为一个独立的应用程序被启动。而且即使脱离网络，也可以通过应用缓存访问到部分页面和数据
- 但需要注意的是，当 PWA 应用通过安装在设备上的图标打开时，虽然从外观上看来像是一个原生的应用程序，但从技术角度来看，其仍属于网站范畴，所以仍需要一个浏览器引擎来解析和运行，为其提供正常运行的环境。因此其原理类似于打开了一个单独的、自定义窗口内容的浏览器窗口
- PWA不仅是一种技术，更代表了一种 Web 网站的开发理念，如果一个网站程序实现了可安装、可离线等多种特定功能，我们就可以将其视为一个 PWA 应用。目前国内支持 PWA 的网站有：微博、语雀等等
  <img src="https://img-blog.csdnimg.cn/45e9a9d5ca2045aeb43321f06e08e1ae.png#pic_center"/>

#### 4.2 PWA 特点

- 原生应用程序代表了最佳的功能，因为其与操作系统深入结合，拥有易于访问、可离线、操作系统集成等优点。Web 网站程序则代表了最广的范围，因为其以浏览器为基础，拥有跨平台、无需下载、易于更新部署等优点。而 PWA 则处于原生应用程序功能和 Web 网站程序范围的交叉点，是两者的结合体，主要拥有以下几种特点：
  - 跨平台：PWA 应用只需开发者书写一套代码，就可以在不同操作平台上运行，而且 PWA 应用采取渐进式增强的理念，其核心功能可以在任何浏览器上正常运行，其余强大的功能则需要依赖于浏览器对 PWA 特性的支持，根据浏览器的支持性，逐步升级体验
  - 可安装：PWA 应用可以添加到主屏幕或应用程序菜单中，实现类似原生应用的图标入口，点击图标，作为一个独立应用被启动，用户可以更方便地访问应用。也可以将程序打包并上传各个应用商店，让用户通过应用商店安装网站应用
  - 离线访问：PWA 应用具备离线访问的能力，它们可以缓存应用的核心资源，使得用户可以在没有网络连接的情况下继续访问应用，查看到部分页面和数据，提供基本的功能，并在网络恢复时更新缓存
  - 推送通知：PWA 应用可以主动发送推送通知给用户，使得应用可以及时通知用户有关重要更新、新消息或其他关键信息，类似于原生应用的通知功能
  - 快速加载：PWA 应用使用 Service Workers 来缓存资源并提供离线体验，这也使得应用可以更快地加载和响应用户操作
  - 可搜索： PWA 应用可以通过搜索引擎被发现，而且可以通过 url 链接进行分享
  - 热更新： PWA 应用中的部分内容发生更新时，可在联网后自动进行局部热更新，确保用户能用到最新的应用程序，而无需像原生应用一样，重新下载安装客户端
- 结合官方提出的 Reliable（ 可靠的 ）、Fast（ 快速的 ）、Engaging（ 可参与的 ）三个核心
  - 跨平台、离线访问体现了Reliable（ 可靠的 ），无论是在低版本浏览器还是无网络的情况下，PWA都可以展示基本功能
  - 快速加载、热更新则体现了Fast（ 快速的 ），利用缓存和自动更新，减少重复数据加载，提升响应速度
  - 可安装和推送通知则体现了Engaging（ 可参与的 ），可安装在设备上，并向用户推送通知

#### 4.3 适用场景

- 地图导航、资料文档、博客笔记等等

#### 4.4 PWA 的核心技术

- PWA 的实现依赖于多种技术实现，其中最核心的技术为 Service Worker、Web App Manifest 和 Push Notification
- Service Worker
  - Service Worker 是一个独立于网页线程的脚本，无权访问页面的 DOM 结构，充当了网站和浏览器之间的代理服务器，每个 PWA 应用都只能注册一个 Service Worker，其在 PWA 中主要用来实现离线访问、缓存资源、推送通知等功能，当然除此之外，它还具有很多其他功能
  - 在网络正常时，当 PWA 应用请求 Service Worker 范围内的资源时，Service Worker 会拦截该请求，并充当网络代理，然后它可以决定是从缓存中获取数据还是从服务器中获取数据。如果是从服务器中获取数据，Service Worker 会缓存请求的数据，等到离线访问时，返回缓存的数据，使得PWA应用可以在离线状态下运行，并且可以利用缓存提升应用的加载速度
  - 由于 Service Worker 权利太大，能够直接截取并返回用户的请求，处于安全性考虑，目前仅支持在 HTTPS 或本地环境的安全环境下使用
- Web App Manifest
  - Web App Manifest（ Web 应用清单 ），是一个遵守 W3C 规范的 JSON 文件，用来定义 PWA 安装的客户端在设备上应该如何显示和运行，例如应用的名称、图标、启动方式等等，该文件是实现 PWA 所必需的。通过该文件，用户可将 PWA 应用安装到用户的主屏幕上，使其更像一个原生应用的客户端
  - 该文件中可定义的应用信息很多，其中比较常用的有以下几条：
    - name
      - 该字段定义 PWA 应用的全名，是 Web App Manifes 中必须的一个基本字段。该名称一般会显示为应用商店的应用名称，也会在应用启动时显示在标题栏中
    - short_name
      - 该字段定义 PWA 应用的简称，尽量控制在 12 个字符以内，当应用程序被安装在桌面上时，由于空间有限，通常就会显示该简称，但具体展示 name 还是 short_name 可能因设备、浏览器或操作系统而有所不同
      - 例如：在 macos 系统中，统一展示 name 字段
    - icons
      - 该字段定义了应用程序安装在桌面上的图标，属性值为一个数组，数组元素为一个对象，对象中包含 src、sizes、type 三个属性，分别代表图标地址、图标的尺寸和图标的 MIME 类型
        - src：指定了图标文件的位置，字段值可以是相对于 manifest 文件的相对 URL，或者是一个绝对的网络 URL
        - sizes：指明了图标的尺寸，以宽 × 高的形式指定了图标的宽高，单位默认为 px，目前设备适配性最好的图标尺寸为 512×512
        - type：指明了图标的 MIME 媒体类型，帮助浏览器在选择合适的图标文件，例如：image/png、image/jpeg 等等
      - 该字段属性值数组至少需要定义一个图标元素，也可以定义多个不同格式的图标元素，从而为用户提供最佳的图标效果。每个浏览器都会根据其需要和所安装的操作系统选择其中最接近其所需的规范的某个图标。图标选择规则很多，主要有尺寸匹配、类型匹配、设备类型匹配等规则
    - start_url
      - 该字段定义 PWA 应用的起始 URL，用户点击图标打开程序时，将会加载这个 URL 所对应的页面，可以是相对于 manifest 文件的相对路径，也可以是一个绝对路径。推荐使用绝对路径，如果 PWA 应用的主页是网站的根目录，那么将该字段设置为 / 即可。如果没有设置该字段，则默认将安装 PWA 应用时的 URL 作为该字段的值
    - display
      - 该字段定义了 PWA 应用的打开方式，字段值有以下四种：
        - standalone（ 推荐 ）：应用将以独立窗口打开，类似于原生应用程序，没有导航栏等浏览器功能
        - fullscreen：应用将以全屏模式打开，隐藏浏览器的地址栏和工具栏
        - minimal-ui：应用将独立窗口打开，但保留了一部分浏览器的导航功能，如后退、刷新功能等
        - browser：应用将以常规浏览器网页的形式打开，类似于设置了一个网页的快捷方式
    - id
      - 该字段用于作为PWA应用的唯一标识，如果未设置，则默认以 start_url 的值为字段值
    - background_color
      - 该字段定义了 PWA 应用窗口打开后且样式表加载完成之前的窗口背景色，字段值支持关键字（ red、green 等 ）、十六进制色值（ #FFFFFF、#CCCCC 等 ）和 RGB 色值（ rgb(255,255,255) 等 ），但不建议使用rgba() 等带有透明度的颜色，因为各个浏览器的展示效果可能大相径庭。但是目前 iOS 和 iPadOS 上的 Safari 以及部分桌面浏览器目前会忽略此字段
    - theme_color
      - 该字段定义了 PWA 应用的窗口主题色，将会影响窗口工具栏、头部标题栏等区域的颜色，段值支持关键字（ red、green 等 ）、十六进制色值（ #FFFFFF、#CCCCC 等 ）和 RGB 色值（ rgb(255,255,255) 等 ）。但是该属性会被 \<meta name="theme-color" content="#ccc"\> 标签设置的主题色所覆盖
    - 其他属性
- Push Notification
  - Push 和 Notification是两个独立的 API，Push 用来接收服务器推送的信息，Notification 用来向用户推送信息。两者都需要在 Service Worker 内调用运行
