## 1. 什么是 V8 引擎

[认识 V8 引擎](https://zhuanlan.zhihu.com/p/27628685)，[V8 引擎简介](http://www.noobyard.com/article/p-eqhoelet-hp.html)

- V8 是由 Google 开发的高性能 JavaScript 引擎，它是 Chrome 浏览器和 Node.js 运行时的核心组件。V8 引擎负责解释和执行 JavaScript 代码，并将其转换为计算机可执行的机器码。它是一个开源项目，使用 C++ 编写，旨在提供快速且高效的 JavaScript 执行能力
- 以下是 V8 引擎的主要特点和功能：
  - 即时编译（ Just-In-Time Compilation，JIT ）：V8 采用了即时编译技术，将 JavaScript 代码转换为本地机器码，从而实现更高的执行速度。它使用了基于代码的优化技术，如内联缓存、行内缓存、快速属性存储等，以提高代码的执行效率
  - 垃圾回收（ Garbage Collection ）：V8 引擎自动管理内存分配和释放，它采用了分代式垃圾回收算法，根据对象的生命周期将内存分为新生代和老生代，并使用不同的垃圾回收策略来优化内存性能
  - 异步编程支持：V8 引擎支持异步编程，包括 Promise、async/await 等功能，使得处理异步任务更加高效和便捷
  - 原生绑定（ Native Bindings ）：V8 允许通过 Node.js 的 C++ 插件，使得可以在 JavaScript 中调用本地的底层功能，从而提高性能和灵活性（ 除了 V8 还有 其他绑定方式将 C++ 代码与 JavaScript 交互 的方法）
  - ES6 和更高版本支持：V8 引擎持续跟进 ECMAScript 标准的更新，对 ES6 及更高版本的 JavaScript 语法和特性提供全面支持，使得开发者能够使用最新的语言特性
  - 快速启动时间：V8 在 Chrome 浏览器和 Node.js 中实现了快速启动时间，减少了 JavaScript 应用程序加载的等待时间
  - 多平台支持：V8 引擎可以在多种操作系统上运行，例 Windows、macOS、Linux 等，支持 x86、x64、ARM 等不同处理器架构

## 2. V8 编译流程

#### JIT 是什么

- JIT 是即时编译（ Just-In-Time Compilation ）的缩写，它在程序运行时动态地将代码从一种形式（ 通常是高级语言或中间表示 ）转换为另一种更底层的形式（ 通常是机器码 ）的编译技术
- 传统上，静态编译器将源代码转换为目标平台的机器码，并在执行之前完成这个过程。而 JIT 编译器延迟编译过程，将代码片段的编译推迟到程序运行时
- JIT 编译器的优势在于它能够根据实际执行情况对代码进行动态优化。通过在运行时收集性能信息，JIT 编译器可以针对特定的硬件和执行环境进行优化，以提高程序的执行效率。这种动态优化使得 JIT 编译器在很多场景下能够提供比静态编译更好的性能

#### V8 引擎编译（ 2017 年 4 月底，v8 的 5.9 版本以前 ）

- 其他引擎： 源代码 → 抽象语法树（ AST ） → 字节码 → JIT → 本地代码
- V8 引擎：源代码 → 抽象语法树（ AST ） → JIT → 本地代码
- V8 更加直接的将抽象语法树通过 JIT 技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在 V8 生成本地代码后，也会通过 Profiler 采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间
- 使用的两种编译器：
  - full-codegen：一个生成简单和相对较慢机器码的简单，速度很快的编译器
  - Crankshaft：一个生成高度优化代码的更复杂的（ JIT ）优化编译器

#### V8 引擎编译（ v8 的 5.9 版本及之后版本 ）

- V8 又把生成字节码这个过程给添加回来了
- V8 引擎的编译过程涉及到了两个主要的编译器：解释器和优化编译器，以及热点迁移操作
  - 解释器（ Ignition ），它执行了两个重要的任务：字节码解析和即时编译
    1. 字节码解析：当 JavaScript 代码被传递给 V8 引擎时，Ignition 解析器首先将其转换为字节码。字节码是一种中间表示形式，相对于源代码具有更高的执行效率。Ignition 解析器将 JavaScript 代码分析为字节码指令序列，这些指令可以被快速解释执行
    2. 即时编译：Ignition 解释器不仅负责解析字节码，还会在解释执行过程中监视热点代码。热点代码是经常执行的部分，Ignition 会将这些热点代码标记为 “热点函数”。一旦 Ignition 检测到一个函数变得热点，它将触发即时编译器 TurboFan 来生成高效的机器码
    - **设计目标是快速启动和迅速执行代码。通过使用字节码作为中间表示，并结合即时编译技术，它可提供快速的代码执行能力**
  - 优化编译器（ TurboFan ），当 V8 引擎观察到某些代码被频繁执行，它会启动 TurboFan 对这些代码进行优化：
    1. 目标优化：优化编译器会将符合一定规则的代码标记为优化目标，如 热点函数 或 热点循环
    2. 特定上下文优化：TurboFan 可以根据执行上下文生成特定的优化代码。例如，在浏览器环境中，由于 DOM 操作是常见的，TurboFan 可以针对 DOM 操作进行优化，提高操作效率
    3. 寄存器分配图：优化编译器通过建立寄存器分配图来确定变量和寄存器之间的关系，并进行更高级别的优化
    4. 内联化：TurboFan 还支持内联化，即将被频繁调用的函数内联到调用处。这样可以减少函数调用的开销，并提高代码的执行速度
    5. AST 优化：优化编译器会对抽象语法树（ AST ）进行优化，如内联缓存、行内缓存等优化技术
    6. 即时编译优化：TurboFan 利用 JIT 技术，即在运行时动态地将字节码编译为机器码。这种动态编译技术使得 TurboFan 能够根据实际的执行情况优化生成的机器码，从而提供更好的性能
    7. 静态分析和类型推断：TurboFan 在生成机器码之前进行静态分析和类型推断。它通过收集变量的类型信息，并对代码的执行路径进行分析，以确定最佳的优化策略
    - **包含了一系列的优化技术和算法，负责将 Ignition 解释器标记的热点代码转化为高度优化的机器码**
  - 热点迁移（ Hot Functions Migration ）：
    - 在 V8 引擎中，某些函数可能会频繁地从解释器和优化编译器之间迁移。当一个函数在解释器中被频繁执行，引擎将观察其性能表现。如果函数逐渐变得“热点”，它将被迁移到优化编译器中进行高级别的优化。反之，如果引擎观察到一个热点函数的执行次数减少，它可能会将该函数迁移回解释器，以避免浪费优化编译器的资源

## 3. V8 垃圾回收机制

#### 为啥需要回收

在 js 中，数据类型分为简单类型和引用类型，简单类型，内存是保存在栈空间中，复杂数据类型，内存是保存在堆空间中

- 基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值来访问的
- 引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的

对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放
而堆空间中的内存，由于大小不固定，系统无法无法进行自动释放，这个时候就需要 JS 引擎来手动的释放这些内存

#### 两种 GC 机制

1. "引用计数"：

   - 早期的浏览器最常使用的垃圾回收方法
   - 语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。即数据存在堆内存中，如果一个值的引用次数是 0，就表示没有任何变量或数据指向它，因此可以将这块内存释放，被回收
   - 但这种方法对于 obj1.a = obj2，obj2.a = obj1 这种互相指向的情况没有办法，obj1 和 obj2 通过各自的属性相互引用，所有它们的引用计数都不为零，这样就不会被垃圾回收机制回收，造成内存浪费，所以现在已经废弃不用了
   - 引用计数算法其实还有一个比较大的缺点，就是我们需要单独拿出一片空间去维护每个变量的引用计数，这对于比较大的程序，空间开销还是比较大的

2. "标记清除"：

   - 现在的浏览器最常使用的垃圾回收方法
   - 核心思想：分标记和清除两个阶段完成
     - 遍历所有对象找标记活动对象
     - 遍历所有对象清除没有标记对象
     - 回收相应的空间
   - 标记阶段：

     - 标记阶段就是找到可访问对象的一个过程；对象的可达性，垃圾回收是从一组对象的指针（objects pointers）开始的，我们将其称之为根集（root set），这其中包括了执行栈和全局对象；然后垃圾回收器会跟踪每一个指向 JavaScript 对象的指针，并将对象标记为可访问的，同时跟踪对象中每一个属性的指针并标记为可访问的，这个过程会递归的进行，直至所有节点没有可遍历的路径

     <img src="https://img-blog.csdnimg.cn/19c4ff6aea8c4177892b003e2daf29cd.png" width="700px">

   - 清除阶段：
     - 标志阶段结束后，未被打上标志的对象，说明从根节点无法访问它，垃圾回收器就会回收该内存
   - "标记清除算" 对比 "引用计数算法"，标记清除法最大的优点是能够回收循环引用的对象，它也是 v8 引擎使用最多的算法
   - 但还是存在缺点，空间碎片化：
     红色区域是一个根对象，就是一个全局变量，会被标记；而蓝色区域就是没有被标记的对象，会被回收机制回收。这时就会出现一个问题，表面上蓝色区域被回收了三个空间，但是这三个空间是不连续的，当我们有一个需要三个空间的对象，那么我们刚刚被回收的空间是不能被分配的，这就是 “空间碎片化”

   <img src="https://img-blog.csdnimg.cn/37a093ce2df94c9b9ad6f896b54c578f.png">

#### GC（垃圾回收）的收集方法

1. 标记清除
   - 上面说的，将未标记到的统一回收，但会造成空间碎片化
2. 标记整理

   - 为了解决 "空间碎片化" 的问题，提高对内存的利用
   - 标记整理可以看做是标记清除的增强，标记阶段的操作和标记清除一致
   - 清除阶段会先执行整理，移动对象位置,将存活的对象移动到一边，然后再清理端边界外的内存
   - 但也还是存在缺点，回收前需要移动对象位置，不会立即回收对象，回收的效率比较慢
   - 适合老年代进行垃圾收集
     &nbsp;

   <img src="https://img-blog.csdnimg.cn/de04f791a1f846479077219a9571c0b1.png">&nbsp;
   <img src="https://img-blog.csdnimg.cn/43028a18e1294433a291e90f943c398d.png">
   <img src="https://img-blog.csdnimg.cn/f5a7bbc526954305adac12ee38e5b610.png">

3. 复制算法

   - 也可以解决 "空间碎片化" 的问题，提高对内存的利用
   - 它先将可用的内存按容量划分为大小相同的两块，每次只是用其中的一块。当这块内存用完了，就将还存活着的对象复制到另一块上面，然后把已经使用过的内存空间一次清理掉
   - 牺牲空间换取时间，所以缺点是将内存缩小位原来的一半
   - 适合新生代进行垃圾回收
   - 改进思路：
     由于新生代都是朝生夕死的，所以不需要 1：1 划分内存空间，可以将内存划分为一块较大的 Eden 和两块较小的 Suvivor 空间。每次使用 Eden 和其中一块 Survivor。当回收的时候，将 Eden 和 Survivor 中还活着的对象一次性地复制到另一块 Survivor 空间上，最后清理掉 Eden 和刚才使用过的 Suevivor 空间。其中 Eden 和 Suevivor 的大小比例是 8：1。缺点是需要老年代进行分配担保，如果第二块的 Survovor 空间不够的时候，需要对老年代进行垃圾回收，然后存储新生代的对象，这些新生代当然会直接进入来老年代

   <img src="https://img-blog.csdnimg.cn/d08aad52d6d8478481c34a217e91a963.png">

4. 优化收集方法的思路（分代收集算法）：
   - 根据对象存活的周期的不同将内存划分为几块，然后再选择合适的收集算法
   - 一般是分成新生代和老年代，这样就可以根据各个年待的特点采用最适合的收集算法。在新生代中，每次垃圾收集都会有大量的对象死去，只有少量存活，所以选用复制算法，老年代因为对象存活率高，没有额外空间对他进行分配担保，所以一般采用标记整理或者标记清除算法进行回收

#### V8 引擎的内存回收策略

1. 分代内存

   在 V8 引擎的内存结构中，堆内存分为两类进行处理，新生代内存和老生代内存

   - 新生代内存：是指临时分配内存，存活时间短
     【 新生代内存可分为两个区域 From-space，To-space 】
     【 其中 from 区域还可细分为 nursery 子代和 intermediate 子代 】
   - 老生代内存：是常驻内存，存活时间长

   【 新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了 】

   <img src="https://img-blog.csdnimg.cn/5624552b783c421991f8749f18952e78.png">

2. 垃圾回收器
   对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收

   - 副垃圾回收器 - Scavenge（复制算法）：主要负责新生代的垃圾回收
   - 主垃圾回收器 - Mark-Sweep & Mark-Compact（标记清除，标记整理）：主要负责老生代的垃圾回收

3. 晋升

   - 如果新生代中的一个变量经过多次垃圾回收后，依旧存活。该对象就会被认为是一个声明周期较长的对象，被放入老生代内存中，对象从新生代转移到老生代的过程，称为晋升
   - 对象晋升的条件有两个：
     - 已经经历过一次 Scavenge（即在 Form 空间中的 intermediate 子代区域中的对象）
     - To（当前闲置）空间内存占用超过 25%
   - 即在新生代中，分为 nursery 子代和 intermediate 子代两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 intermediate 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升

4. 采用分代收集算法
   新生代采用 复制算法，老生代采用 标记整理 或 标记清楚 算法
   新生代中，大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法
   老生代中，对象都已经至少经历过一次或者多次的回收所以它们的存活概率会更大，支持的容量交大，会出现空间资源浪费问题

#### v8 解决全停顿问题

1. 什么是全停顿：

   - 由于垃圾回收是在 JS 引擎中进行的，而当活动对象较多的时候，它的执行速度不可能很快，为了避免 JavaScript 应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将 JavaScript 应用暂停，这个过程，被称为全停顿
   - 在新生代中，由于空间小，存活对象较少，Scavenge 算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿
   - orinoco（V8 的垃圾回收器） 为了提升用户体验，解决全停顿问题，它利用了增量标记、懒性清理、并发、并行来降低主线程挂起的时间

2. 增量标记：（优化标记过程）

   - 为了减少全停顿的时间，V8 对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记
   - 长时间的 "全停顿" 垃圾回收，用户体验感变得非常糟糕，同时会严重影响性能
   - 从 2011 年起，v8 就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的 1/6
   - 由于每个小的增量标价之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以也暴露出来增量标记的，缺点：
     - 并没有减少主线程的总暂停的时间，甚至会略微增加
     - 由于写屏障（Write-barrier）机制的成本，增量标记可能会降低应用程序的吞吐量

   <img src="https://img-blog.csdnimg.cn/3ee1d775980049c4866109780bba00cb.png">

3. 懒性清理：（优化清理过程）
   - 当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让 JavaScript 逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕
4. 并发式 GC：

   - 并发式 GC 允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于 JavaScript 代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作

   <img src="https://img-blog.csdnimg.cn/b8b99bdb0f614aed84fdb89099341227.png">

5. 并行式 GC

   - 并行式 GC 允许主线程和辅助线程同时执行同样的 GC 工作，这样可以让辅助线程来分担主线程的 GC 工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）
     <img src="https://img-blog.csdnimg.cn/5bff6bcb2b7d480093dea3fd2b429740.png">

6. 副垃圾回收器

   - V8 在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从 from-to 复制到 space-to 的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8 在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制

   <img src="https://img-blog.csdnimg.cn/22fd258e6b5b45989955afb53f85737b.png">

7. 主垃圾回收器

   - V8 在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在 JavaScript 代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被 JavaScript 代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪
   - 当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行 check 操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程 JavaScript 代码的执行
     <img src="https://img-blog.csdnimg.cn/38081cc527eb4455a9308b615994dd3b.png">

8. V8 当前解决全停顿问题的方案
   2011 年，V8 应用了增量标记机制。直至 2018 年，Chrome64 和 Node.js V10 启动并发标记，同时在并发的基础上添加并行技术，使得垃圾回收时间大幅度缩短

## 3. 内存泄漏与优化

#### 内存泄漏

- 内存泄漏，指在 JS 中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况

- 作用域分为全局作用域和局部作用域，局部作用域分为函数作用域和块级作用域，全局作用域的变量就是全局变量，全局变量只有关闭页面才会回收，局部变量在使用完毕后就会被回收，比如一个函数里定义了一个变量，在这个函数运行完毕后这个变量就会被回收

- 在代码中创建对象和变量时会占据内存，但是 JS 基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃

#### 造成内存泄漏的常见原因，及解决办法

- 原因：过多的缓存
  解决办法：及时清理过多的缓存
- 原因：滥用闭包
  解决办法：尽量避免使用大量的闭包，注意闭包，对闭包进行限制，不能无限制的增长（例如：当闭包里的数组进行 push 数据，超过一定长度，删除一些，再继续 push）
- 原因：定时器或回调太多
  解决办法：与节点或数据相关联的计时器不再需要时，DOM 节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）
- 原因：当不需要 setTimeout 或 setInterval 时，定时器没有被清除，定时器的回调函数以及其内部依赖的变量都不能被回收，会造成内存泄漏
  解决办法：在定时器完成工作时，需要手动清除定时器。
- 太多无效的 DOM 引用。DOM 删除了，但是节点的引用还在，导致 GC 无法实现对其所占内存的回收
  解决办法：给删除的 DOM 节点引用设置为 null。
- 滥用全局变量。全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为 null 或在完成后重新分配它
  解决办法：尽量不要定义全局变量，定义了也要及时手动回收（如：让这个变量的值等于 undefined、null 或重定义），使用严格模式
- 从外到内执行 appendChild。此时即使调用 removeChild 也无法进行释放内存
  解决办法：从内到外 appendChild。
- 反复重写同一个数据会造成内存大量占用，但是 IE 浏览器关闭后会被释放
- 注意程序逻辑，避免编写『死循环』之类的代码
- 避免 DOM 对象和 JS 对象相互引用

关于内存泄漏，如果想要更好地排查以及提前避免问题的发生，最好的解决方法是通过熟练使用 Chrome 的内存剖析工具，多分析多定位 Chrome 帮你分析保留的内存快照，来查看持续占用大量内存的对象

## 4. V8 原生绑定

#### 基础介绍

- V8 支持原生绑定是通过 Node.js 的 C++ 插件来实现的。Node.js 提供了一套 C++ API，允许开发者编写 C++ 代码，然后将其绑定到 V8 引擎，从而可以在 JavaScript 中直接调用这些 C++ 代码
- 原生绑定是用在 Node.js 上的，不能在浏览器环境中使用。原因是在浏览器中，JavaScript 是运行在沙箱环境中，受到严格的安全限制，不允许直接访问底层系统资源或执行本地的原生代码。在浏览器环境中通常可以通过 Web APIs 来间接与底层系统进行交互或执行原生代码

#### 使用场景

- 性能优化：对于性能敏感的任务，例图像处理、加密解密等，用原生绑定可以充分利用 C++ 的高效性能，提高代码的执行速度和效率
- 底层功能访问：需要访问硬件设备或执行底层硬件的操作，可能无法通过 JavaScript 直接实现，例如访问操作系统的底层功能、调用本地库等。此时可以通过原生绑定在 C++ 中实现这些功能，并在 JavaScript 中调用
- 大规模数据处理：原生绑定在处理大规模数据时具有优势，C++ 对内存管理和数据处理更为灵活，可以加速数据处理过程
- 需要与现有 C/C++ 库集成：在项目中已经有现有的 C/C++ 库，想要在 JavaScript 中使用这些库的功能，可以通过原生绑定将 C/C++ 库封装成 C++ 插件，然后在 JavaScript 中调用

#### 基础样例

1. 创建 C++ 插件

   - 首先需要编写一个 C++ 插件，其中包含想在 JavaScript 中调用的功能。例创建一个简单的数学计算模块，计算两个数字的和

     ```
     // math.cpp
     #include <node.h>

     using namespace v8;

     void Add(const FunctionCallbackInfo<Value>& args) {
       Isolate* isolate = args.GetIsolate();

       // Ensure at least two arguments are provided.
       if (args.Length() < 2) {
         isolate->ThrowException(Exception::TypeError(
             String::NewFromUtf8Literal(isolate, "Wrong number of arguments")));
         return;
       }

       double sum = args[0]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0) +
                    args[1]->NumberValue(isolate->GetCurrentContext()).FromMaybe(0);

       args.GetReturnValue().Set(Number::New(isolate, sum));
     }

     void Initialize(Local<Object> exports) {
       NODE_SET_METHOD(exports, "add", Add);
     }

     NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
     ```

2. 编译插件

   - 前提：
     - 需要 python 环境，需要 2.7 版本，3.0 版本及以上不行
     - 需要 make 环境（ brew install make ）
     - 需要 node-gyp 工具（ npm init ）（ npm install node-gyp --save-dev ）

   1. 创建并编辑 binding.gyp 文件，指定 C++ 源文件的路径和生成文件名
      ```
      {
          "targets": [
            {
                "target_name": "math",
                "sources": ["math.cpp"]
            }
          ]
      }
      ```
   2. 根据 binding.gyp 文件，来配置构建系统
      ```
      node-gyp configure
      ```
   3. 运行构建系统，进行编译原生模块
      ```
      node-gyp build
      ```

3. 在 Node.js 中使用插件

   - 可以 require 加载 C++插件，并调用其中的功能

     ```
     const math = require("./build/Release/math.node");

     const result = math.add(2, 3);
     console.log(result); // 输出 5
     ```

## 5. AST（抽象语法树）

#### AST 是什么

- AST 是源代码语法结构的一种抽象表示，以树状的形式表现编程语言的语法结构，树上每个节点都表示源代码中的一种结构

#### 常见用途

- 编辑器的错误提示，代码格式化，代码高亮，代码自动补全
- elint、pretiier 对代码错误或风格的检查
- webpack 通过 babel 转译 javascript 语法

#### AST 生成

- 代码执行的第一步是读取代码文件中的 字符流，然后通过 词法分析 生成 token，之后再通过 语法分析 生成 AST，最后 生成 机器码执行。整个解析过程主要分为以下两个步骤：
  - 词法分析（或叫分词）：将整个代码字符串分割成最小语法单元数组
  - 语法分析：在分词基础上建立分析语法单元之间的关系

#### 词法分析

- 词法分析，也称之为 扫描 或者 令牌化（Token），这一步主要是将字符流（char stream）转换为令牌流（token stream），就是在源代码的基础上进行分词，简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的 token，token 是一个不可分割的最小单元
- 词法分析器里，每个关键字是一个 token ，每个标识符是一个 token，每个操作符是一个 token，每个标点符号也都是一个 token。除此之外，还会过滤掉源程序中的注释和空白字符（换行符、空格、制表符等），最终，整个代码将被分割进一个 tokens 列表（或者说一维数组）
- 例如，词法分析器 从左往右逐个字符扫描分析 整个程序的字符串，当遇到不同的字符时，会驱使它迁移到不同的状态。在扫描字符的时候，遇到 c 字母，如果后面还有字符，将继续扫描，直到遇到空格，识别出 const，发现是一个关键字，将其生成词法单元 { type: 'Keyword', value: 'const' }，然后接着扫描，以此类推，生成 Token List

#### 语法分析

- 语法分析会将词法分析出来的 token 转化成有语法含义的抽象语法树结构（AST），同时验证语法，语法如果有错，会抛出语法错误
- 词法分析和语法分析不是完全独立的，而是交错进行的，也就是说，词法分析器不会在读取所有的词法记号后再使用语法分析器来处理。通常情况下，每取得一个词法记号，就将其送入语法分析器进行分析

#### 举例

（使用的工具 AST explorer，[详情](https://juejin.cn/post/7045496002614132766)）

```
function square(n) {
  return n * n;
}
```

经过转化，输出 AST 结构如下：
<img src="https://img-blog.csdnimg.cn/1f0428db54c64a4eaad1a9348915dd7c.png">

AST 的每一层都拥有相同的结构（为了简化，移除了某些属性）：

```
{
    type: "FunctionDeclaration",
    id: {...},
    params: [...],
    body: {...}
}
```

```
{
    type: "Identifier",
    name: ...
}
```

```
{
    type: "BinaryExpression",
    operator: ...,
    left: {...},
    right: {...}
}
```

这样的每一层结构，被称为 节点（Node），每一个节点都包含 type 属性，用于表示节点类型，比如：FunctionDeclaration、Identifier、BinaryExpression 等等。除此之外，Babel 还为每个节点额外生成了一些属性，用于描述该节点在原始代码中的位置，比如： start、end、loc

还有一些例子，可以看出大概 AST 转换后的结构：

```
while b != 0
{
    if a > b
        a = a-b
    else
        b = b-a
}
return a
```

<img src="https://img-blog.csdnimg.cn/3b5666b2bdf340d3ad0f1bd4b61004aa.png">

```
sum=0
for i in range(0,100)
    sum=sum+i
end
```

<img src="https://img-blog.csdnimg.cn/1addbd6be0a843398eb9b16198ac043e.png">

```
<letter>
  <address>
    <city>ShiChuang</city>
  </address>
  <people>
    <id>12478</id>
    <name>Nosic</name>
  </people>
</letter>
```

<img src="https://img-blog.csdnimg.cn/c8c99f6c84b1490ab78e5d6d8cafedce.png">

```
1 + 3 * ( 4 - 1 ) + 2
```

<img src="https://img-blog.csdnimg.cn/31f3b2db5be74450984433bf300bd2fd.png">

## 6. babel 工作原理（AST 的使用）

[具体的看这，详情](https://juejin.cn/post/7045496002614132766)

#### 节点类型（babel）

AST 节点类型，主要分为以下几个大类：字面量、标志符、语句、声明、表达式、注释 等等

- 字面量（Literal）：
  <img src="https://img-blog.csdnimg.cn/b9deaa9047cc4466a7d3f0f6353a1636.png">
- 标志符（Identifier）：
  程序中所有的 变量名、函数名、对象键（key） 以及函数中的参数名，都属于标志符（Identifier）
- 语句（Statement）：
  语句是能够独立执行的基本单位，常见的语句类型有
  <img src="https://img-blog.csdnimg.cn/cb8ab17beba44264b3bc804b466ad21f.png">
- 声明（Declaration）：
  声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个 变量、函数、class、import、export 等
  <img src="https://img-blog.csdnimg.cn/9f1efb02c9184fcf8d25d4d03e685071.png">
- 表达式（Expression）：
  表达式的特点是执行完以后有返回值，这是和语句 (statement) 的区别
  <img src="https://img-blog.csdnimg.cn/931a0e7581e44560bbbb60bdf0f92c79.png">
- Comment & Program：
  <img src="https://img-blog.csdnimg.cn/a1d6e993d3a240a3bc03ff8cf1f45539.png">

#### babel 编译流程

babel 的编译过程和大多数其他语言的编译器大致相同，可以分为 3 个阶段：解析 → 转换 → 生成

1. 解析（Parser）
   - 将代码字符串解析成抽象语法树（AST），每个 JavaScript 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 @babel/parser 实现的。解析过程有两个阶段：词法分析 和 语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构
2. 转换（Transform）
   - 对抽象语法树进行转换操作，转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 Babel 通过 @babel/traverse 对其进行深度优先遍历，维护 AST 树的整体状态，并且可完成对其的替换，删除或者增加节点，这个方法的参数为原始 AST 和自定义的转换规则，返回结果为转换后的 AST
3. 生成（Generator）
   - 根据变换后的抽象语法树再生成代码字符串，同时还会创建 源码映射（source maps）
   - 代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串
   - Babel 通过 @babel/generator 将 AST 转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串

#### babel apis

我们知道 Babel 的编译流程分为三步：Parse → Transform → Generate，每一步都暴露了一些 Api 出来：

1. 解析阶段：通过 @babel/parser 将源码转成 AST；
2. 转换阶段：通过 @babel/traverse 遍历 AST，并调用 visitor 函数修改 AST，期间涉及到 AST 的判断、创建、修改等，这时候就需要 @babel/types 了，当需要批量创建 AST 的时候可以使用 @babel/template 来简化 AST 创建逻辑
3. 生成阶段：通过 @babel/generate 将 AST 输出为目标代码字符串，同时生成 sourcemap
4. 中途遇到错误想打印代码位置的时候，使用 @babel/code-frame 包
5. Babel 的整体功能通过 @babel/core 提供，基于上面的包完成 Babel 整体的编译流程，并实现插件功能

#### AST 实战（ babel ）

[AST 实战](https://juejin.cn/post/6844904035271573511#heading-8)
