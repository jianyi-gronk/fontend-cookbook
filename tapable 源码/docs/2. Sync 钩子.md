## 1. SyncHook

- SyncHook 是 Tapable 所提供的最简单的钩子，它是一个同步钩子

#### 1.1 基础使用

- 初始化 SyncHook 后，可以通过调用实例的 tap 方法来注册事件，调用 call 方法按注册顺序来执行回调

  ```js
  // 初始化同步钩子
  const hook = new SyncHook(["contry", "city", "people"]);

  // 注册事件
  hook.tap("event-1", (contry, city, people) => {
    console.log("event-1:", contry, city, people);
  });
  hook.tap("event-2", (contry, city, people) => {
    console.log("event-2:", contry, city, people);
  });

  // 执行订阅事件回调
  // 钩子上目前注册了 2 个回调，它们会按顺序被触发
  // 输出：event-1: China Shenzhen VJ
  // 输出：event-2: China Shenzhen VJ
  hook.call("China", "Shenzhen", "VJ");

  // 注册事件
  hook.tap("event-3", (contry, city, people) => {
    console.log("event-3:", contry, city, people);
  });
  hook.tap("event-4", (contry, city, people) => {
    console.log("event-4:", contry, city, people);
  });

  // 执行订阅事件回调
  // 钩子上目前注册了 4 个回调，它们会按顺序被触发
  // 输出：event-1: USA NYC Trump
  // 输出：event-2: USA NYC Trump
  // 输出：event-3: USA NYC Trump
  // 输出：event-4: USA NYC Trump
  hook.call("USA", "NYC", "Trump");
  ```

#### 1.2 代码实现

- SyncHook 实例化后其实就是一个 Hook 类的实例对象，并带上了一个自定义的 compile 方法

  ```js
  class SyncHookCodeFactory extends HookCodeFactory {
    // content 方法的参数都是模板参数，它们执行后都会返回模板字符串，用于在 callTap 方法里拼接函数代码段
    content({ onError, onDone, rethrowIfPossible }) {
      return this.callTapsSeries({
        onError: (i, err) => onError(err),
        onDone,
        rethrowIfPossible
      });
    }
  }

  function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
  }

  this.compile = COMPILE;
  ```

- callTapsSeries 会遍历订阅数组并逐次调用 callTap，最后将全部订阅事件的执行代码字符串拼接起来

## 2. SyncBailHook

#### 2.1 基础使用

- SyncBailHook 也是一个同步钩子，不同于 SyncHook 的是，如果某个订阅事件的回调函数返回了非 undefined 的值，那么会中断该钩子后续其它订阅回调的调用

  ```js
  const { SyncBailHook } = require("tapable");

  // 初始化钩子
  const hook = new SyncBailHook(["contry", "city", "people"]);

  // 订阅事件
  hook.tap("event-1", (contry, city, people) => {
    console.log("event-1:", contry, city, people);
  });

  hook.tap("event-2", (contry, city, people) => {
    console.log("event-2:", contry, city, people);
    return null; // 设置了非 undefined 的返回值
  });

  // 因为 event-2 设置了返回值，所以后续的 event-3、event-4 都不会执行
  hook.tap("event-3", (contry, city, people) => {
    console.log("event-3:", contry, city, people);
  });

  hook.tap("event-4", (contry, city, people) => {
    console.log("event-4:", contry, city, people);
  });

  // 输出：event-1: USA NYC Trump
  // 输出：event-2: USA NYC Trump
  hook.call("USA", "NYC", "Trump");
  ```

#### 2.2 代码实现

- SyncBailHook 相对于 SyncHook.js 的主要区别是 content/callTapsSeries 方法中 onResult 参数
  ```js
  class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
      return this.callTapsSeries({
        onError: (i, err) => onError(err),
        // 会判断返回值是否为空，为空则继续执行下一个订阅回调，否则中断后续订阅回调的执行
        onResult: (i, result, next) =>
          `if(${result} !== undefined) {\n${onResult(
            result
          )};\n} else {\n${next()}}\n`,
        resultReturns,
        onDone,
        rethrowIfPossible
      });
    }
  }
  ```

## 3. SyncWaterfallHook

#### 3.1 基础使用

- SyncWaterfallHook 也是同步钩子，它会把前一个订阅回调所返回的内容，作为第一个参数传递给后续的订阅回调

  ```js
  const SyncWaterfallHook = require("./SyncWaterfallHook.js");

  const hook = new SyncWaterfallHook(["contry", "city", "people"]);

  hook.tap("event-1", (contry, city, people) => {
    console.log("event-1:", contry, city, people);
  });

  hook.tap("event-2", (contry, city, people) => {
    console.log("event-2:", contry, city, people);
    return "The United State"; // 设置了返回值
  });

  hook.tap("event-3", (contry, city, people) => {
    console.log("event-3:", contry, city, people);
  });

  hook.tap("event-4", (contry, city, people) => {
    console.log("event-4:", contry, city, people);
  });

  // 输出：event-1: USA NYC Trump
  // 输出：event-2: USA NYC Trump
  // 输出：event-3: The United State NYC Trump
  // 输出：event-4: The United State NYC Trump
  hook.call("USA", "NYC", "Trump");
  ```

#### 3.2 代码实现

- SyncWaterfallHook 只需要调整 onDone 和 onResult 两个模板参数即可
  ```js
  class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onResult }) {
      return this.callTapsSeries({
        onResult: (i, result, next) => {
          // 修改点
          let code = "";
          code += `if(${result} !== undefined) {\n`;
          code += `${this._args[0]} = ${result};\n`;
          code += `}\n`;
          code += next();
          return code;
        },
        onDone: () => onResult(this._args[0]) // 修改点
      });
    }
  }
  ```
