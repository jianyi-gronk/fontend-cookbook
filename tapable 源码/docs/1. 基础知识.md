## 1 Tapable

- Tapable 是一个基于 发布/订阅模式 的 钩子 库，对外提供了如下几种钩子
  ```javascript
  const {
    SyncHook,
    SyncBailHook,
    SyncWaterfallHook,
    SyncLoopHook,
    AsyncParallelHook,
    AsyncParallelBailHook,
    AsyncSeriesHook,
    AsyncSeriesBailHook,
    AsyncSeriesWaterfallHook
  } = require("tapable");
  ```
- 每个钩子拥有自己专属的事件执行机制和触发时机，Webpack 正是利用它们，在不同的编译阶段来调用各插件回调，从而影响编译结果

## 2. Hook（ 钩子 ）

- Hook 是 Tapable 中的一个基础类，核心概念是 注册事件 和 拦截器

#### 2.1 注册事件（ Tap ）

- 注册事件是将插件函数订阅到钩子上，当钩子被触发时，这些函数会被执行
- 支持三种注册方式
  - tap：同步注册，用于同步钩子或异步钩子的同步插件。
  - tapAsync：异步回调式注册，函数最后需调用 callback
  - tapPromise：Promise 式注册，返回 Promis
- 这些注册方法有两个参数
  - option：字符串 或 对象，包含插件的定义
    - 对象
      - name：string，插件名称
      - before：string 或 string 数组，代表在指定的 插件 之前执行（ 只能指定已经注册过的 ）
      - stage：number，优先级，值越低优先级越高
    - 字符串，即插件名称，等效于 name 属性
  - fn：具体需要执行的函数
- 通过 tap 注册 插件 时，将会把 fn 和 type（ tap 对应三种注册方法，sync，async 和 promise ），合并到 option 中，然后按照执行顺序放入 taps 数组中

#### 2.2 拦截器（ Interceptor ）

- Interceptor 存在 register，call，loop，tap，error，result，done 七种方法（ 可只实现部分 ），分别在不同时机被调用
  - register
    - 订阅前触发拦截，调用 hook.intercept 方法时执行拦截回调
    - 当前钩子有多少个订阅事件就会执行多少次 register 拦截回调，可以在该拦截回调里修改订阅者信息
  - call
    - 用户调用 hook.call/callAsync 时触发，在订阅事件的回调执行前执行，参数为用户传参
    - 只会触发一次
  - loop
    - loop 类型钩子每次循环起始时触发（ 排在 call 拦截器后面 ），参数为用户传参
    - 循环几次就会触发几次
  - tap
    - 调用 hook.call/callAsync 时触发，在订阅事件的回调执行前执行（ 排在 call 和 loop 拦截器后面 ），参数为订阅者信息
    - 有多个订阅回调就会执行多次
  - error
    - 调用 hook.call/callAsync 时触发，拦截时机为执行订阅回调出错时，参数为错误对象
  - done
    - 调用 hook.call/callAsync 时触发，拦截时机为全部订阅回调执行完毕的时候（ 排在用户传入的 “事件终止” 回调前面 ），没有参数
- 可以通过 intercept 方法将其添加进 interceptors 数组，只根据添加先后决定顺序，不能指定顺序。在不同时机，会遍历 interceptors 数组，如果 Interceptor 有实现对应方法则执行

#### 2.3 其他方法

- withOptions
  - 返回一个新的包含所有 Hook 方法的对象，参数为 默认 options
  - 包含 Hook 相同功能的注册方法，但所有方法会自动合并默认 options
  - 支持链式调用，可以 hook.withOptions(xxx).withOptions(xxx)
- isUsed
  - 判断当前钩子是否有插件或拦截器注册
- compile
  - 抽象方法，子类必须实现
  - 根据当前 taps、interceptors、type（ sync/async/promise ）等信息，动态生成一个高效的钩子执行函数并返回

#### 2.4 细节

- 延迟编译

  - 在 constructor 中，对 call、callAsync、promise 方法进行了延迟编译，以 call 举例

    ```js
    /**
     * 该函数同时包含 编译 和 执行
     * 作用是 延迟编译，第一次触发 call 的时候，会用 _createCall 编译后的函数覆盖原本的 call 方法
     * 后续调用 call 方法，就会直接执行编译后的函数，而不会再进入重新编译函数
     */
    function CALL_DELEGATE(...args) {
      this.call = this._createCall("sync");
      return this.call(...args);
    }

    /**
     * 声明两次的原因是
     * 1. 带下划线声明
     *    原始默认实现，不会被改变，用于修改 拦截器 或 注册插件 后，用 _call 覆盖 call 方法
     *    然后第一次执行 call 的时候，会再次基于最新的 拦截器 和 注册插件 进行编译
     * 2. 不带下划线声明
     *    实际对外暴露的触发方法，触发的第一次会被更改成 _createCall 编译后的函数
     */
    this._call = CALL_DELEGATE;
    this.call = CALL_DELEGATE;

    /*
     * 本身并没有实现 compile，需要调用子类的 compile 方法生成真正的执行函数
     */
    _createCall(type) {
    	return this.compile({
    		taps: this.taps,
    		interceptors: this.interceptors,
    		args: this._args,
    		type
    	});
    }
    ```

- 删除原型链 `Object.setPrototypeOf(Hook.prototype, null);`
  - 主要原因：设置原型为 null，防止原型链污染
  - 附加原因：可以避免在原型链上查找属性和方法，从而提高性能（ 差距有限 ）

## 3. HookCodeFactory

- 子类的 compile 方法就是通过 HookCodeFactory 实例生成的，写法如下
  ```js
  function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
  }
  ```
- 区别在于 factory 不同，不同类型 hook 的 factory 对应类在继承 HookCodeFactory 的基础上，自定义实现了 content 方法
- setup 方法，将所有注册事件的 fn 放到 \_x 数组中，后续要触发所有订阅事件回调，只需要按顺序执行 \_x 即可
  ```js
  setup(instance, options) {
    instance._x = options.taps.map((t) => t.fn);
  }
  ```
- HookCodeFactory 的核心是 create 方法

  - 根据当前 taps 和 interceptors 的实际情况，动态生成一段函数代码字符串
  - 然后用 new Function() 把字符串转换成函数
    ```js
    new Function([arg1, arg2, ...], functionBody)
    ```
    - arg1, arg2, ... 是函数的参数列表，对应 hooks 注册时传入的参数
    - functionBody 是函数的主体代码，是一个字符串
    - 例如创建一个接受两个参数并返回它们之和的函数
      ```js
      let add = new Function("a", "b", "return a + b;");
      let result = add(5, 3);
      console.log(result); // 输出: 8
      ```
  - 例如传统写法，每次调用都需要循环遍历 taps 数组，或者需要做一些逻辑判断
    ```js
    funcation(arg1, arg2) {
      ...
      for (const tap of taps) {
        const fn = tap.fn;
        fn(arg1, arg2);  // 或处理 async/promise
        if (tap.type === "sync") {
          console.log(tap.name, "is sync");
        }
      }
    }
    ```
  - 而动态生成函数代码字符串，则可以避免每次调用时遍历数组和一些逻辑判断

    ```js
    function(arg1, arg2) {
      ...
      var _x = taps;  // 插件函数数组
      _x[0](arg1, arg2);
      _x[1](arg1, arg2);
      const result = _x[2](arg1, arg2);

      // 可以直接生成函数前判断，如果是 sync 类型，则加这段代码，否则不加
      console.log(tap.name, "is sync");
      return result;
    }
    ```
