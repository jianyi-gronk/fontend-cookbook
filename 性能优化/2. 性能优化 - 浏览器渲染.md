## 1. 浏览器渲染原理

1. 获取 HTML 文档：
   - 浏览器通过网络请求（如 HTTP、HTTPS 协议）从服务器获取 HTML 文件。这个过程需要 DNS 解析、TCP 连接、HTTP 请求等多个步骤
2. 构建 DOM 树：
   - 浏览器解析 HTML 文档，将其转换为 DOM（文档对象模型）树。DOM 树是一个树状结构，表示 HTML 文档的逻辑结构。浏览器会将 HTML 文档中的每个元素（如标签、属性、文本等）转换为 DOM 树上的一个节点。此过程是自上而下的，浏览器会逐行解析 HTML 代码，遇到标签就会创建对应的 DOM 节点
3. 获取 CSS 文件：
   - 与获取 HTML 文档类似，浏览器还需要通过网络请求从服务器获取 CSS 文件
4. 构建 CSSOM 树：
   - 浏览器解析 CSS 文件，将其转换为 CSSOM（CSS 对象模型）树。CSSOM 树也是一个树状结构，表示 CSS 样式规则。浏览器会将 CSS 文件中的每个样式规则转换为 CSSOM 树上的一个节点。CSSOM 树的构建同样是自上而下的
5. 合并 DOM 树和 CSSOM 树：
   - 浏览器将 DOM 树和 CSSOM 树合并为一个渲染树（render tree）。渲染树包含了网页上所有可见元素的样式和位置信息。在这个过程中，浏览器会根据 CSSOM 树上的样式规则计算 DOM 树上每个节点的样式信息
6. 布局：
   - 在渲染树构建完成后，浏览器会计算每个元素在屏幕上的确切位置和大小，这个过程被称为布局（layout）或重排（reflow）。布局过程从根节点（如 HTML 元素）开始，递归地计算每个子节点的位置和大小。布局计算会考虑各种因素，如盒模型、定位、浮动、弹性布局等
7. 绘制：
   - 布局完成后，浏览器会将渲染树上的每个元素绘制到屏幕上，这个过程称为绘制（painting）或重绘（repaint）。绘制过程包括绘制背景、边框、文字、图像等。在绘制过程中，浏览器会使用 GPU（图形处理器）加速，以提高性能
8. JavaScript 执行：
   - 浏览器还需要执行网页上的 JavaScript 代码。JavaScript 代码可能会修改 DOM 结构、CSS 样式或者触发其他事件。这些操作可能导致浏览器重新执行布局、绘制等步骤
9. 事件处理：
   - 浏览器会监听用户的交互事件（如点击、滚动等），并根据事件类型触发相应的事件处理程序。事件处理程序可能会改变 DOM 结构、CSS 样式或者执行其他操作，从而导致浏览器重新渲染网页
10. 页面更新：
    - 在整个浏览过程中，浏览器会根据需要对页面进行更新，如执行动画、响应用户操作等。这些更新可能会导致浏览器重新执行布局、绘制等步骤

## 2. 减少重排重绘

#### 重排重绘

- 重排一定会引起重绘，重绘不一定会发生重排
- 重排（Reflow）
  - 重排是指浏览器重新计算元素的布局，以确定页面中各个元素的位置和尺寸，可能会影响到 DOM 树中的大量元素，因此可能导致性能问题。频繁的重排可能导致页面渲染速度变慢，从而影响用户体验
  - 当以下情况发生时，浏览器会触发重排：
    - 添加或删除可见的 DOM 元素
    - 元素的位置、尺寸（如宽度和高度）或其他布局属性发生变化
    - 页面的初始渲染
- 重绘（Repaint）：
  - 重绘是指浏览器重新绘制页面中的元素，以应用新的样式，通常比重排的性能开销要小，因为它只涉及到元素的外观，而不需要重新计算布局。但是，频繁的重绘仍然可能导致性能问题
  - 当以下情况发生时，浏览器会触发重绘：
    - 元素的视觉样式（如颜色、背景、边框等）发生变化
    - 重排完成后，需要更新页面上的元素外观

#### 如何避免重排重绘

1. 避免触发同步布局事件（即避免频繁获取某些布局信息）
   - 可以通过用变量保存元素的某些属性，避免频繁地去获取，从而引起重排重绘
2. 避免频繁插入元素
   - 使用文档碎片插入
3. 尽量避免多次修改 css
   - 最好修改完后一次重排重绘，例如通过 class，一次性修改了
4. img 事先设置好宽高
   - 遇到 img 标签，会立马发送一个 http 请求，下载图片，页面继续向下渲染，如果图片不设置尺寸，首次载入时，占据空间会从 0 到完全出现，上下左右都可能位移，引起重排，所以尽可能设置图片的大小，这样只会引起重绘
5. 可以尽量将 display: none 改为 visibility: hiden
   - 前者会引起重排，后者（设为不可见）只会引起重绘
6. 对于有动态效果的元素，减少影响重拍重绘的范围
   - 可以让其处于 BFC 中，脱离文档流，防止引起大范围重排，它仍然在原始的渲染层中进行渲染，但它会创建一个独立的渲染环境
   - 或者使用 GPU 加速，把它提取到独立的渲染层（ will-change，translateZ 等等 ）
7. 避免使用 table 布局
   - table 布局可能很小的一个改动就会造成整个 table 重排
8. 尽量利用 css 动画完成动态效果
   - 合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 javascript 或者一些布局任务占用，css 动画依然能继续执行。所以如果能让 css 处理动画，就尽量交给 css 来操作。另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层

## 3. 文档碎片优化节点添加

- dom 节点插入时，会触发重排重绘，为了减少资源浪费，提高效率，应该尽可能减少重排重绘，本来需要将多个节点插入到父节点中，使用文档碎片可以只进行一次插入操作
- 将多个子节点先插入到文档碎片中，再将文档碎片统一插入到实际节点中，减少了节点插入到父节点中的次数，减少了回流重绘，优化了性能
- DocumentFragment 节点自身不会插入到父节点中，它相当于一个临时区域

```
<ul></ul>
<script>
    // 创建文档碎片
    var documentFragment = document.createDocumentFragment();

    // 创建li标签
    var li1 = document.createElement("li");
    li1.innerHTML = "测试列表1"; // li标签中加入“测试列表1”选项
    var li2 = document.createElement("li");
    li2.innerHTML = "测试列表2";
    var li3 = document.createElement("li");
    li3.innerHTML = "测试列表3";

    // li1 li2 li3插入到文档碎片中
    documentFragment.appendChild(li1);
    documentFragment.appendChild(li2);
    documentFragment.appendChild(li3);

    // 文档碎片插入到ul中 ---一次操作将li1 li2 li3 全部插入了
    var ul = document.querySelector("ul");// 读到ul标签
    ul.appendChild(documentFragment);// 把存到临时容器中的li标签存入ul标签中
</script>
```

## 4. querySelector 和 getElementBy 性能分析

#### 基础介绍

- getElementBy 常用的有 getElementById('idName')，getElementsByTagName('tagName')，getElementsByClassName('className')，分别通过 id，tag 和 class 获取元素（还有别的）
- querySelector 有 querySelector，querySelectorAll，分别是返回匹配指定 CSS 选择器元素的第一个元素，和返回所有匹配的元素

#### 动态集合 和 静态集合

- getElement 返回动态集合，而 querySelector 返回静态集合
- 动态集合或静态集合，取决于元素的数组，是否会随着文档操作而改变，动态会，静态则不会，也就是说，如果要动态获取新创建的 dom 元素，就只能通过 getElementsBy 去实现
- 简单来说 “静态” 是指如果在后续的 DOM 操作中有新的元素符合查询条件，querySelector 返回的元素不会更新，比如
  - 即是否会随着文档操作变化来更新这个 li 的元素集合（此时页面上应该是 6 个 li）
  ```
  const ul1 = document.getElementsByTagName('ul');
  const ul2 = document.querySelectorAll('ul')
  const li1 = document.getElementsByTagName('li');
  const li2 = document.querySelectorAll('li');
  ul1[0].appendChild(document.createElement('li'));
  ul2[0].appendChild(document.createElement('li'));
  console.log(li1.length);  // 6
  console.log(li2.length);  // 4
  ```

#### 获取元素的效率问题

1. 获取节点

   ```
   console.time('querySelector');
   for (var i = 0; i < 100000; i++) {
       document.querySelector("#wp_editbtns");
   }
   console.timeEnd('querySelector');
   //querySelector: 519ms

   console.time('getElementById');
   for (var i = 0; i < 100000; i++) {
       document.getElementById("wp_editbtns");
   }
   console.timeEnd('getElementById');
   //getElementById: 491ms
   ```

2. 获取节点集合
   `
   console.time('querySelectorAll');
   for (var i = 0; i < 10000; i++) {
   document.querySelectorAll(".menu-top");
   }
   console.timeEnd('querySelectorAll');
   //querySelectorAll: 1781ms

   console.time('getElementsByClassName');
   for (var i = 0; i < 10000; i++) {
   document.getElementsByClassName("menu-top");
   }
   console.timeEnd('getElementsByClassName');
   //getElementsByClassName: 54ms
   `
   （只要知道 getElementBy 的效率比 querySelector 高就行了）

#### 布局抖动（同步布局事件）

- 当代码执行一系列连续的修改和读取 DOM 时会发生布局抖动，迫使浏览器重新计算布局信息，引发重排重绘，造成 Web 应用程序产生更慢、更少的响应
- 不管是静态集合还是动态集合，修改集合中的页面元素的属性，一样会同步到页面；并且当页面元素的样式发生改变时，也会同步到集合中的元素
- 不管是静态集合还是动态集合，当访问的是集合中的元素的布局属性，就会触发重排重绘
- 由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是当你获取布局信息的操作的时候，会强制清空队列，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排，重绘（也就是同步布局事件）
- 那些布局信息中常用的有（还有其他的）：
  1.  offsetTop、offsetLeft、offsetWidth、offsetHeight
  2.  scrollTop、scrollLeft、scrollWidth、scrollHeight
  3.  clientTop、clientLeft、clientWidth、clientHeight
  4.  getComputedStyle()
  5.  getBoundingClientRect()
  6.  width、height

#### 使用场景

- 那既然 getEelementBy 的效率这么高，为啥有的框架还使用 querySelector，因为大伙懒，喜欢图方便，就比如你要获取标签为 div 的且类名为 box 的元素集合，你该怎么用 getElementBy 获取，还得用标签名获取元素集合，再用类名获取元素集合，看看里面重复的有哪些，把它们全提出来才能得到
- 所以如果考虑效率就用 getElementBy，考虑方便就用 querySelector

#### 其他细节

1. querySelector 返回的都是 NodeList 对象（即文档节点的集合），而 getElementsBy 返回的是 HTMLCollection（ HTML 元素的集合）
2. querySelector 属于 W3C 中的 Selectors API 规范，而 getElementBy 系列则属于 W3C 的 DOM 规范
3. getElementBy 接收的参数只能是简单的 className，tagName，id 等，querySelector 接收的参数可以是选择器或选择器组
