## 4. js 阻塞页面渲染

（老早就听过别人说把&#60;scrpt&#62;放到最后面，一直没去了解，我这里也没写的那么深入，也就是带了自己的理解，大概浅浅介绍（能力不够），如果有错误，欢迎指出）

1. 为什么会阻塞
   由于 js 可能会修改 dom，所以运行 js 和构建 dom 不能同时进行，因此 js 会对页面渲染造成较大的影响
2. 如何阻塞
   1. 如果是内联 js
      1. 浏览器解析到 script 标签时，会停止向下解析，开始执行 script 中的 js 代码
      2. 直到执行完 js 代码，才会对继续向下解析
      3. 解析完之后，再进行布局，绘制等操作
   2. 如果是外部链接引入的 js
      1. 浏览解析到 script 标签的时候，发送请求获取想要引入的 js 文件
      2. 在等待 block.js 加载的过程中，浏览器没有对 script 标签后面的内容进行解析，而是对已经完成解析的这部分内容进行了布局和绘制，如果请求的慢的话，之前部分的标签内容可能出现在页面上
      3. 得到 js 文件后，开始执行 js 代码
      4. 直到代码执行完成后才开始对剩余内容解析，回流，重绘等操作
   3. 外部链接并使用 async 属性的 js
      对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。 对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。 该属性能够消除解析阻塞的 Javascript。解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析
   4. 外部链接并使用 defer 属性的 js
      这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。 有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成
3. 举两个样例（这里面带有个人理解，如有错误，可评论或私信我交流）
   1. 内联 js
      ```
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
          <script>
              // 此时只解析了上面部分，获取不到下面的dom，是undefined
              console.log(document.querySelector('ul'))
          </script>
      </head>
      <body>
          <ul>
              <li>Lisa</li>
              <li>Jennie</li>
              <!-- 这一段会阻塞页面解析，上面的部分也不会进行渲染显示到页面上，开始执行这一段代码 -->
              <script>
                  function mySleep(time){
                      const timeOld = new Date().getTime()
                      while(new Date().getTime() - timeOld < time){}
                  }
                  mySleep(3000) // 阻塞3秒
              </script>
              <!-- 等执行完之后，再向下解析，最后进行渲染 -->
              <li>Rose</li>
              <li>Jisoo</li>
          </ul>
      </body>
      </html>
      ```
   2. 外部链接引入的 js（用别人的）
      ```
      <html>
      <body>
        <h1>hello</h1>
        <!-- 解析到这里，停止解析，发送请求获取js文件，由于发送请求是异步，所以开始解析完成部分布局和绘制 -->
        <!-- 设置了获取时间延长 -->
        <!-- 渲染绘制时间早于js文件加载的时间，所以页面之前的内容加载出来，此时页面上显示hello -->
        <!-- 加载完之后，开始执行js代码 -->
        <script src="/block.js?t=100"></script>
        <!-- 执行完之后对剩余部分继续解析，渲染 -->
        <br>
        <h1>world</h1>
      </body>
      </html>
      ```

## 5. css 相关优化

1. 选择器性能：
   - 浏览器会从右到左解析 css 选择器，越靠右的选择器越具有唯一性，浏览器解析 CSS 属性的效率就越高，避免使用层级较深的选择器
   - 避免使用较慢的选择器，一些 CSS 选择器比其他选择器要慢，因此可以优化性能，例如避免使用后代选择器、通用选择器和属性选择器等
2. 避免使用 css 表达式（expression）：
   - css 表达式是动态设置 css 属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次，例
     ```
     left: expression(document.body.offsetWidth - 110 + "px");
     ```
3. 减少文件大小：
   - 通过压缩和合并 css 文件，可以减少页面加载时间。可以使用 css 压缩工具，如 YUI Compressor、CSSNano 和 CleanCSS 等
   - 避免使用不必要的 css 可以减少文件大小，并提高性能，可以通过删除未使用的 css 代码来优化性能，可以使用 css 的代码分析工具，如 PurifyCSS
4. 减少 css 文件中的 HTTP 请求可以提高页面加载时间，可以使用数据 URI 方案和内联样式来减少 HTTP 请求

## 6. 防抖节流

（这个太常见，就不细说了）

- 防抖：频繁操作，多次取最后一次
- 节流：频繁操作，按一定频率触发

## 7. 前端性能指标

以前衡量一个网站的好坏，所使用的指标很多，而且各有不同。所以 Google 推出了 Web Vitals， 定义了指标集，旨在简化和统一衡量网站质量的指标。在 Web Vitals 指标中，Core Web Vitals （核心网络指标）是其中最核心的部分，包含三个指标：

1. LCP（测验加载性能）：
   根据页面开始加载的时间报告可视区域内可见的最大图像或文本块完成渲染的计算时间，用于测验加载性能，衡量网站初次载入速度。 我们应该控制该值在 2.5 秒以内（最大其实就是指元素的尺寸大小，这个大小不包括可视区域之外或者是被裁剪的不可见的溢出。也不包括元素的 Margin / Padding / Border 等）
2. FID（测试交互性）：
   首次输入延迟时间，主要为了测量页面加载期间响应度，测量交互性。为了提供良好的用户体验，页面的 FID 应为 100 毫秒或更短，测量用户第一次与页面交互（单击链接、点按按钮等等）到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间。FID 只关注不连续操作对应的输入事件，例如点击，轻触，按键等。一般只考虑测量首次输入的延迟。FID 只考虑事件处理过程的延迟，不考虑事件处理花费的时间或者事件处理完成更新页面花费的时间
3. CLS（测试视觉稳定性）：
   累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1 或更少。CLS 即是测量整个页面生命周期内发生的所有意外布局偏移中最大一连串的布局偏移分数
   每当一个可见元素从一个已渲染帧变更到另一个已渲染帧时，就是发生了布局偏移。所谓一连串布局偏移，是指一个或者多个的布局偏移，这些偏移相隔少于 1 秒，总持续时间最大为 5 秒。而最大一连串就是所有的一连串布局偏移中偏移累计分数最大的一连串

除此之外还有其他比较常用的指标：

1. TTFB：
   首包时间，资源请求到获取第一个字节之间的时间，包括以下阶段的总和
2. FCP：
   首屏时间，首次内容绘制的时间，指页面从开始加载到页面内容的任何某一部分在屏幕上完成渲染的时间
3. FP：
   白屏时间，首次渲染的时间点。FP 和 FCP 有点像，但 FP 一定先于 FCP 发生，例如一个页面加载时，第一个 dom 还没绘制完成，但是可能这时页面的背景颜色已经出来了，这时 FP 指标就被记录下来了。而 FCP 会在页面绘制完第一个 dom 内容后记录。
4. SI：
   速度指数衡量页面加载期间内容的视觉显示速度，也就是页面填充快慢的指标。良好的 SI 应该控制在 3.4 以内。
5. TTI：可交互时间，指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。良好的 TTI 应该控制在 5 秒以内。
6. TBT：总阻塞时间，也就是从 FCP 到 TTI 之间的时间

## 8. 如何定位项目的性能问题（ 前端性能测试分析 ）

#### 借助第三方库

可以使用谷歌官方的 web-vitals 库衡量核心网页指标并生成报告

#### 性能分析工具（ 在开发者工具里 ）

Lighthouse 是谷歌官方开发的性能分析工具，目前已经嵌入到 chrome 开发者工具的选项卡中，不需要额外安装，可以直接使用

#### 性能测试网站（ 输入网址就可以测试性能的网站 ）

很多，比如 PageSpeed Insights（谷歌开发的），WebPageTest，Speedcurve 等

#### 通过 npm 或 docker（ 使用 npm 的话，你就可以在浏览器窗口中看到发生了什么，所以推荐 npm ）

sitespeed.io 是一款可监视和衡量网站前端性能的开源工具
简易通过 npm 测试：

1. 安装
   ```
   npm install -g sitespeed.io
   ```
2. 使用
   ```
   sitespeed.io https://www.sitespeed.io/ -b chrome
   ```
3. 查看报告
   在生成报告中，有一个网址，可以打开看到更适合观察的报告

#### 通过原生 js（ window.performance ）

window.performance 可以用来 监控网页与程序性能

（ [属性和方法的详情](https://blog.csdn.net/u014481405/article/details/107406761)，属性 和 方法不止下面的三种，[其他一些方法属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance) ）

- 它身上的属性有

  - memory 属性对象
    - 这个属性提供了一个可以获取到基本内存使用情况的对象
    ```
    memory: {
        jsHeapSizeLimit: 2172649472 // 内存大小限制
        totalJSHeapSize: 5891850 // 可使用的内存
        usedJSHeapSize: 4044814 // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize
    }
    ```
  - navigation 属性对象
    - 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等
    ```
    navigation: {
      redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来
      type: 0
      // type的取值：0 1 2 255
      // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）；例如：(用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)
      // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面；例如： (用户通过刷新，包括JS调用刷新接口等方式访问页面)
      // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）；例如：(用户通过后退按钮访问本页面)
      // 255 即 TYPE_UNDEFINED    非以上方式进入的页面
    }
    ```
  - timing 属性对象

    - 对象包含延迟相关的性能信息
      <img src="https://img-blog.csdnimg.cn/c98ee6447dbf42e494aa9692c6444130.png">

    ```
    timing: {
          // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
          navigationStart: 1594965271358,

          // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
          unloadEventStart: 1594965271476,

          // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳
          unloadEventEnd: 1594965271479,

          // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0
          redirectStart: 0,

          // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0
          redirectEnd: 0,

          // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前
          fetchStart: 1594965271374,

          // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
          domainLookupStart: 1594965271378,

          // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
          domainLookupEnd: 1594965271378,

          // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等
          // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
          connectStart: 1594965271378,

          // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等
          // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
          // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
          connectEnd: 1594965271437,

          // HTTPS 连接开始的时间，如果不是安全连接，则值为 0
          secureConnectionStart: 1594965271407,

          // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
          // 连接错误重连时，这里显示的也是新建立连接的时间
          requestStart: 1594965271437,

          // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
          responseStart: 1594965271468,

          // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
          responseEnd: 1594965271526,

          // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
          domLoading: 1594965271483,

          // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
          // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源
          domInteractive: 1594965271737,

          // DOM 解析完成后，网页内资源加载开始的时间
          // 在 DOMContentLoaded 事件抛出前发生
          domContentLoadedEventStart: 1594965271737,

          // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）
          domContentLoadedEventEnd: 1594965271768,

          // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
          domComplete: 1594965272079,

          // load 事件发送给文档，也即 load 回调函数开始执行的时间
          // 注意如果没有绑定 load 事件，值为 0
          loadEventStart: 1594965272079,

          // load 事件的回调函数执行完毕的时间
          loadEventEnd: 1594965272087
      }
    ```

- 它身上的方法有
  - getEntries() 方法
    - 这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求
  - now() 方法
    - 此方法可以精确计算程序执行时间；performance.now() 与 Date.now() 不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准
    - 并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）
    - 注意 Date.now() 输出的是 UNIX 时间，即距离 1970 的时间，而 performance.now() 输出的是相对于 performance.timing.navigationStart(页面初始化) 的时间
    - 使用 Date.now() 的差值并非绝对精确，因为计算时间时受系统限制（可能阻塞）。但使用 performance.now() 的差值，并不影响我们计算程序执行的精确时间。
  - mark() 方法
    - 此方法可以精确计算程序执行时间；使用 performance.mark() 标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了

## 9. SEO 优化

1. 白帽 SEO：白帽 SEO 是指遵守搜索引擎规则和准则的优化方法。它主要关注网站的用户体验和内容质量，通过合法的手段来提高网站的可见性和排名。白帽 SEO 的做法包括优化网站结构、关键词研究和应用、创建有价值的内容、建立高质量的链接等。

2. 黑帽 SEO：黑帽 SEO 是指采用违反搜索引擎规则和准则的优化方法，以获得快速而不可持续的排名提升。黑帽 SEO 常常利用一些不诚实的手段，如关键词堆砌、隐藏文字、购买链接、使用假页面等，来欺骗搜索引擎算法。这种做法往往违背用户体验和搜索引擎的原则，一旦被搜索引擎发现，可能会导致网站被惩罚或降低排名。
