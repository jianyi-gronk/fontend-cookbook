## 1. CSR（ Client Side Rendering，客户端渲染 ）

- 目前国内社区中主流框架比如 Vue、React 等严格意义上来说都是基于 CSR 的产物，意味着当发出一个请求时，服务器会返回一个空的 HTML 页面以及对应的 JavaScript 脚本，比如

  ```
  <html>
    <head>
       <title>test</title>
    </head>

    <body>
         <div id="root"></div>
         <script src="./index.js"> </script>
     </body>
   </html>
  ```

  - 当浏览器下载完成对应的 JS 脚本后才会动态执行对应的 JS 脚本然后在返回的 HTML 页面上进行渲染页面内容
  - 可以简单的理解为上述的 ./index.js 会在客户端下载完成后执行该脚本，从而执行 document.getElementById('root').innerHTML = '...' 来进行页面渲染

- 这种方式并不是从服务端下发的 HTML 文件来进行渲染页面，相反而是通过**浏览器获取到服务端下发 HTML 中的所有的 JS 文件后执行 JS 代码从而在客户端通过脚本进行页面渲染**
- 以及通常在 CSR 中当我们**点击任何页面中的导航链接并不会向服务端发起请求**，而是通过下载的 JS 脚本中的路由模块（ 比如 ReactRouter、VueRouter 这样的模块 ）**重新执行 JS 来处理页面跳转从而进行页面重新渲染**
- 上面是非常典型的 CSR ，浏览器仅仅接受一个用作网页容器的 HTML 页面，这方式通常也被称为 **单页面应用 ( SPA )**

## 2. SSR（ Server Side Render，服务端渲染 ）

- 比如旧时代的类似 Java 的 JSP 页面，不过显然 JSP 的方式每个 HTML 都需要单独请求服务器返回对应的 HTML 内容严格意义上来说这也是 SSR 的方式但是很明显这已经被时代淘汰了
- 目前国内广泛应用的服务端渲染技术大概的思路是这样的（ Next 的 SSR 模式也是同样的思路 ）：
  （ 当用户首次访问你的应用站点 ）
  1.  首先服务器会根据对应的 URL 在服务端根据对应路径渲染对应的 HTML 模版
      - 注意这里渲染的 HTML 模版是具有该页面真正的内容。同时它并**不具备任何交互逻辑**（比如 DOM 元素的点击事件），这是一份完全的静态站点
  2.  服务器会下发这份仅具有静态内容的 HTML 模版，同时这份模版中也会包含对应的 JavaScript 执行脚本
      - 此时静态 HTML 会立即显示在用户视野中，此时对于访问站点的用户来说首屏渲染相较于 SPA 应用来说会非常快。因为它并不需要在客户端浏览器上再次下载和执行 JavaScript 脚本来进行页面渲染
      - 其次，针对于 SEO 的优化也会非常良好，因为服务器上下发的 HTML 页面是包含当前站点的真实 HTML 结构，对于搜索引擎的爬虫来说会非常容易的匹配到当前关键字
  3.  然后浏览器会利用网络进程下载当前 HTML 脚本中的 JS 脚本
      - 因为首先呈现给用户的一份静态的 HTML 页面，并不具备任何交互效果。我们需要为页面上的元素增加对应交互，HTML 页面中的 JS 脚本中会包含网站的交互逻辑
  4.  最后，当下载完 HTML 脚本中的 JS 脚本后，会立即执行这些 script 脚本。从而发生一种被称为 **hydrate(水合)** 的过程，从而为页面上静态 HTML 元素再次添加对应的事件处理从而保证页面具有交互性
- **当 hydration 过程完成后，会由客户端框架接管网站的后续渲染**，在后续的导航链接跳转和页面渲染中和服务器已经没有任何关系，所以完全可以利用客户端的路由切换（ History Api/Hash Api ）利用 JS 进行页面渲染从而保证切换页面不用再次请求浏览器保证非常及时的页面交互

#### hydration 介绍

- 所谓的 hydration 简单来说，也就是客户端下载完成 JS 脚本后，浏览器会执行下载的 JS 脚本这些脚本中有部分内容会将已经存在的 HTML 内容通过执行下载的 JS 脚本添加上对应的事件监听器 从而保证页面的交互
  - 注意，在 React、Vue 中 hydration 并不意味这重新渲染。因为在 **Server 端已经渲染了和 Client 完全相同的 DOM 结构**所以完全没有必要再次重新渲染（ 这也是为什么在 Next 等框架中为什么必须要保证 Server 端和 Client 的渲染 HTML 结构必须一致的原因 ）
- **所以 hydration 的过程是给当前页面中已经生成的 HTML 页面添加上对应的事件监听器**
- 以 Next 举例来说（ Vue 也是同样的道理 ）
  - 当用户访问 www.test.com 时，服务端接收到请求调用 ReactDOMServer.renderToString() 生成当前页面的 HTML 静态结构
  - 服务器会下发这个 HTML 页面给客户端，同时这个 HTML 页面上也会携带一部分 JS 脚本 script 标签
  - 用户的浏览器中会立即展现到该 HTML 页面，同时也会下载对应 JS 脚本并执行
  - 当 JS 脚本执行完毕后，客户端会调用 ReactDOM.hydrate() 发生水合为当前页面的 HTML 页面添加事件交互处理，同时后续由 JS 接管页面的跳转渲染

#### hydration 难点

- **Hydration 过程的难点就在于我们需要知道需要什么事件处理程序，以及将该事件处理程序附加在哪个对应的 DOM 节点上**
- 这个过程中，我们需要处理
  - （ what ）每一个事件处理程序中的内容，绝大多数框架中的状态都做为闭包函数保存在内容中。所以需要 hydration 的过程来重新获取状态
  - （ where ）在搞清楚了每个事件处理函数的内容后，我们也需要将对应的事件处理函数附加到对应的 DOM 节点上，同时还要确保该监听器的正确事件类型
- 更加复杂每个事件处理函数中的内容是一个闭包函数，这个函数内部需要处理两种状态
  - APP_STATE：应用程序的状态。简单来说应用程序的状态就是 HTML 事件中的各个状态事件，如果不存在这些事件状态那么所有的内容都是没有任何交互效果的
  - FRAMEWORK_STATE：框架内部状态。通常我们会利用诸如 React 或者 Vue 等框架进行接替渲染。如果没有 FRAMETER_STATE，框架内部就不知道应该更新哪些 DOM 节点，也不知道应该在什么时候更新它们
- **通俗来说 Hydration 就是在客户端重新执行 JS 去修复应用程序内部的 APP_STATE 以及 FRAMEWORK_STATE**

#### 总结 SSR

- 我们为了让用户能尽早看到初始化页面，所以放弃了动态加载页面，剥离可交互，只保留静态页面（ 丢弃掉了 APP_STATE 和 FRAMEWORK_STATE ），然后为了应用程序的可交互性，添加回事件处理函数到对应的 DOM 节点上（ 恢复在服务器上被丢掉的 APP_STATE 和 FRAMEWORK_STATE ）
- 比如
  存在一个 Counter 的计数器组件

  ```
  export const Main = () => <>
     <Greeter />
     <Counter value={10}/>
  </>

  export const Greeter = () => {
    return (
      <button onClick={() => alert('Hello World!'))}>
        Trip Biz
      </button>
    )
  }

  export const Counter = (props: { value: number }) => {
    const store = useStore({ count: props.number || 0 });
    return (
      <button onClick={() => store.count++)}>
        {store.count}
      </button>
    )
  }
  ```

  在服务端渲染后，两个按钮不拥有任何处理状态的能力

  ```
  <button>Greet</button>
  <button>10</button>
  ```

  要使网页具有交互性，需要通过下载对应 HTML 页面中的 script 脚本并执行代码从而恢复按钮上的交互逻辑和状态

## 3. SSG（ Static Site Generation，静态网站生成 ）

- 页面访问： 当用户请求 SSG 页面时，服务器会直接发送预渲染的 HTML 文件，无需额外的服务器端处理。由于这些 HTML 文件是静态的，它们可以快速加载和显示，从而提高用户体验和首次内容绘制（FCP）速度
  - 其实就是在服务器上，渲染出所有页面，在前端访问页面，以及跳转到其他页面的时候，直接返回静态页面资源
- 预渲染： 在 SSG 中，页面内容在构建阶段（build time）就已经生成为静态 HTML 文件。这些预渲染的 HTML 文件可以包含完整的页面结构和内容，无需在客户端执行 JavaScript 即可显示。这与 SSR 不同，SSR 是在用户请求页面时动态在服务器端生成 HTML
- 构建和部署： 当你的应用程序使用 SSG 时，你需要将其构建为一组静态 HTML、CSS 和 JavaScript 文件。在构建过程中，应用程序会为每个页面生成一个对应的 HTML 文件，其中包含页面的结构和内容。完成构建后，你可以将这些静态文件部署到服务器或 CDN 上，以便用户访问

## 4. ISG（ Incremental Static Generation，增量静态生成 ）

- ISG 是一种结合静态内容生成和按需更新的策略。在构建阶段（build time）生成静态 HTML 文件，但允许在运行时按需重新生成这些文件
- ISG 旨在克服 SSG 和 SSR 之间的折中。通过使用 ISG，你可以为页面提供快速的加载速度（类似于 SSG），同时仍然能够在内容发生更改时动态更新页面（类似于 SSR）
- 初始构建：在构建阶段，ISG 会为每个页面生成静态 HTML 文件，就像 SSG 一样。这些文件会包含页面的结构和内容，无需在客户端执行 JavaScript 即可显示
- 页面访问：当用户请求 ISG 页面时，服务器会直接发送预渲染的 HTML 文件，无需额外的服务器端处理。由于这些 HTML 文件是静态的，它们可以快速加载和显示，从而提高用户体验和首次内容绘制（FCP）速度
- 内容更新：在内容发生更改时，ISG 允许按需重新生成静态 HTML 文件。这意味着当用户访问已更新的页面时，他们将看到最新的内容而无需等待服务器端重新生成整个页面。这可以通过定义一个“失效时间”来实现，在该时间后，页面将在下次请求时被重新生成
- 重新生成：当失效时间到达后，下一个请求页面的用户会触发页面的重新生成。在重新生成期间，用户会接收到过期的 HTML 文件，而服务器会在后台生成新的 HTML 文件。一旦新文件生成完毕，后续的用户访问将收到更新后的内容

## 5. CSR，SSR，SSG 和 ISG 的优缺点

#### CSR 优缺点

- CSR 优点：
  - 在页面初始化访问后加载速度极快且响应非常迅速。 在页面初始化后，网站所有的 HTML 内容都是在客户端通过执行 JS 生成，并不需要再次请求服务器即可重新渲染 HTML
  - 此外，有关任何实时的数据获取都可以通过 AJAX 请求对于页面进行局部更新从而刷新页面
- CSR 缺点：
  - 强依赖于 JS
    - 初始加载时间长，首次请求完服务器获取到 HTML 页面后，初始化的页面仍然需要在一段时间内处于白屏状态
      - 因为在初始渲染之前，浏览器必须等待 HTML 页面中的所有 Javascript 脚本加载完成并且执行完毕，此时页面才会进行真正的渲染
      - 虽然可以使用代码拆分或延迟加载等多种方案可以有效的减少上述的问题。但是这些方式始终是治标不治本，因为它并没有从本质上解决 CSR 存在的问题（ 强依赖于 JS 这个问题 ）
    - 因为依赖于 JS，所以当用户禁用 JS 时网站只能是白屏展现给用户等等
  - SEO（搜索引擎优化） 的负面影响
    - 所谓 CSR 本质上首先会返回一个空的 HTML 页面，所以这也就造成了在搜索引擎对于该页面的数据爬取中会认为它是一个空页面。从而影响对应的搜索结果排名
    - 虽然说在最新的 Google 中已经可以触发执行 JS 对于网站进行关键字排名，但是在 JS 体积足够大的时候针对于 SEO 仍然是存在一部分问题导致无法解析出正确的关键字匹配

#### SSR 优缺点

- SSR 优点：
  - 不强依赖于 JS
    - 更快的首屏渲染，因为相较于 SPA 它少了在 Client 中下载和执行 JS 脚本后渲染的过程
    - 页面不需要 JS 也可以正常渲染，虽然没有 JS 意味着页面失去了可交互性。但对于禁用 JS 的用户来说，展示一些静态内容总比 SPA 应用的白屏来的更加友好一些对吧
  - 更好的搜索引擎优化 SEO 方式，HTML 模板是从服务端直接下发这也就导致搜索引擎爬虫中更多的关键字匹配
- SSR 缺点：
  - 强依赖于服务
    - 针对于 CSR 的方式它是一种纯静态资源。我们可以直接将它放在 CDN 上就可以良好的用户访问到，而 SSR 的方式必须依赖于一个服务器进行服务端预渲染（ 当然纯 SSG 应用我们不在这个讨论范围之内 ）
    - 同时，有服务的地方就存在并发压力，当需要为应用考虑服务端渲染的方式时，一定不要忘记为服务器进行压测
  - TTI （ Time to Interactive ）可交互时间的增长，虽然说 SSR 的方式有效的缩短了首屏加载的方式，但是会增加 TTI
    - 所谓的 TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间
    - 因为 SSR 的方式在用户访问时会下发当前页面中静态的 HTML 内容，但是页面需要用户交互效果缺又需要下载和执行完成 JS 脚本发生 hydatrion 后才具有交互性，这也就造成页面的 TTI 相较于 CSR 方式会有所差劲，因为 CSR 在渲染完成后就会立即具有交互性（ 不需要其他任何多余步骤 ）

#### SSG 优缺点

- SSG 优点：
  - 高性能：预渲染的 HTML 文件可以直接在浏览器中显示，无需客户端执行 JavaScript，从而提高首次内容绘制速度
  - 搜索引擎优化（SEO）：由于 SSG 生成的 HTML 文件包含完整的页面结构和内容，搜索引擎爬虫可以更容易地抓取和解析页面，从而提高 SEO 效果
  - 可扩展性：静态文件可以轻松部署到 CDN，从而提高应用程序的可扩展性。此外，SSG 减轻了服务器端的压力，因为服务器只需提供静态文件，而无需动态生成 HTML
  - 安全性：由于 SSG 页面在构建阶段生成，服务器不需要执行任何动态代码，这降低了安全风险
- SSG 缺点：
  - 不适用于实时更新：SSG 页面在构建阶段生成，无法实时更新。如果网站需要实时数据或动态内容，SSG 可能不是最佳选择。然而，可以通过 AJAX 请求和客户端 JavaScript 实现部分动态内容
  - 构建时间：随着页面数量的增加，构建时间可能会变得较长。这可能会影响开发过程中的迭代速度和部署时间

#### ISG 优缺点

- ISG 优点：
  - 更灵活的内容更新：与传统的 SSG 不同，ISG 允许您在运行时按需生成和更新页面，而无需重新构建整个网站。这使得 ISG 更适用于内容较为动态或更新频率较高的网站
  - 减少构建时间：通过只在构建阶段生成部分页面，ISG 可以缩短构建时间，特别是对于具有大量页面的网站
  - 提高性能和可扩展性：ISG 生成的静态页面可以直接部署到 CDN，从而提高性能和可扩展性。与 SSR 相比，ISG 减轻了服务器端的压力，因为服务器只需提供静态文件，而无需动态生成 HTML
  - 支持 SEO：与 SSG 类似，ISG 生成的 HTML 文件包含完整的页面结构和内容，有助于搜索引擎爬虫抓取和解析页面，从而提高 SEO 效果
- ISG 缺点：
  - 初次访问时间：当用户首次访问尚未生成的页面时，服务器需要生成该页面并将其缓存以供后续访问。在页面生成期间，用户可能会遇到稍长的加载时间。然而，一旦页面被缓存，后续访问将具有与 SSG 类似的高性能
  - 服务器资源消耗：虽然 ISG 可以减少构建时间，但它仍然需要服务器在运行时按需生成页面。这可能会导致服务器资源消耗，尤其是在高并发访问时。为确保良好的性能，您可能需要优化服务器配置和缓存策略

## 5. 如何选择 CSR，SSR，SSG 和 ISG

- 性能和加载速度：
  - SSG 和 ISG 通常具有最快的加载速度，因为页面内容在构建时已经预渲染好，无需额外的服务器端处理或客户端 JavaScript 执行。这对于首次内容绘制（FCP）和搜索引擎优化（SEO）非常有利
  - SSR 具有较快的首次内容绘制速度，因为页面内容由服务器生成并直接发送给客户端。但是，服务器端处理可能会导致一定的性能开销
  - CSR 需要在客户端执行 JavaScript 来生成页面内容，这可能会导致较慢的首次内容绘制速度。然而，一旦页面加载完成，客户端渲染可以提供较好的交互性能和用户体验
- 用户交互和动态内容：
  - SSG 更适用于内容较为静态、用户交互较少的网站。虽然可以通过 JavaScript 添加动态功能，但 SSG 本身并不提供实时数据或动态内容的更新
  - ISG 在 SSG 的基础上提供了更灵活的内容更新，适用于内容较为动态、更新频率较高或有大量页面的网站。ISG 可以在运行时按需生成和更新页面，而无需重新构建整个网站
  - CSR 和 SSR 都可以提供丰富的用户交互和动态内容。CSR 在客户端生成和更新页面内容，通常适用于单页面应用（SPA）或需要密集用户交互的应用。SSR 适用于需要实时数据或频繁更新内容的应用，同时希望保持较好的首次内容绘制速度和 SEO
- 搜索引擎优化（SEO）：
  - SSG 和 ISG 通常具有较好的 SEO，因为它们生成的 HTML 页面可以被搜索引擎爬虫更容易地抓取和索引
  - SSR 也具有较好的 SEO，因为页面内容由服务器生成并直接发送给客户端，搜索引擎爬虫可以更容易地抓取和解析页面
  - CSR 可能会对 SEO 产生负面影响，因为搜索引擎爬虫可能无法完全解析和执行 JavaScript。然而，许多现代搜索引擎（如 Google）已经能够对 JavaScript 进行一定程度的解析
- 开发和维护成本：
  - SSG 和 ISG 通常具有较低的开发和维护成本，因为它们不需要服务器端逻辑。然而，对于需要动态内容或实时数据的网站，实现这些功能可能会变得复杂和耗时
  - CSR 和 SSR 可能具有较高的开发和维护成本，因为它们需要更复杂的前后端逻辑和技术栈。但是，这些技术可以更好地满足动态内容和实时数据的需求

## 6. Next.js（ 经典的 SSR 处理框架 ）

#### 基础介绍

- Next.js 是一个基于 React 的开源前端框架，由 Vercel 开发，专为服务端渲染（SSR）和静态网站生成（SSG）优化的应用程序。Next.js 提供了一套简单易用的 API 和工具集，使开发人员能够快速构建高性能、SEO 友好且具有良好用户体验的 Web 应用程序

#### 主要特性

1. SSR：Next.js 自动为每个页面提供服务端渲染，无需额外配置。这意味着在浏览器收到页面内容之前，页面已经在服务器上生成。这可以提高首屏加载速度，提升用户体验，并优化搜索引擎优化（SEO）
2. SSG 和 ISG：Next.js 支持静态网站生成（SSG），允许你在构建阶段生成静态 HTML 文件。此外，Next.js 还提供了增量静态生成（ISG）功能，使你能够在运行时按需更新静态内容
3. 文件系统路由：Next.js 通过文件系统自动创建页面路由。这意味着在 pages 目录下创建的每个文件都将自动变为一个可访问的路由。这样可以简化路由配置，使开发过程更加高效
4. 代码分割和懒加载：Next.js 自动实现代码分割和懒加载，以优化应用程序性能。它会根据路由将代码分割成独立的 JavaScript 包，仅在需要时加载。这可以减少页面加载时间，提高用户体验
5. API 路由：Next.js 提供了一个简单的 API 路由系统，允许你在 pages/api 目录下快速创建 API 端点。这样你可以在同一个项目中管理前端和 API，简化项目结构
6. CSS 和 Sass 支持：Next.js 内置对 CSS 和 Sass 的支持，你可以直接在组件中导入样式文件。此外，Next.js 还提供了 CSS-in-JS 解决方案，如 styled-jsx 和 emotion 等
7. 插件和社区生态：Next.js 拥有一个庞大的插件生态系统，提供了许多预构建的功能和扩展，如数据获取、状态管理、响应式设计等。这使得开发人员能够快速集成新功能并保持项目的可维护性
8. 快速部署：Next.js 由 Vercel 开发，可以方便地将项目部署到 Vercel 平台。当然，你也可以选择其他服务提供商进行部署。Next.js 输出的静态文件和服务端渲染应用程序可以部署到任何支持 Node.js

#### 用 Next.js 去搭建一个简单的 SSR 服务器

1. 打开终端，运行以下命令创建一个新的 Next.js 项目：
   ```
   npx create-next-app my-next-app
   ```
   - my-next-app 是项目名称，可以自定义
   - 创建的项目包含以下文件和文件夹：
     - pages：存放页面组件的文件夹，每个文件对应一个路由
     - public：存放静态资源（如图片）的文件夹
     - styles：存放全局样式文件（如 CSS 或 Sass）的文件夹
     - package.json：项目的配置文件，包括依赖、脚本等信息
     - README.md：项目说明文件
     - .gitignore：Git 忽略文件
2. 进入项目目录：
   ```
   cd my-next-app
   ```
3. 创建一个服务端渲染的页面，在 pages 文件夹下创建一个新文件，例如 ssr-page.js，并编辑 ssr-page.js，添加以下代码：

   ```
   javascriptCopy code
   import React from 'react';

   function SSRPage({ serverData }) {
     return (
       <div>
         <h1>服务端渲染页面</h1>
         <p>从服务端获取的数据：{serverData}</p>
       </div>
     );
   }

   export async function getServerSideProps() {
     // 在此处获取服务端数据
     const serverData = 'Hello, SSR!';

     // 返回的数据将作为组件的 props
     return { props: { serverData } };
   }

   export default SSRPage;
   ```

   - 这里使用 getServerSideProps 函数获取服务端数据。该函数将在每次请求时运行，返回的数据将作为组件的 props

4. 在终端中，运行以下命令启动项目：
   ```
   npm run dev
   ```
5. 在浏览器中访问 http://localhost:3000/ssr-page，能看到新创建的服务端渲染页面

#### Nuxt.js （ 适用于 Vue 版的 Next.js ）

- Nuxt.js 和 Next.js 在功能和理念上几乎相似，主要区别就是 Next.js 适用于 React，而 Nuxt.js 适用于 Vue

#### 用 Next.js 去搭建一个简单的 SSR 服务器

1. 打开终端，运行以下命令创建一个新的 Nuxt.js 项目，my-nuxt-app 是项目名称，可以自定义：
   ```
   npx create-nuxt-app my-nuxt-app
   ```
   - 选择项目配置。创建过程中，会提示你选择一些配置选项，例如 UI 库、测试框架等。可以按照自己需求进行选择，或者使用默认设置
   - 创建的项目包含以下文件和文件夹：
     - assets：存放未编译静态资源（如 LESS、Sass、JavaScript 文件）的文件夹
     - components：存放 Vue.js 组件的文件夹
     - layouts：存放布局组件的文件夹
     - middleware：存放中间件的文件夹
     - pages：存放页面组件的文件夹，每个文件对应一个路由
     - plugins：存放插件的文件夹
     - static：存放静态资源（如图片）的文件夹
     - store：存放 Vuex 状态管理相关文件的文件夹
     - nuxt.config.js：Nuxt.js 项目的配置文件
     - package.json：项目的配置文件，包括依赖、脚本等信息
     - README.md：项目说明文件
     - .gitignore：Git 忽略文件
2. 进入项目目录：
   ```
   cd my-nuxt-app
   ```
3. 创建服务端渲染的页面，在 pages 文件夹下创建新文件，例 ssr-page.vue，并编辑 ssr-page.vue，添加以下代码：

   ```
   <template>
     <div>
       <h1>服务端渲染页面</h1>
       <p>从服务端获取的数据：{{ serverData }}</p>
     </div>
   </template>

   <script>
   export default {
     async asyncData({ params }) {
       // 在此处获取服务端数据
       const serverData = 'Hello, SSR!';
       // 返回的数据将作为组件的 data
       return { serverData };
     },
   };
   </script>
   ```

   - 这里使用 asyncData 函数获取服务端数据。这个函数将在每次请求时运行，返回的数据将与组件的 data 对象合并

4. 在终端中，运行以下命令启动项目：
   ```
   npm run dev
   ```
5. 在浏览器中访问 http://localhost:3000/ssr-page，能看到新创建的服务端渲染页面

## 7. qwik（ 号称世界上第一个 O(1) 的 JavaScript SSR 框架 ）

#### 优化点

- 当前 SSR 的方案是，（ 第一步 ）先根据对应的 URL 在服务端根据对应路径渲染对应的 HTML 模版，（ 第二步 ）然后根据 URL 返回仅具有静态内容的 HTML 模版，（ 第三步 ）然后下载 JS 脚本，（ 第四步 ）并进行 hydrate（ 水合 ）
- 如果能在第一步渲染 HTML 页面时，就添加对应的事件处理，后续的 3 步就可以省略下来
- 本质就是同一个组件的渲染逻辑被执行了两遍，这是一个非常冗余且耗费性能的过程，一遍丢弃可交互，一遍找回可交互
- qwik 的工作原理就是在服务端序列化 HTML 模版，避免水合重复操作，加上更加细粒的代码控制配合惰性加载事件处理程序以及事件委托来缩短首屏时间

#### Resumability 内容（ 更加优雅的 hydartion 替代方案 ）

- 将所有必需的信息序列化为 HTML 的一部分
  - qwik 将需要的状态以及事件序列化保存在 Server 端下发的 HTML 模版中，需要序列化信息需要包括 WHAT（事件处理函数内容），WHERE（哪些节点需要哪些类型的事件处理函数），APP_STATE（应用状态）和 FRAMEWORK_STATE（框架状态）
  - 因为我们在 HTML 中的每个元素中都已经通过序列化从而在它的标签属性上记录了对应事件处理函数的位置以及脚本内容（自然内容中也包含对应的状态），所以当获得 HTML 页面后其实就可以说此时页面已经加载完毕了而不需要任何实时的 JS 执行
  - 这样做的好处是在 qwki 中完全可以省略 hydration 的多余步骤，甚至可以说完全抛弃了 hydration 的概念，客户端完全不必和服务端的 HTML 进行 hydration，相同的渲染内容仅仅是在 Server 端进行一次渲染客户端即可拥有对应的事件处理内容
- 依赖于事件冒泡来拦截所有事件的全局事件处理程序（ 事件委托 ）
  - qwik 中事件处理程序是在全局处理的，这样我们就不必在在特定的 DOM 元素上单独注册所有事件
- qwik 内部存在一个可以延迟恢复事件处理程序的工厂函数
  - 该工厂函数主要用于处理 WHAT 阶段，也就是用来识别某个事件处理函数中应该存在什么脚本逻辑
  - 延迟加载模块的确会存在多个 small bundle 的问题，可是当我们拥有的 bundle 越多，其实我们就拥有更多的自由度去以各种各样的方式去拼装成为单个大的 bundle
  - qwik 中存在足够的方式提供给我们将多个小的 chunk 自由组合成为一个从而有效的减少细碎 chunk 的数量，当然这个点在传统构建工具中也是这样
- qwik 进行这些事件 & 状态的恢复时，是通过在返回的 HTML 页面中内嵌的所谓 qwikloader 的 script 脚本（这段脚本的大小不超过 1kb）配合 qwikjson 映射表，从而在全局进行恢复事件和状态的逻辑

#### Resumability 带来的好处

- 对比 Hydration，Resumable 直接获取 HTML 后页面其实就已经准备完毕，这无疑对于性能的提升是巨大的，我们在 HTML 中的每个元素中都已经通过序列化从而在它的标签属性上记录了对应事件处理函数的位置以及脚本内容（自然内容中也包含对应的状态），所以当获得 HTML 页面后其实就可以说此时页面已经加载完毕了而不需要任何实时的 JS 执行
- qwki 中完全可以省略 hydration 的多余步骤，甚至可以说完全抛弃了 hydration 的概念，客户端完全不必和服务端的 HTML 进行水合，所以简直可以说是接近零 JS 的执行过程，相同的渲染内容仅仅是在 Server 端进行一次渲染客户端即可拥有对应的事件处理内容，最终在用户触发事件时候达到惰性的创建事件并执行，这个过程中完全没有重复任何服务器已经完成的任何工作

#### qwik 举例

- 存在计数器

  ```
  export const Main = () => <>
     <Greeter />
     <Counter value={10}/>
  </>

  export const Greeter = () => {
    return (
      <button onClick={() => alert('Hello World!'))}>
        Trip Biz
      </button>
    )
  }

  export const Counter = (props: { value: number }) => {
    const store = useStore({ count: props.number || 0 });
    return (
      <button onClick={() => store.count++)}>
        {store.count}
      </button>
    )
  }
  ```

- 在 qwik 编译后，服务端会序列化对应组件的 HTML 结构从而下发如下的模板
  ```
  <div q:host>
    <div q:host>
      <button on:click="./chunk-a.js#button">Trip Biz</button>
    </div>
    <div q:host>
      <button q:obj="1" on:click="./chunk-b.js#count[0]">10</button>
    </div>
  </div>
  <script id="qwikloader">/* qwik 中设置全局事件监听器的代码 */</script>
  <script id="qwik/json">/* 用于反序列化的 JSON 相关信息 */</script>
  ```
  - 经过 qwik 编译后的 html 结构并不单单只有 DOM 元素，同时会在对应需要状态 & 事件的 DOM 元素上通过 HTML 元素属性来记录当前元素的事件和状态信息，这既是 qwik 中的序列化
  - 比如上边 button 的 on:click 属性记录了该元素后续需要恢复的所有信息
  - 序列化这一步是在服务端渲染时完成的，这也就意味着后续客户端可以通过服务端序列化的属性信息进行反序列化从而达到所谓的可恢复性而不需要重复执行组件
