## 1. 图片种类

1. JPEG（.jpg）：
   - JPEG 是一种常用的图像格式，它使用有损压缩算法，可以在保持较高图像质量的同时减小文件大小
   - JPEG 图片的文件大小通常较小，适合用于照片和复杂图像。但是，压缩率较高可能导致一些细节损失
   - JPEG 适用于大部分的照片和复杂图像，如网页中的背景图片、产品展示图等
2. PNG（.png）：
   - PNG 是一种无损压缩的图像格式，可以保持图像质量的同时减小文件大小，它支持透明度和更高的色彩深度
   - PNG 图片的文件大小通常较大，特别是对于复杂图像
   - PNG 格式适用于图标、图形和需要透明背景的图像，如网页中的 Logo、按钮图标、线条图形等
3. GIF（.gif）：
   - GIF 是一种支持动画和透明度的图像格式，它使用 LZW 无损压缩算法
   - GIF 图片的文件大小通常较小，但是对于复杂图像可能会有较高的文件大小
   - GIF 格式适用于简单的动画、图标和低色彩深度的图像，如网页中的加载动画、表情动图等
4. WebP（.webp）
5. SVG（.svg）
6. 字体图标（.ttf，.otf，.woff，.eot，.svg）

（ 一般可以用 WebP 代替 JPEG，PNG，GIF；用 SVG 代替 字体图标 ）

（ 有损压缩和无损压缩的主要区别在于是否会损失原始数据的一部分信息。有损压缩可以实现更高的压缩比，但可能导致质量降低；无损压缩则可以保持原始数据的完整性，但压缩比相对较低 ）

## 2. WebP

- WebP 是一种谷歌开发的图像格式，它使用有损和无损压缩算法，可以在保持较高图像质量的同时减小文件大小
  - 有损 WebP 压缩使用的图像编码方式与 VP8 视频编解码器中压缩视频关键帧的方法相同。通过对已经编码的图像部分进行分析和预测，来推测未编码的图像部分。为了提高预测的准确性，图像会被分成更小的块进行处理，分块越细预测越准确。然后，将预测的图像数据与原始图像数据进行比较，得到它们之间的差异。最后，只对这些差异进行编码，以减小文件的大小。通过这种方式，可以在保持较高图像质量的同时控制文件的大小
  - 无损 WebP 压缩会根据已有的图像信息，尽可能地还原原始图像的像素值，以保证图像的质量。当某些像素无法准确还原时，会使用一种本地调色板的技术来进行优化处理，以尽量接近原始图像。这样可以在减小文件大小的同时，保持图像的无损品质
- WebP 适用于网页上的图像显示，可以提供更快的加载速度和较小的文件大小，通常用于替代 JPEG 和 PNG 格式的图像，特别是对于需要高质量图像的网页
- WebP 综合了 JPG、PNG 和 GIF 的优点，同时具有更小的文件大小、更好的图像质量、支持透明度 和 动画 等特性。它可以替代 JPG、PNG 和 GIF 格式，从而提供更好的性能和用户体验
- WebP 的兼容性可能相对较差。尽管现代浏览器（如 Chrome、Firefox、Edge 等）已经原生支持 WebP 格式，但并非所有的浏览器都支持。在一些旧版的浏览器或不支持 WebP 的环境中，您可能需要提供备用的 JPG、PNG 或 GIF 图片来确保兼容性

## 3. 图片实现动画

- 实现原理
  1.  多帧图像：图片由多个图像帧组成，每一帧都是一个完整的静态图像
  2.  延迟时间：每一帧都有一个指定的延迟时间，表示该帧在动画中显示的持续时间
  3.  循环播放：图片可以设置循环次数，指定动画播放的重复次数。如果循环次数设置为 0，则表示无限循环播放
  4.  顺序播放：图片按照帧的顺序依次显示，每一帧显示的时间由延迟时间决定。当所有帧循环播放完毕后，动画会重新开始
- GIF 和 WebP 的动画实现的区别：
  1.  压缩算法：GIF 使用无损的 LZW 压缩算法，可以减小文件大小而不损失图像质量。WebP 则使用有损和无损压缩算法，可以根据需要在保持较高质量的同时减小文件大小
  2.  颜色支持：GIF 是 8 位颜色索引图像格式，最多支持 256 种颜色。这使得 GIF 适用于简单的图像和动画。而 WebP 支持更丰富的颜色空间，包括真彩色图像和透明度，能呈现更丰富和真实的颜色
  3.  动画支持：GIF 是常见的动画格式，可以通过在单个文件中包含多个图像帧来创建动画效果。每个图像帧都有自己的延迟时间，可以控制动画的速度和循环次数。WebP 也支持动画，但在动画方面比 GIF 更高效，使用帧间压缩和预测来减小文件大小，并提供更好的动画效果
  4.  透明度支持：GIF 支持简单的透明度，可以将一个颜色定义为透明。这使得 GIF 可以创建具有透明背景的图像。WebP 支持更复杂的透明度，可以实现像素级的透明度控制，能够创建更复杂的图像和动画，其中透明度可以应用于图像的任何部分
  5.  文件大小：WebP 通常比 GIF 具有更小的文件大小，尤其是对于相同质量的图像。这是因为 WebP 使用更先进的压缩算法和更高效的图像编码方式。较小的文件大小意味着在网络上加载图像时更快速和更高效

## 4. SVG

#### 基础介绍

- SVG 是一种基于 XML 的矢量图形格式，它使用 XML 标记语言来描述图形。SVG 图形可以通过使用形状、路径、文本、图像等元素来创建，所以 SVG 本质是一个文本文件
- 由于 SVG 是矢量图形，因此它可以无损地缩放和放大，而不会失去图像质量
  - 矢量图形是一种使用数学公式来描述图形的图像格式。它通过定义图形的几何形状、线条、曲线、颜色等属性来表示图像
- SVG 图形可以通过 CSS 样式和 JavaScript 来进行控制和交互
- 由于 SVG 是基于文本的，因此它可以通过文本编辑器进行编辑和修改
- SVG 图形适合用于绘制图标、图表、地图等需要保持清晰度的图形

#### 页面中使用 SVG

1. SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作
   ```
   <!DOCTYPE html>
   <html>
   <head></head>
   <body>
   <svg
     id="mysvg"
       xmlns="http://www.w3.org/2000/svg"
       viewBox="0 0 800 600"
       preserveAspectRatio="xMidYMid meet"
   >
       <circle id="mycircle" cx="400" cy="300" r="50" />
   <svg>
   </body>
   </html>
   ```
2. SVG 代码也可以写在一个独立文件中，然后用 \<img\>、\<object\>、\<embed\>、\<iframe\>等标签插入网页
   ```
   <img src="circle.svg">
   <object id="object" data="circle.svg" type="image/svg+xml"></object>
   <embed id="embed" src="icon.svg" type="image/svg+xml">
   <iframe id="iframe" src="icon.svg"></iframe>
   ```
3. CSS 也可以使用 SVG 文件
   ```
   .logo {
     background: url(icon.svg);
   }
   ```

#### 编写 SVG 代码内容

- SVG 代码都放在顶层标签 \<svg\>之中，如果直接放在页面中，可以用 JavaScript 和 CSS 进行操作
- SVG 的 CSS 属性与网页元素有所不同
  - fill：填充色
  - stroke：描边色
  - stroke-width：边框宽度

```
----------   html   ----------
<svg width="300" height="180">
    <circle cx="30"  cy="50" r="25" id="mycircle" />
    <circle cx="90"  cy="50" r="25" class="red" />
    <circle cx="150" cy="50" r="25" class="fancy" />
</svg>

----------   js   ----------
var mycircle = document.getElementById('mycircle');

mycircle.addEventListener('click', function(e) {
  console.log('circle clicked - enlarging');
  mycircle.setAttribute('r', 60);
}, false);

----------   css   ----------
.red {
  fill: red;
}

.fancy {
  fill: none;
  stroke: black;
  stroke-width: 3pt;
}

.fancy:hover {
  stroke: #090;
  fill: #fff;
}
```

#### SVG 图像转 Canvas 图像

1. 首先，需要新建一个 Image 对象，将 SVG 图像指定到该 Image 对象的 src 属性

   ```
   var img = new Image();
   var svg = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});

   var DOMURL = self.URL || self.webkitURL || self;
   var url = DOMURL.createObjectURL(svg);

   img.src = url;
   ```

2. 当图像加载完成后，再将它绘制到 \<canvas\>元素
   ```
   img.onload = function () {
       var canvas = document.getElementById('canvas');
       var ctx = canvas.getContext('2d');
       ctx.drawImage(img, 0, 0);
   };
   ```

## 5. Canvas

#### 基础介绍

- Canvas 使用 JavaScript 来绘制图形，通过在画布上绘制像素点来创建图形
- 由于 Canvas 绘制的图形是位图图形，因此它不能无损地缩放和放大，并且在放大时会出现像素化的效果
  - 在位图图形中，图像被分割成一个个像素点的网格，每个像素点都有自己的颜色信息，都是一个离散的、固定大小的点，当位图图形被放大时，每个像素点都会被放大，导致图像变得模糊和失真。同样，当位图图形被缩小时，一些细节可能会丢失。因此，位图图形在放大或缩小时会出现像素化的效果
- Canvas 是一个 HTML5 元素，它提供了一个用于绘制图形的空白画布。还提供了一系列的绘图 API，包括绘制路径、矩形、圆形、文本等功能
- Canvas 适合用于实时的、动态的图形绘制，例如游戏、数据可视化等

#### SVG 和 Canvas 的区别

- SVG 适合用于静态的、需要保持清晰度的图形绘制，而 Canvas 适合用于动态的、实时的图形绘制，原因如下
  1.  性能：
      - Canvas 使用基于像素的绘图方式，直接操作像素点。这使得 Canvas 在绘制复杂、实时的动画或游戏时具有更高的性能
      - SVG 是基于矢量图形的，需要解析和渲染 XML 标记，对于大规模的动画或游戏场景，性能可能不如 Canvas
  2.  动态更新：
      - Canvas 提供了一系列的绘图 API，可以通过 JavaScript 动态地更新和修改绘图内容。这使得 Canvas 非常适合实时更新和交互，可以实现复杂的动画效果和用户交互
      - SVG 的更新和交互需要通过 DOM 操作，相对来说较为繁琐
  3.  像素级控制：
      - Canvas 可以直接操作像素点，可以实现更精细的图像处理和特效。例如，可以使用 Canvas 绘制粒子效果、光影效果、图像滤镜等
      - SVG 的图形元素是基于矢量的，对于一些像素级的处理可能不够灵活

#### GIF 和 Canvas 的区别

- GIF 由一系列静态图像帧组成，适合用于实现简单的动画效果，而 Canvas 适合用于实时更新和交互等复杂的动画效果
  1.  技术原理：
      - Canvas 动画是通过使用 JavaScript 在 Canvas 元素上绘制一系列图像帧来实现的。每一帧都是通过绘制新的图像来更新画布上的内容
      - GIF 动画是一种基于位图的图像格式，它使用一系列预定义的图像帧按照一定的时间间隔播放
  2.  可控性：
      - Canvas 动画通过 JavaScript 可以实现对动画的完全控制。开发者可以自定义动画的帧率、动画效果、交互等
      - GIF 动画是静态的，无法进行动态的交互和控制
  3.  文件大小：
      - Canvas 动画可以通过绘制图形元素和使用动画技巧来实现动画效果，因此文件大小通常较小
      - GIF 动画是一种位图图像格式，每一帧都是一个完整的图像。因此，GIF 动画文件通常比较大，特别是在帧数较多或者图像细节较复杂的情况下
  4.  兼容性：
      - Canvas 动画是基于 HTML5 的 Canvas 元素实现的，几乎所有现代浏览器都支持
      - GIF 动画是一种通用的图像格式，几乎所有的浏览器和图像查看器都支持 GIF 格式
  5.  动画效果：
      - Canvas 动画可以实现更复杂、更丰富的动画效果，包括形状变换、颜色渐变、透明度变化等
      - GIF 动画在动画效果方面相对较为简单，主要是帧之间的切换

## 6. 字体图标

#### 使用指定字体的步骤

1. 读取文字内容转换成对应的 unicode 码
2. 根据 HTML 里设置的 font-family（如果没设置则使用浏览器默认设置）即去查找电脑里（如果有自定义字体 @font-face ，则加载对应字体文件）对应字体的字体文件
3. 找到文件后根据 unicode 码去查找绘制外形，找到后绘制到页面上

#### 实现字体图标的步骤

1. 设计师通过设计软件制作 svg 格式的图标
2. 使用软件导入到字体文件中，例如 fontcreator，然后自己书写 unicode 编码
3. 生成兼容大部分浏览器的字体文件（ttf，otf，woff，eot，svg）
4. 通过 css 样式 @font-face 导入字体文件，并设置公共样式，设置具体的 icon 名称 和 Unicode 编码一一对应
5. 前端调用：\<i class='iconfont iconfont-arrow-l'\>\</i\>

```
// unicode 码 分别对应 我 人 谷 三个字
<p>Hello &#x6211; &#x4eba; &#x8c37;</p>

p {
    font-family: serif;
}


// 如果觉得在标签中写 unicode 码 导致可读性太低，可以抽离到伪元素中
<span class=“icon”></span>

@font-face {
  font-family: “hello”;
  src: url(‘//at.alicdn.com/t/font_1475388520_7015634.ttf’) format(‘truetype’)
}
.icon:before {
  font-family:“hello”;
  content: “\e600”;
}
</style>
```

#### 字体图标和 SVG 的区别

- SVG 是首选，全方面优于 字体图标，字体图标 只是在兼容性上，略微优秀一点点
  1.  精致度：
      - SVG 是最直接的矢量图形了，在任何大小的情况下都能细腻的显示图标，尤其是在 retina 显示屏上，效果绝佳，这是众多开发者选择 SVG 的最主要一个原因
      - 字体图标也是矢量，但因为字体图标本身是一个字符，所以会受到系统级反锯齿（如 ClearType 和 Retina）影响，导致本来锐利的小尺寸的图标边缘不锐利
  2.  视觉效果：
      - SVG 可以是多颜色的，且 SVG 的各个部分可以单独分开添加交互的动画效果，比如鼠标划过就打开的信封，或是鼠标点击就转动的手表
      - 字体图标是单一的整体，它是单色，添加起交互效果往往是针对整体的放大缩小，变色旋转等等，有网站是把彩色图标拆分成单色图标，再叠加显示，显然用 SVG 显然更方便
  3.  定位问题：
      - SVG 可以直接定位到 SVG 元素
      - 字体图标的定位比较困难，图标是通过伪元素插入的，典型就是复选框和文字标签对不齐，要检查图标的 CSS line-height，vertical-align，letter-spacing，word-spacing，display，寻找对不齐的原因
  4.  引用问题
      - SVG 可以直接内嵌到页面中，不需要额外请求
      - 字体图标当遇到网络较差，或者用户使用了屏蔽网页字体的插件时，图标会变成 口口口，需要在字体文件加载完成之前尝试隐藏所有图标
  5.  兼容性
      - SVG 兼容到 IE 8
      - 字体图标兼容到 IE 6

#### 为什么字体图标会有抗锯齿

- 锯齿问题的产生是由于浏览器默认有一个抗锯齿的机制。而字体图标的重叠部分由于颜色混合后无法很好的抗锯齿，从而导致了一些锯齿现象。而字体图标在设计时，往往是基于一些矢量图形进行的，而矢量图形无论放到多大或变成多小，其边缘都是光滑的，不会出现锯齿。但是，当将其转换成字体文件后，放大或缩小过程中会失去其光滑的边缘，这就导致了锯齿现象的生成
- 为了避免锯齿问题，我们可以做出以下措施：
  - 采用更高分辨率的设备，这可以通过提升分辨率来使得字体图标在放大状态下更加平滑，缩小后更不会出现锯齿
  - 使用 SVG 图标，SVG 可以无限放大而不失真
  - 通过 CSS 隐藏字体图标的 4 个顶点，即顶角，使得上下左右有缺口，这样锯齿可以变成缺口，从而对锯齿问题进行遮盖而不是直接解决
  - 通过更改字体图标属性，例如 text-shadow 等来缓解锯齿问题
  - 通过缩小或放大字体图标在某些大小或倍数下，找到一个合适的比例，使字体图标正常显示，避免锯齿问题的产生

## 7. 图片相关性能优化

1. 精灵图（雪碧图）：（减少请求次数）
   - 如果一个页面有上百张图片，哪怕是很小的图标，都需要经历一次请求响应过程，那么肯定会由于请求数量的增加让整个页面的加载速度降低。将大量的小图标整合到一张图，从而减少发送请求的次数，提高页面的加载速度
   - 实质就是利用背景图和背景图的位置去显示同一张图上，不同位置的图片，进而在引入一张图的前提下，显示不同图片
   - 但是当整合图片比较大时，一次加载比较慢，随着字体图片，base64 等的流行，该技术渐渐使用的变少了
2. base64：（减少请求次数）
   - 直接把图片通过 base64 编码，然后放入 css 文件中，可以减少请求次数
   - 但是编码后大小大约比原始值扩大了 33%，如果图片过大，会使 css 文件过大，一般小于 10k 才会用 base64 编码
3. 图片懒加载：（减少首屏渲染时间）
   - 为了首屏渲染更快，图片可设置一张加载图代替，当页面在可视区域内时在替换为正真的图片
4. 图片预加载：（减少用户等待时间）
   - 提前加载所需要的图片资源，加载完毕后会缓存到本地，当需要时可以立马显示出来，以达到在预览的过程中，无需等待直接预览的良好体验，例 看漫画
   - 预加载会占用较多的后台资源，因为可能一次性加载较多的图片，一般是利用用户进行其他操作时进行（如漫画是在用户看上一个图片时进行预加载），或者是在等待的这段时间显示其他（如显示进度条）
   - 可借助 Image 对象，它代表嵌入的图像，常用来做预加载图片
     ```
     let img = new Image()
     img.src = urlList[count] // 预加载第 count 张图片（异步）
     img.onload = function() {// 加载完后处理函数
       count++
       img.src = urlList[count] // 预加载下一张图片（异步）（即每次加载完加载下一张）
     }
     ```
   - 也可直接设置 img 标签的 loading 属性，指示浏览器应当如何加载该图像
     - 值为 lazy 时，实现图片的懒加载，当图片进入视口时，浏览器会自动加载图片
     - 值为 eager 时，立即加载图像，不管它是否在可视视口（默认值）
5. 使用字体图标来代替图片：（减少请求资源大小）
   - 借助字体图标，我们可以如同操作文字一样操作字体图标，例 颜色的切换，大小的改变
   - 可以将多个图标整合到一个字体文件中，从而减少网页的请求次数，字体图标是“雪碧图”的良好替代品，相较于“雪碧图”，字体图标的使用更加方便，简单，快捷
   - 对字体图标进行放大不会出现失真，缩小不会浪费掉像素点
   - 但由于字体图标本质上就是文字，所以字体图标不能像图片那样有着丰富多彩的颜色，它只能是单色或者渐变色
   - 但字体图标不能像图片一样预览，只能在页面上渲染出来后才能看到具体的形状
   - 常用如 Iconfont-阿里巴巴矢量图标库，IcoMoon 等
