## 1. props，\$emit

- 父组件通过 props 的方式向子组件传递数据
  - 第一，prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。所以不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 computed 属性进行转换
  - 第二，如果 props 传递的是引用类型（对象或者数组），在子组件中改变这个对象或数组，父组件的状态会也会做相应的更新，利用这一点就能够实现父子组件数据的“双向绑定”，虽然这样实现能够节省代码，但会牺牲数据流向的简洁性，令人难以理解，最好不要这样去做，还是用 JSON.parse(JSON.stringify(xxx)) 处理一下比较好
- $emit 子组件可以向父组件通信
  - 父组件在子组件上通过 v-on 绑定事件，子组件中，通过 emit 触发，通过传参的方式传递数据

## 2. v-model 指令

- v-model 是用来在表单控件或者组件上创建双向绑定的，他的本质是 v-bind 和 v-on 的语法糖，在一个组件上使用 v-model，默认会为组件绑定名为 value 的 prop 和名为 input 的事件

## 3. .sync 修饰符

- .sync 修饰符在 vue 1.x 的版本中就已经提供，1.x 版本中，当子组件改变了一个带有 .sync 的 prop 的值时，会将这个值同步到父组件中的值。这样使用起来十分方便，但问题也十分明显，这样破坏了单向数据流，当应用复杂时，debug 的成本会非常高
- 所以在 vue 2.0 中移除了 .sync，但是在实际的应用中，.sync 是有它的应用场景的，所以在 vue 2.3 版本中，又迎来了全新的 .sync
- 新的 .sync 修饰符所实现的已经不再是真正的双向绑定，它的本质和 v-model 类似，只是一种语法糖，都不是真正的双向绑定
  ```
  v-bind:title.sync 等效于 v-bind:title="doc.title" v-on:update:title="doc.title = $event"
  ```
- 和 v-model 的区别：
  - 相比较之下，.sync 更加灵活，它可以给多个 prop 使用，而 v-model 在一个组件中只能有一个
  - 从语义上来看，v-model 绑定的值是指这个组件的绑定值，比如 input 组件，select 组件，日期时间选择组件，颜色选择器组件，这些组件所绑定的值使用 v-model 比较合适。其他情况，没有这种语义，个人认为使用 .sync 更好

## 4. \$parent，\$children

- 通过 \$parent 和 \$children 就可以访问组件的实例，即代表可以访问此组件的所有方法和 data
- \$children 的值是数组，而 \$parent 是个对象
- 边界情况，如在 #app 上拿 \$parent 得到的是 new Vue() 的实例，在这实例上再拿 \$parent 得到的是 undefined，而在最底层的子组件拿 $children 是个空数组

```
// 获取并修改子组件 0
this.$children[0].message = 'this is new value'
// 获取并修改父组件
this.$parent.message = 'this is new value';
```

## 5. provide，inject

- 是 vue2.2.0 新增的 api，即祖先组件中通过 provide 来提供变量，然后再子孙组件中通过 inject 来注入变量
- 如果是基础类型变量，provide 和 inject 绑定并不是可响应的，如果是引用类型变量，则是可响应的
  ```
  provide() {
      return {
        test: this.msg; // 相当于是指传递了值
      }
  },
  ```
- 可用于实现全局变量，绑定到最顶层的组件 app.vue，这样所有后代都接收到了，就是当做全局变量来用

## 6. ref，$refs

- 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素
- 如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据，是父组件控制子组件的一种方式，但如果子组件想向父组件传参或操作，只能通过其他的方式了

## 7. eventBus

- 原理就是消息订阅与发布
  - 需要数据的地方订阅消息
  - 提供数据的地方发布消息
- 即事件总线，步骤为：
  1.  初始化
      - 创建一个 .js 文件
        ```
        // event-bus.js
        import Vue from 'vue'
        export const EventBus = new Vue()
        ```
      - 修改 main.js 文件
        ```
        // main.js
        Vue.prototype.$EventBus = new Vue()
        ```
  2.  发生事件
      ```
      import { EventBus } from './event-bus.js'
      EventBus.$emit('addition', {
          num: this.num++
      })
      ```
  3.  接收事件
      ```
      import { EventBus } from './event-bus.js'
      EventBus.$on('addition', param => {
          this.count = this.count + param.num;
      })
      ```
  4.  移除事件监听者
      ```
      import { eventBus } from 'event-bus.js'
      EventBus.$off('addition')
      ```
- 也可以通过第三方库实现消息订阅与发布，例 pubsub.js

## 8. vuex

- state：用于数据的存储，是 store 中的唯一数据源
- getters：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算
- mutations：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件
- actions：类似于 mutation，用于提交 mutation 来改变状态，而不直接变更状态，可以包含任意异步操作
- modules：类似于命名空间，因为应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store 对象就有可能变得相当臃肿，所以 modules 用于项目中将各个模块的状态分开定义和操作，便于维护

## 9. Pinia（ 代替 vuex 的新方案 ）

#### 和 vuex 的区别

- 核心概念区别
  - Vuex 的核心概念有 state，getters，mutations（同步），actions（异步），moudles 五个部分
  - Pinia 的核心概念有 state，getter，action（同步异步都支持） 三个部分
  - 为什么去掉 mutations ？
    - mutation 已被弃用，vuex 是 action 中调用 mutation 再修改状态，所以它经常被认为是冗余的
  - 为什么去掉 moudles ？
    - 不再有嵌套结构的 moudles，store 的命名取决于它的定义方式，实现一种扁平架构
- 更加轻量，压缩后体积只有 2kb 左右
- 更加支持 typescript，无需创建自定义复杂包装器来支持 typeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断

#### 可以跟面试官谈的

> vuex5 提案是：

    1. 选项式 和 组合式 都支持
    2. 没有 mutations

3.  没有嵌套的模块
4.  使用 typescript 重构，为了支持 typescript（ 所以 vuex 源代码是 javascript，而 pinia 是 typescript ）
    >     5. 自动代码分割

- Pinia 就是完整的符合了当时 Vuex5 提案所提到的功能点，所以可以说 Pinia 就是 Vuex5 也不为过，因为它的作者就是官方的开发人员，并且已经被官方接管了，只是目前 Vuex 和 Pinia 还是两个独立的仓库，以后可能会合并，也可能独立发展，只是官方肯定推荐的是 Pinia

## 10. localStorage，sessionStorage

- 这种通信比较简单，缺点是数据和状态比较混乱，不太容易维护
  - 通过 window.localStorage.getItem(key) 获取数据
  - 通过 window.localStorage.setItem(key, value) 存储数据
- 可以结合 vuex，实现数据的持久保存，同时使用 vuex 解决数据和状态混乱问题

## 11. 自己实现简单的 store 模式

- 因为对于小型的项目，使用 vuex 会显得冗余和繁琐，这种情况可以自己在项目中实现简单的 store，就是一个 state 存储数据，然后通过方法来修改 state 中的数据
  ```
  // store.js
  const store = {
    debug: true, // 如果是调试阶段，则会打印一些触发痕迹，方便调试
    state: {
      author: 'abc'
    },
    setAuthorAction (newValue) {
      if (this.debug) console.log('setAuthorAction triggered with', newValue)
      this.state.author = newValue
    },
    deleteAuthorAction () {
      if (this.debug) console.log('deleteAuthorAction triggered')
      this.state.author = ''
    }
  }
  export default store
  ```
- 上面代码原理就是，store.js 文件暴露出一个对象 store，通过引入 store.js 文件，然后各个页面来共同维护这个 store 对象。能这么做的前提是，ES6 模块是动态引用，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。此外，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是相同实例
- 和 vuex 一样，store 中 state 的改变都由 store 内部的 action 来触发，并且能够通过 console.log() 打印触发的痕迹。这种方式十分适合在不需要使用 Vuex 的小项目中应用。与 $root 访问根实例的方法相比，这种集中式状态管理的方式能够在调试过程中，通过 console.log() 记录来确定当前变化是如何触发的，更容易定位问题

## 12. 通过 \$root 访问根实例

- 通过 $root，任何组件都可以获取当前组件树的根 Vue 实例，通过维护根实例上的 data，就可以实现组件间的数据共享

## 13. \$attrs，\$listeners

- 比如存在 组件 A，其子组件为 组件 B，其孙组件为 组件 C，如果 A 和 C 要实现通讯
  - 用之前的方法：
    - props，\$emit：我们可以使用组件 B 来做通信的中转站，当组件 A 需要把数据传到组件 C 时，组件 A 通过 props 将数据传给组件 B，然后组件 B 再用 props 传给组件 C，这是一种解决方案，但是如果嵌套的组件过多，就会导致代码冗余且繁琐，维护就比较困难，而且如果组件 C 也要将数据传给组件 A，也要一层一层往上传递，就更麻烦了
    - 自定义一个事件总线，这种适合组件跨级传递数据，但是缺点是碰到多人合作时，会导致代码的维护性较低，代码可读性也较低
    - 使用 vuex 来进行数据管理，但是如果仅仅是传递数据, 而不做中间处理,使用 vuex 处理感觉有点大材小用了
    - 还有一种解决方案，就是用 provide，inject，但是这种方式，官方不推荐，因为这个方法真的是太不好管控了，比如说我在根组件 provide 了 一个对象，子孙组件去使用了 该对象 里面的一个变量，这时候很难去跟踪到这个变量的出处了，而且也并不知道，项目中哪个组件有用到这个变量，有没有在其他组件中进行改变，所以这个 api 在项目中很少人使用，但是很多人拿来写组件用
- \$attrs：包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)，并且可以通过 v-bind="\$attrs" 传入内部组件。当一个组件没有声明任何 props 时，它包含所有父作用域的绑定 (class 和 style 除外)
- \$listeners：包含了父作用域中的 (不含 .native 修饰符) v-on 事件监听器。它可以通过 v-on="\$listeners" 传入内部组件。它是一个对象，里面包含了作用在这个组件上的所有事件监听器，相当于子组件继承了父组件的事件
- 举例

  ```
  // father.vue 组件
  <template>
  　　 <child :name="name" :age="age" :infoObj="infoObj" @updateInfo="updateInfo" @delInfo="delInfo" />
  </template>
  <script>
      import Child from '../components/child.vue'

      export default {
          name: 'father',
          components: { Child },
          data () {
              return {
                  name: 'abc',
                  age: 22,
                  infoObj: {
                      from: '广东',
                      job: 'policeman',
                      hobby: ['reading', 'writing', 'skating']
                  }
              }
          },
          methods: {
              updateInfo() {
                  console.log('update info');
              },
              delInfo() {
                  console.log('delete info');
              }
          }
      }
  </script>
  ```

  ```
  // child.vue 组件
  <template>
      <!-- 通过 $listeners 将父作用域中的事件，传入 grandSon 组件，使其可以获取到 father 中的事件 -->
      <grand-son :height="height" :weight="weight" @addInfo="addInfo" v-bind="$attrs" v-on="$listeners"  />
  </template>
  <script>
      import GrandSon from '../components/grandSon.vue'
      export default {
          name: 'child',
          components: { GrandSon },
          props: ['name'],
          data() {
            return {
                height: '180cm',
                weight: '70kg'
            };
          },
          created() {
              console.log(this.$attrs);
  　　　　　  // 结果：age, infoObj
  　　　　　  // 虽然父组件共传来name, age, infoObj三个值，由于name被 props接收了，所以只有age, infoObj属性
              console.log(this.$listeners); // updateInfo: f, delInfo: f
          },
          methods: {
              addInfo () {
                  console.log('add info')
              }
          }
      }
  </script>
  ```

  ```
  // grandSon.vue 组件
  <template>
      <div>
          {{ $attrs }} --- {{ $listeners }}
      <div>
  </template>
  <script>
      export default {
          props: ['weight'],
          created() {
              console.log(this.$attrs); // age, infoObj, height
              console.log(this.$listeners) // updateInfo: f, delInfo: f, addInfo: f
              this.$emit('updateInfo') // 可以触发 father 组件中的updateInfo函数
          }
      }
  </script>
  ```

- \$attrs / \$listeners ，通常配合 inheritAttrs 一起使用

  - 在版本 2.4 以前，默认情况下父作用域的不被认作 props 的属性，将会 “回退” 且作为普通的 HTML 特性应用在子组件的根元素上，在 2.4 中新增选项 inheritAttrs，inheritAttrs 的默认值为 true，将 inheritAttrs 的值设为 false，这些默认的行为会禁止掉
  - 即，当子组件的 props 中未注册父组件传递过来的属性

    ```
    // 父组件传递属性，但子组件并未注册接收
    <child-component aaa="1111"></child-component>
    ```

    - 当设置 inheritAttrs: true（默认）时，子组件的顶层标签元素中（本例子的 div 元素）会渲染出父组件传递过来的属性（本例子的 aaa="1111"）

    <image src="https://img-blog.csdnimg.cn/86511a655b184b348e2671584a1f257e.png">

    - 当设置 inheritAttrs: false 时，子组件的顶层标签元素中（本例子的 div 元素）不会渲染出父组件传递过来的属性（本例子的 aaa="1111"）

    <img src="https://img-blog.csdnimg.cn/e0e0398eb5b94675b434fa4ee46170cc.png">

    - 不管 inheritAttrs 为 true 或者 false，子组件中都能通过 $attrs 属性获取到父组件中传递过来的属性

## 14. 组件间通信总结

- 父子组件通信: props、$parent / $children、 provide / inject 、 ref \ $refs 、 $attrs / $listeners
- 兄弟组件通信: eventBus 、 vuex、 自己实现简单的 Store 模式
- 跨级通信: eventBus、 Vuex、 自己实现简单的 Store 模式、 provide / inject 、 $attrs / $listeners
