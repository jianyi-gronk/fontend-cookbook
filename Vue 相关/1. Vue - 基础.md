## 1. vue 的生命周期

1. 介绍一下有哪几个
   - vue2 中的生命周期有 11 个，分别为 beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed，activated，deactivated，errorCaptured，而 vue3 中采用组合式 api，将各个生命周期前面加上 on 作为 api，但没有 onBeforeCreate 和 onCreated，多出来了 setup，并且将 beforeDestroy 和 destroyed 分别改名为 onBeforeUnmount 和 onUnmounted
2. 一般在哪个生命周期进行数据请求
   - created 和 mounted 都可以，基本上是 created，因为 vue 是数据驱动的，也就是说只要能操作到 data 中的数据时即可请求（ 要把数据挂载到 data 上 ），如果请求需要获取，借助，依赖，改变 dom，这时请求放在 mounted
   - beforeMount 也行，但是没必要，不如 created 早，还获取不到 dom
3. activated 和 deactivated
   1. 设置了 keep-alive 缓存的组件，会多出这两个生命周期钩子
   2. 首次进入组件时：beforeRouteEnter > beforeCreate > created> mounted > activated > ... ... > beforeRouteLeave > deactivated
   3. 再次进入组件时：beforeRouteEnter >activated > ... ... > beforeRouteLeave > deactivated

## 2. v-if 和 v-show 区别

1. v-if 是惰性的，只有当第一次为 true 的时候，才会渲染元素
2. v-if 相当于把元素从 dom 树中删除，而 v-show 相当于把 display 设为 none，所以频繁的修改元素是否显示，一般用 v-show

## 3. v-if 和 v-for 能否一起使用

vue2 中 v-for 的优先级高于 v-if，vue3 中 v-if 的优先级高于 v-for

## 4. Vue2 和 Vue3 的区别

#### 概括

1. 性能改进：
   - Vue3 的性能得到了显著提升，包括更小的打包尺寸、更快的渲染速度和更少的内存占用
   - Vue3 的虚拟 DOM 重写，使其渲染性能和更新性能得到了提升
   - Vue3 使用了 Proxy 对象，替代了 Vue2 中的 Object.defineProperty，实现了更高效的响应式系统
2. Composition API：
   - Vue3 引入了全新的 Composition API，它是一个可选的、更灵活的逻辑复用和组织方式，以取代 Vue2 中的 Mixins 和 Scoped Slots
   - Composition API 提供了 ref 和 reactive 函数来创建响应式数据，以及 computed 和 watch 等一系列与响应式数据处理相关的函数
   - 使用 Composition API 可以更好地组织和管理代码，解决大型组件的逻辑复杂性问题
3. 更好的 TypeScript 支持：
   - Vue3 使用 TypeScript 重写，从而为 Vue 开发者提供了更好的类型推断和类型检查支持
   - Vue3 的 Composition API 也提供了更友好的 TypeScript 支持
4. 多根组件：
   - Vue3 允许在单文件组件（ SFC ）中使用多个根元素，而 Vue2 只能有一个根元素
5. Fragment, Teleport 和 Suspense：
   - Fragment 是 Vue3 中的新特性，它允许组件返回多个根节点
   - Teleport 提供了一种在组件树的其他位置渲染子组件内容的方法，例如模态框、提示框等
   - Suspense 是 Vue3 中的实验性特性，用于在组件等待异步依赖时显示一个 fallback 内容，可以简化异步组件的加载和错误处理
6. 自定义指令 API 改进：
   - Vue3 改进了自定义指令的 API，使其更加一致和易于使用。Vue3 中的自定义指令需要使用一个具有多个生命周期钩子的对象（如 beforeMount、mounted、beforeUpdate 等），而不是 Vue2 中的单一函数
7. 移除过滤器：
   - Vue3 移除了过滤器（ Filters ）的概念，推荐使用计算属性（ Computed properties ）或方法（ Methods ）替代
8. 全局 API 和内置组件的变更：
   - Vue3 重新组织了全局 API，将全局 API（ 如 Vue.component、Vue.directive 等 ）移到了应用实例上，以提高模块化和可维护性
   - Vue3 中，内置组件（ 如 keep-alive、transition、transition-group 等 ）需要显式导入和注册

#### 为什么 Vue3 对 TypeScript 更加支持

1. 因为 Vue3 的源代码完全使用 TypeScript 编写，这意味着 Vue3 本身的类型定义更加完善和一致
2. Vue3 的官方库（如 vue-router 和 vuex）也使用 TypeScript 编写，第三方库也逐渐开始支持 Typescript

## 5. v-model 的原理

#### v-model 用在 input 上

- 绑定在 input 上时，v-model 其实就是 v-bind 绑定 value 和 v-on 监听 input 事件的结合体
  1.  v-bind 绑定一个 value 属性
  2.  v-on 指令给当前元素绑定 input 事件
- 模拟实现：
  ```
  // 1. 通过 v-bind:value 绑定 username 变量，每次输入内容的时候触发input事件
  // 2. 通过事件对象参数 event.target.value 获得输入的内容，并且把这个内容赋值给username
  // 3. 此时更改username时input输入框会变化，更改input输入框时username变量会变，从而实现了v-model的双向绑定功能
  <input v-model="username" />
  <input type="text" :value="username" @input="username = $event.target.value" />
  ```

#### v-model 用在组件上

- 实现场景：父组件 price 的初始值是 100，子组件是一个输入框；输入框的值改变时，能实时更新父组件的 price

  ```
  // 父组件
  <currency-input v-model="price"></currentcy-input>
  // 相当于 <currency-input :value="price" @input="price = $event.target.value"></currency-input>
  // 所以相当于向子组件传了一个 value 值，和绑定了一个 input 事件

  // 子组件
  <template>
      <input
        :value="value"
         @input="$emit('input', $event.target.value)"
    />
  </template>

  <script>
  export default {
      props: {
        value: String,  // 父组件传过来的 value 值
      }
  }
  </script>
  ```

- 子组件好看一点的写法

  ```
  // 子组件（好看点的写法）
  <template>
    <button @click="add">点击按钮自增 1</button>
  </template>

  <script>
  export default {
    props: {
      value: Number, // 属性名必须是 value
    },

    methods: {
      add() {
        this.$emit('input', this.value + 1) // 事件名必须是 input
      },
    }
  }
  </script>
  ```

- v-model 应用到组件上，会有一些体验不好的场景，因为它默认会把 value 作为组件的属性，把 input 作为给组件绑定事件时的事件名
- 但在 Vue 2.2 及以上版本，你可以在定义组件时通过 model 选项的方式来定制 prop / event：

  ```
  // 父组件
  <my-button v-model="number"></my-button>

  // 子组件
  <template>
      <button @click="add">点击按钮自增 1</button>
  </template>

  <script>
  export default {
      model: {
        prop: 'num', // 自定义属性名
        event: 'addNum' // 自定义事件名
     },
      props: {
        num: Number,
      },
      methods: {
        add() {
            this.$emit('addNum', this.num + 1)
        },
      }
  }
  </script>
  ```

## 6. watch 和 computed 的区别

- 功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。
- 是否调用缓存：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。
- 是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。
- computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）
- 使用场景：computed ---- 当一个属性受多个属性影响的时候，使用 computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用 watch -----搜索框

## 7. defineProperty 与 proxy 的优缺点

#### defineProperty 的优缺点

- 优点：
  - 兼容性好
  - 性能好
- 缺点：
  - 无法检测到对象属性的新增或删除 和 数组内部的变化
    （ vue 为了监听数组变化重写了 push，pop，unshift，shift，splice，sort，reverse ）

#### Proxy 的优缺点

- 优点
  - Proxy 可以监听嵌套，这样就不需要知道提前知道要拦截的所有属性，而 Object.defineProperty() 的 getter/setter 就不能嵌套
- 缺点
  - 兼容性差
    1. Babel 可以将较新版本的 JavaScript 代码转换成老旧浏览器能够运行的代码
    2. 在处理 Proxy 兼容性问题时，Babel 会检测当前环境是否支持原生的 Proxy 对象。如果当前环境不支持原生的 Proxy 对象，Babel 就会通过内置的 polyfill（垫片）来模拟实现 Proxy 对象的功能，以解决兼容性问题
    3. 这个 polyfill 可以在 Babel 的 @babel/plugin-proposal-proxy-instrumentation 插件中使用。该插件会将代码中的 Proxy 相关语法转换为对 polyfill 中的函数的调用，从而实现对 Proxy 对象的模拟实现
    4. 需要注意的是，虽然 polyfill 可以提供与原生 Proxy 对象相似的功能，但由于其实现方式不同，因此在某些情况下可能会导致性能或行为差异等问题
  - 性能差
    - 虽然 proxy 有性能问题，但同样性能很差的 Promise 在最近几年中也被快速采用，并且 proxy 作为新标准将受到浏览器厂商重点持续的性能优化
