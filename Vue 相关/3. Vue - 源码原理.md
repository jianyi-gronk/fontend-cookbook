## 1. 响应式原理

#### 基础概念

- 指当组件的数据发生变化时，视图会自动更新，而无需手动操作 DOM，即数据驱动 DOM 视图的变化，是单向的过程
- Vue 的响应式是建立在数据劫持机制（ 数据劫持的原理是 Object.defineproperty 和 proxy ）基础上的一种编程模式，它通过数据劫持来实现双向绑定的特性，从而让开发者更加方便地管理视图与状态

#### 核心原理

- 在组件实例化时，会对组件的 data 对象进行递归遍历，将每个属性添加 getter/setter，从而实现数据劫持
- 当组件的 data 对象中的属性被读取时，会触发 getter 函数，Watcher 会将自身添加到该数据所对应的依赖收集器中（ 收集依赖 ）
- 当属性被修改时，会触发 setter 函数，属性对应的依赖收集器会通知所有依赖于它的 Watcher 进行更新视图（ 派发更新 ）
- 为了保证数据的一致性，Vue.js 会为每个组件实例创建一个 Watcher 对象，用来管理该组件的依赖收集和更新视图，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染

#### 根据数据更新 DOM

- Vue 在更新 DOM 时是 **“异步”** 执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在**同一事件循环**中发生的所有数据变更
- 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。会在**下一个事件循环**中，Vue 刷新队列并执行实际 (已去重的) 工作
- Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替

## 2. 双向绑定原理

#### 基础概念

- 双向数据绑定就是无论用户更新 View 还是 Model，另一个都能跟着自动更新，是一个双向的关系
- 响应式只是双向绑定的一环（ Model 到 View 的一环 ）
- 而 View 到 Model 的原理，既是通过事件绑定，比如输入事件的时候，更新 Model 中的数据

#### vue 中的实现

- Vue 中体现出的双向绑定有两种方式：v-model 和 .sync
- v-model：
  - 主要用于在表单控件（如 input、textarea、select 等）和数据对象的属性之间建立双向绑定关系
    - v-model 实际上是一个语法糖，它结合了 v-bind 和 v-on 指令，在不同的表单控件上有不同的实现
      - 对于普通的 input 和 textarea 元素，v-model 会将数据绑定到元素的 value 属性，并监听 input 事件。当用户输入时，v-model 会将新值传递给数据对象的属性
      - 对于单选按钮、复选按钮和下拉列表，v-model 会将数据绑定到元素的 checked 或 selected 属性，并监听 change 事件。当用户进行选择时，v-model 会将新值传递给数据对象的属性
      ```javascript
      <input type="text" v-model="message">
      //相当于
      <input type="text" v-bind:value="message" v-on:input="message=$event.target.value">
      ```
  - 有时也会作用在组件上，v-model 默认会利用名为 value 的 prop 和名为 input 的事件
- .sync

  - 父组件向子组件用 props 传递数据时，它只能单向传递，而使用 .sync 可以实现子组件修改父组件的数据

    ```javascript
    <!-- 父组件给子组件传入一个setNum函数 -->
    <child :num.sync="numParent">

    <script>
    //子组件通过调用这个函数来实现修改父组件的状态
    methods: {
      changNum() {
          this.$emit('update:num',666)
      }
    }
    </script>
    ```

## 3. nextTick 原理

#### 使用场景

- 因为 vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新 DOM，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更，这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作 DOM 的次数
- 如果不采用这种方法，假设数据改变 100 次就要去更新 100 次 DOM，而频繁的 DOM 更新是很耗性能的，所以不能直接操作基于最新的数据生成的最新数据，需要靠 nextTick()

#### nextTick 作用

nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到 DOM 更新后才执行

#### nextTick 原理

[详情](https://juejin.cn/post/7102750403418128391)
将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务

## 4. Diff 原理

#### 虚拟 DOM

- 本质就是一个对象，上面有一些描述这个 DOM 的属性
- 优点（ 主要是前面两个 ）
  - 提高性能
    - 虚拟 DOM 可以在不必要的情况下避免频繁地操作 DOM，通过将多个操作合并为一个操作来提高性能
    - 虚拟 DOM 还可以通过比较新旧虚拟 DOM 树来找到需要更新的节点，减少不必要的 DOM 操作
  - 减少空间浪费
    - 因为真实 DOM 上有一堆属性，然后我们可能很多都用不上，比如 diff 比较的时候，用不到那么多属性
  - 跨平台
    - 虚拟 DOM 可以在浏览器环境和服务器端环境中运行，使得前后端代码复用更加方便
  - 方便维护和开发
    - 使用虚拟 DOM，我们可以将视图和业务逻辑分离，从而使得代码更加清晰和易于维护。另外，虚拟 DOM 也为开发者提供了更加高级的 API 和工具，例如 React 中的 JSX 和 Vue 中的模板语法

#### diff 复杂度

- 两个树的完全的 diff 算法是一个时间复杂度为 O(n^3)，Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题（只比较同级不考虑跨级问题），因为在前端操作 DOM 的时候了，不会把当前元素作为上一级元素或下一级元素，很少会跨越层级地移动 Dom 元素，常见的都是同级的比较。所以 Virtual Dom 只会对同一个层级的元素进行对比
  > O(n^3) 的复杂度是因为树的比较，很麻烦
  > 对于树，我们定义三种操作，用来将一棵树转化为另外一棵树：
  >
  > - 删除：删除一个节点，将它的 children 交给它的父节点
  > - 插入：在 children 中插入一个节点
  > - 修改：修改节点的值

#### Vue2 和 Vue3 的 diff 区别

- 静态树提升：
  - Vue3 会在编译阶段自动检测不会发生变化的节点（静态树），并将它们提升到渲染函数的外部。这样，在组件重新渲染时，静态树就不会再被重新创建和比较，从而降低了 diff 算法的计算负担。静态树提升减少了不必要的渲染，提高了渲染性能
  - 比如 \<h1 class="title"\>Hello, Vue3!\</h1\>， \<h1\> 标签及内容是静态的，不会发生变化的部分就不会被重新创建和比较
- 静态属性提升：
  - Vue3 也会在编译阶段自动检测元素上的静态属性（如 id、class 等），并将它们提升到渲染函数的外部。这样，在组件重新渲染时，这些静态属性就不会再被重新创建和比较，从而减少了虚拟 DOM 节点的创建。静态属性提升进一步降低了 diff 算法的计算负担
  - 比如 \<h1 :class="titleClass\>Hello, Vue3!\</h1\>，它的 class 属性是动态的，但是标签本身和其他属性仍然是静态的，当 Vue3 编译这个模板时，它会将静态部分提升到渲染函数的外部，当组件重新渲染时，Vue3 的 diff 算法会跳过提升的静态部分，仅关注动态部分
- 基于块（block）的更新策略：
  - Vue3 在编译阶段会将模板划分为许多独立的块，每个块都包含一个或多个动态节点。当模板中的数据发生变化时，Vue 3 不需要遍历整个组件树，而是可以直接定位到包含发生变化的动态节点的块，从而跳过那些不需要更新的块。这种基于块的更新策略使得 diff 算法更加高效，有助于提高更新性能
  - Vue3 会根据模板的结构和动态节点的分布情况来合理地划分块，以实现最佳的性能优化。在某些情况下，Vue3 会将多个相邻的动态节点合并到一个块中，以减少块的数量。这样，Vue3 可以在保持高性能的同时，避免产生过多的块
- 更好的 diff 算法：
  - Vue3 的 diff 算法得到了优化，可以更高效地处理节点的添加、删除、移动等操作
  - 具体原因：
    - 因为静态节点提升，静态属性提升，基于块的更新
    - 更精确的更新范围：
      - Vue3 的 diff 算法更具针对性地比较子组件的更新，只有在相关 prop 或插槽内容发生变化时，才会触发子组件的更新。这减少了不必要的子组件更新，提高了性能
    - 优化的 Fragment diff：
      - Vue3 支持 Fragments，即允许组件返回多个根节点。Vue3 的 diff 算法针对 Fragments 进行了优化，保证了在存在多个根节点的情况下，diff 过程仍然高效
- 更小的体积：
  - Vue3 的源码经过优化，使得虚拟 DOM 的实现更加简洁，整个库的体积更小。较小的体积意味着更快的加载速度和更低的内存占用，有助于提高整体性能
- 优化的事件处理和组件实例：
  - Vue3 进一步优化了事件处理机制和组件实例的创建过程，使得组件的初始化和更新更加高效。这可以提高整个应用的性能，使得 Vue3 更加适合大型应用和高性能需求

#### 标记节点

- 在 Vue 3 中，vnode 对象代表着一个虚拟节点，其中包含了节点的各种属性和方法。shapeFlag 属性是 vnode 对象的一个属性，它用于表示当前节点的类型和特征，并根据不同的组合值进行位运算生成。可用于方便静态节点和非静态节点分别处理
- 但 shapeFlag 属性是 vue 内部使用的属性，在普通开发中不需要直接使用它
- 以下是 shapeFlag 属性的一些可能取值：
  - ELEMENT：表示当前节点是普通的 HTML 元素
  - STATEFUL_COMPONENT：表示当前节点是有状态的组件
  - TEXT_CHILDREN：表示当前节点只有文本子节点
  - ARRAY_CHILDREN：表示当前节点有多个子节点
  - SLOTS_CHILDREN：表示当前节点包含插槽内容
  - TELEPORT：表示当前节点是一个 teleport（ 瞬移 ）组件
  - SUSPENSE: 表示当前节点是一个 suspense（ 暂停 ）组件
  - COMPONENT：表示当前节点是一个函数式组件或者无状态组件
  - STABLE_FRAGMENT：表示当前节点是一个稳定的片段，即该片段的子节点不会改变
  - KEYED_FRAGMENT：表示当前节点是一个带有 key 的片段

## 5. 路由原理

#### hash 模式

- 原理：
  hash 就是指 url 中 # 号后面的字符，由于 hash 值的变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 onhashchange 事件（onhashchange 是 window 对象的属性），假如在 onhashChange 事件中获取当前的 hash 值，并根据 hash 值来修改页面内容，则达到了前端路由的目的
- 特点：
  hash 虽然出现 url 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。hash 本来拿来做页面定位的，如果拿来做路由的话，原来锚点功能就不能用了。hash 模式又叫做前端路由，因为改变 hash 值不会向后端发送请求
- hash 原本功能（锚点功能）：

  - hash（#）是 URL 的锚点，代表的是网页中的一个位置，单单改变 # 后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 # 是用来指导浏览器动作的，对服务器端完全无用，HTTP 请求中也不会不包括 #
  - 同时每一次改变 # 后的部分，都会在浏览器的访问历史中增加一个记录，使用 ”后退” 按钮，就可以回到上一个位置

  ```
  <style>
      div {
          height: 800px;
          width: 400px;
          border: 2px solid black;
      }
      h2 {
          position: fixed;
          margin:50px 500px;
      }
  </style>

  <h2>
      <a href="#div1">to div1</a>
      <a href="#div2">to div2</a>
      <a href="#div3">to div3</a>
  </h2>
  <div id="div1">div1</div>
  <div id="div2">div2</div>
  <div id="div3">div3</div>
  ```

#### history 模式

- 前提：

  - 在 HTML5 之前，浏览器就有 history 对象了，只能用于多页面之间的跳转，有 go()，forward()，back() 方法，在 HTML5 规范中，history 中增加了新的 API，pushState() 和 replaceState()

    ```
    history.go(n) // n>0前进n页；n<0后退n页
    history.forward() // 前进一页
    history.back() // 后退一页

    /*
      参数说明：
        state：合法的JavaScript对象，可以用在popstate对象中
        title：标题，基本忽略，用null
        url: 任意有效的url，将要跳转的新地址
    */
    history.pushState(state, title, url) // 保留现有记录的同时，将url加到历史记录中
    history.replaceState(state, title, url) // 将历史记录中的当前页面替换成url

    // 但replaceState()是修改当前历史记录，而pushState()是创建新的历史记录
    // 实例1，如果当前网页是：www.com

    history.pushState(null,null,'/html.1'); // www.com/html.1
    history.pushState(null,null,'/html.2'); // www.com/html.2
    history.replaceState(null,null,'html.3'); // www.com/html.3   replaceState会替换刚刚那个pathname

    history.back();  // 后退一次，www.com/html.1
    history.back();  // 后退一次，www.com
    history.go(2)   // 前进两次，www.com/html.3
    ```

  - 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。pushState() 方法可以改变 URL 地址且不会发送请求，replaceState() 方法可以读取历史记录栈，还可以对浏览器记录进行修改。这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求

- 原理：
  - history 模式原理可以这样理解，首先我们要改造我们的超链接，给每个超链接增加 onclick 方法，阻止默认的超链接跳转，改用 history.pushState 或 history.replaceState 来更改浏览器中的 url，并修改页面内容。由于通过 history 的 api 调整，并不会向后端发起请求，所以也就达到了前端路由的目的
  - 在浏览器某些行为，比如点击后退、前进按钮（或者在 js 中调用 history.back()，history.forward()，history.go() 方法），则会触发 window.onpopstate 事件，监听页面根据路由地址修改页面内容，但调用 history.pushState() 或 history.replaceState() 不会触发 popstate 事件，所以如果用户使用浏览器的前进后退按钮，也能对应更改页面内容
- 特点：
  - history 模式的 url 发生变化时不会立即向服务器发起请求，刷新会立即请求
  - 浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。因此在线上部署基于 history API 的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404

#### hash 和 history 区别

- 外观：hash 的 url 有个 # 符号，history 没有，所以 history 外观更好看
- 刷新：hash 刷新会加载到地址栏对应的页面，history 刷新浏览器会重新发起请求，如果服务端没有匹配当前的 url，就会出现 404 页面。
- 兼容性：hash 能兼容到 IE8，history 只能兼容到 IE10
- 服务端支持：hash（#及后面的内容）的变化不会导致浏览器向服务器发起请求；history 刷新会重新向服务器发起请求，需要在服务端做处理，例如果没有匹配到资源，就返回同一个 html 页面
- 原理：hash 通过监听浏览器的 onhashchange() 事件，查找对应的路由规则。而 history 利用 H5 新增的 pushState() 和 replaceState() 方法改变 url
- 记录：hash 模式只有 # 后面的内容被修改才会添加新的记录栈。而 history 通过 pushState() 设置的 url 于当前 url 一模一样也会被记录到历史记录栈

## 6. keep-alive 原理

#### vue 渲染原理

![image](https://img-blog.csdnimg.cn/856edd3f565a44739a4f357f29c66b8a.png)

#### keep-alive 作用

- keep-alive 其实就是 vue 自己封装的一个组件，和普通组件一样
- 当 keep-alive 包裹一个动态组件时，将需要保留状态的组件缓存起来，而不是销毁和重新创建。这样，在切换组件时，如果组件已经被缓存，它将直接从缓存中取出组件并重新挂载到 DOM 中，而不是重新加载数据和渲染，从而避免了重新创建组件的开销
- keep-alive 的工作原理如下：
  - 首次加载组件时，会将组件实例缓存起来，同时将组件的 vm.$el（组件实例的根 DOM 元素）从 DOM 树中移除
  - 当切换到其他组件后，原始组件的 vm.$el 会放入一个名为 \_inactive 的数组中保存起来
  - 如果再次切换回原始组件，原始组件的 vm.$el 会从 \_inactive 数组中取出，并重新插入到 DOM 树中

#### keep-alive 属性

- include：
  - 值为 逗号分隔字符串，正则表达式 或 一个数组
  - 只有名称匹配的组件会被缓存
- exclude：
  - 值为 逗号分隔字符串，正则表达式 或 一个数组
  - exclude 优先级高于 include
  - 任何名称匹配的组件都不会被缓存
- max：
  - 值为 字符串 或 数字
  - 表示最多可以缓存多少组件实例，超过 max 则按照 LRU 算法进行置换

#### vue3 中 keep-alive 源码

```javascript
const KeepAliveImpl = {
  name: `KeepAlive`,

  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,

  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  setup(props: KeepAliveProps, { slots }: SetupContext) {
    const cache: Cache = new Map()
    const keys: Keys = new Set()
    let current: VNode | null = null

    const instance = getCurrentInstance()!
    // console.log('instance',instance)
    // KeepAlive communicates with the instantiated renderer via the "sink"
    // where the renderer passes in platform-specific functions, and the
    // KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.
    const sink = instance.sink as KeepAliveSink
    const {
      renderer: {
        move,
        unmount: _unmount,
        options: { createElement }
      },
      parentSuspense
    } = sink
    const storageContainer = createElement('div')
    // console.log('sink',sink)
    sink.activate = (vnode, container, anchor) => {
      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)
      queuePostRenderEffect(() => {
        const component = vnode.component!
        component.isDeactivated = false
        if (component.a !== null) {
          invokeHooks(component.a)
        }
      }, parentSuspense)
    }

    sink.deactivate = (vnode: VNode) => {
      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)
      queuePostRenderEffect(() => {
        const component = vnode.component!
        if (component.da !== null) {
          invokeHooks(component.da)
        }
        component.isDeactivated = true
      }, parentSuspense)
    }

    function unmount(vnode: VNode) {
      // reset the shapeFlag so it can be properly unmounted
      vnode.shapeFlag = ShapeFlags.STATEFUL_COMPONENT
      _unmount(vnode, instance, parentSuspense)
    }

    function pruneCache(filter?: (name: string) => boolean) {
      cache.forEach((vnode, key) => {
        const name = getName(vnode.type as Component)
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key)
        }
      })
    }

    function pruneCacheEntry(key: CacheKey) {
      const cached = cache.get(key) as VNode
      if (!current || cached.type !== current.type) {
        unmount(cached)
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        current.shapeFlag = ShapeFlags.STATEFUL_COMPONENT
      }
      cache.delete(key)
      keys.delete(key)
    }

    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache(name => matches(include, name))
        exclude && pruneCache(name => matches(exclude, name))
      },
      { lazy: true }
    )

    onBeforeUnmount(() => {
      cache.forEach(unmount)
    })

    return () => {
      if (!slots.default) {
        return null
      }

      const children = slots.default()
      let vnode = children[0]
      if (children.length > 1) {
        if (__DEV__) {
          warn(`KeepAlive should contain exactly one component child.`)
        }
        current = null
        return children
      } else if (
        !isVNode(vnode) ||
        !(vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT)
      ) {
        current = null
        return vnode
      }

      const comp = vnode.type as Component
      const name = getName(comp)
      const { include, exclude, max } = props

      if (
        (include && (!name || !matches(include, name))) ||
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      const key = vnode.key == null ? comp : vnode.key
      const cached = cache.get(key)

      // clone vnode if it's reused because we are going to mutate it
      if (vnode.el) {
        vnode = cloneVNode(vnode)
      }
      cache.set(key, vnode)
      if (cached) {
        // copy over mounted state
        vnode.el = cached.el
        vnode.anchor = cached.anchor
        vnode.component = cached.component
        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition!)
        }
        // avoid vnode being mounted as fresh
        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE
        // make this key the freshest
        keys.delete(key)
        keys.add(key)
      } else {
        keys.add(key)
        // prune oldest entry
        if (max && keys.size > parseInt(max as string, 10)) {
          pruneCacheEntry(Array.from(keys)[0])
        }
      }
      // avoid vnode being unmounted
      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE
      current = vnode
      return vnode
    }
  }
}
```

#### 基础原理

- keep-alive 在 setup 中初始化一个 cache（ Map 数据类型 ） 和 keys（ Set 数据类型 ），前者键为组件的 key，值为缓存组件的虚拟 DOM，后者用来存缓存组件的 key 集合，并实时监听 include 和 exclude 这两个属性的变化，并执行相应操作
  - 上述的 key 指 const key = vnode.key == null ? comp : vnode.key
    - vnode.key，即 v-for 中需要指定的 key 值
    - comp 值为 vnode.type，即节点的类型，可能有以下几种取值
      - 如果节点是普通的 HTML 元素：vnode.type 将是该元素的标签名，以字符串形式表示，例如 "div", "span", "p" 等
      - 如果节点是注释节点：vnode.type 将是 "comment"
      - 如果节点是文本节点：vnode.type 将是 "text"
      - 如果节点是组件：vnode.type 将是该组件的选项对象，即组件的定义
- 当需要重新渲染缓存的组件时，Vue 将从 cache 对象中查找该组件的实例，并将其重新挂载到 DOM 中，当组件被销毁时，它的实例将从 cache 和 keys 中删除
- 在路由切换的过程会调用 instance.sink.activate() 和 instance.sink.deactivate()

  - 在渲染过程中，Vue 会将这个渲染函数和组件实例对象绑定起来，并使用 instance.sink 属性作为渲染函数的输出流。渲染函数产生的虚拟节点对象会被通过 instance.sink 输出，然后由 Vue 内部的渲染器处理成真正的 DOM 元素并插入页面中
  - instance.sink.activate 和 instance.sink.deactivate 就是控制输出流的开关，用于控制渲染函数的执行和输出。具体来说：
  - instance.sink.activate()：调用这个方法会启动组件的渲染流程，也就是开始执行组件的渲染函数，并将输出流打开，使得渲染结果会被输出到 instance.sink 中。Vue 内部会自动在组件加载、数据变化等时机调用这个方法来保证组件能够正确地显示
  - instance.sink.deactivate()：调用这个方法会停止组件的渲染流程，也就是停止执行组件的渲染函数，并关闭输出流，使得渲染结果不再被输出到 instance.sink 中。这个方法通常用于优化组件的性能。当组件处于不活跃状态时（ 例如被包含在 keep-alive 组件中或者切换到了其他路由 ），我们可以手动调用这个方法来停止组件的渲染，以减少不必要的计算和更新
  - 比如会分别在 instance.sink.activate 和 instance.sink.deactivate 中执行

    ```clike
    // instance.sink.activate
    if (component.a !== null) {
          invokeHooks(component.a) // invokeHooks 可以触发 Vue 组件实例的生命周期钩子函数，例 invokeHooks(['created'])
        }
    component.isDeactivated = false

    // instance.sink.deactivate
    if (component.da !== null) {
          invokeHooks(component.da) // invokeHooks 可以触发 Vue 组件实例的生命周期钩子函数，例 invokeHooks(['created'])
        }
    component.isDeactivated = true
    ```

- keep-alive 会在 onBeforeUnmount 中删除掉所有缓存相关的东西

#### LRU 缓存策略（ Least recently used，最近最少使用 ）

- 即从内存中找出最久未使用的数据置换新的数据，算法根据数据的历史访问记录来进行淘汰数据，其核心思想是如果数据最近被访问过，那么将来被访问的几率也更高。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰
- keep-alive 用非常简单的实现方法，通过 key（ Set 数据类型 ）来记录访问顺序，利用 Set 特性：

  1.  Set 的遍历顺序是按照插入顺序进行的，这样可以记录访问顺序，但是再次插入的相同元素，会被忽略，因此多次插入相同元素不能改变遍历顺序
  2.  所以如果有已经存在于 key 中的元素被再次访问，需要更新顺序，应该将原有元素删除，并重新插入，例源码：
      ```clike
      keys.delete(key)
      keys.add(key)
      ```
  3.  如果设置了 max，需要淘汰最近最少使用的元素，只需要删除 key 的第一个元素即可，例源码：

      ```clike
      pruneCacheEntry(Array.from(keys)[0])

      function pruneCacheEntry(key: CacheKey) {
        cache.delete(key)
          keys.delete(key)
        }
      ```
